// Copyright (c) 2017 ASMlover. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list ofconditions and the following disclaimer.
//
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in
//    the documentation and/or other materialsprovided with the
//    distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";
import "nyx_common.proto";
package nyx.core;

option cc_generic_services = true;
option py_generic_services = true;

// gate与game之间的通信协议

message ClientInfo {
  // gate收到client的请求后，添加ClientInfo信息到routes以便game直到是哪个
  // 客户端发送的请求，以便进行相应的处理
  bytes addr = 1; // 客户端的ip地址
  int32 port = 2; // 客户端的port
  bytes client_id = 3; // 客户端的标识
  bytes session_id = 4; // 服务器session标识
  bytes gate_id = 5; // gate服务器的id信息
}

message GateMailbox {
  ClientInfo client_info = 1;
  bytes entity_id = 2;
}

message ClientBindMessage {
  ClientInfo client_info = 1; // 客户端标识
  ServerInfo server_info = 2; // 新的服务器信息
  bytes entity_id = 3; // 需要转移的entity id
}

message RegisterMd5IndexMessage {
  bytes routes = 1;
  Md5Index md5_index = 2;
}

message GateReturnValue {
  ClientInfo client_info = 1; // 客户端标识信息
  bool return_value = 2; // 返回是否OK
}

message RealEntityCreateInfo {
  ServerInfo dst_server = 1; // 迁移的目标服务器信息
  ServerInfo src_server = 2; // 迁移的源服务器信息
  bytes real_entity_id = 3; // 要迁移的entity id
  bytes real_entity_class = 4; // 要迁移的entity class类型
  bytes pre_trans_entity_id = 5; // 目标服务器占位entity id
  bytes content = 6; // 初始化信息
  bytes client_info_cache = 7; // 如果创建的是一个avatar，需设置cleint info
}

message GateToGameReturnValue {
  enum CallbackType {
    NO_CALLBACK = 0; // 没这个callback
    GATE2GAME_ENTITYMSG = 1; // gate到game的message信息
  }
  CallbackType type = 1; // 默认应该为NO_CALLBACK
  int32 callback_id = 2; // callback id信息，rpc调用时传递
  bool return_bvalue = 3; // bool返回值使用这个
  bytes return_svalue = 4; // 复杂返回值，编码成字符串
  bytes error_msg = 5; // 错误信息
}

message GameLoad {
  double load = 1;
}

message GateInfo {
  bytes gate_id = 1; // gate的id信息
}

message GateRpcMessage {
  Md5Index method = 1;
  bytes params = 2;
}

service SGateToGame {
  // gate服务器与game服务器通信的rpc定义

  // 连接game服务器，进行认证
  rpc connect_server(ConnectRequest) returns(Void);
  // 客户端entity的rpc消息，通过gate服务器转发到game服务器
  rpc entity_message(EntityRpcMessage) returns(Void);
  // 通知game服务器，客户端断开连接了
  rpc client_lose_connection(ClientInfo) returns(Void);
  // gate在准备好后，回复game服务器可以开始迁移entity
  rpc on_transfer_client(GateReturnValue) returns(Void);
  // gate转发的game之间的消息
  rpc forward_entity_message(EntityRpcMessage) returns(Void);
  // 注册gateserver，用于转发消息
  rpc reg_gate_server(GateInfo) returns(Void);
  // gate转发的回调
  rpc gate_callback(GateToGameReturnValue) returns(Void);
  // avatar迁移成功之后，通知就的game server删除相应的绑定
  rpc unbind_client_from_game(ClientInfo) returns(Void);
  // gate服务器通知game服务器创建real entity
  rpc create_real_entity(RealEntityCreateInfo) returns(Void);
  // gate通知game服务器迁移到目标服务器的real entity已经创建成功了
  rpc real_entity_created(EntityMailbox) returns(Void);
  // 客户端发送的md5和index注册消息
  rpc reg_md5index(RegisterMd5IndexMessage) returns(Void);
}

service SGameToGate {
  // game服务器发送给gate服务器的rpc信息

  // 对gate连接请求的应答
  rpc on_connect_server(ConnectResponse) returns(Void);
  // game服务器通知client创建entity，通过gate服务器转发
  rpc create_entity(EntityInfo) returns(Void);
  // game服务器通知client销毁entity，通过gate服务器转发
  rpc destroy_entity(EntityInfo) returns(Void);
  // game服务器通知gate主动断开与client的连接
  rpc disconnect_client(ClientInfo) returns(Void);
  // game服务器通过gate转到到client的entity rpc消息
  rpc entity_message(EntityRpcMessage) returns(Void);
  // game服务器发送到client的global entity消息(通过gate转发到所有client)
  rpc global_entity_message(GlobalEntityRpcMessage) returns(Void);
  // game服务器发送到client的一些带外数据信息
  rpc chat_to_client(OutbandInfo) returns(Void);
  // game服务器通知gate服务器跨进程迁移avatar，需要gate做缓存
  rpc transfer_client(ClientBindMessage) returns(Void);
  // 跨进程转移avatar到新的game，game发送通知给gate
  rpc bind_client_to_game(ClientBindMessage) returns(Void);
  // game通过gate转发消息
  rpc forward_entity_message(EntityRpcMessage) returns(Void);
  // 通知迁移目标game建立了真正的entity
  rpc create_real_entity(RealEntityCreateInfo) returns(Void);
  // 通知gate服务器迁移源game服务器已经创建了真正的entity
  rpc real_entity_created(EntityMailbox) returns(Void);
  // 向客户端注册md5和index信息
  rpc reg_md5index(RegisterMd5IndexMessage) returns(Void);
  // game服务器向gate服务器发送负载情况
  rpc update_game_load(GameLoad) returns(Void);
  // game服务器发送给gate的rpc消息
  rpc gate_method(GateRpcMessage) returns(Void);
}
