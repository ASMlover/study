// Copyright (c) 2017 ASMlover. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list ofconditions and the following disclaimer.
//
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in
//    the documentation and/or other materialsprovided with the
//    distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";
import "Common.proto";
package Nyx.Core;

option cc_generic_services = true;
option py_generic_services = true;

// NyxEngine服务器与客户端通信的基本通信协议
// RPC Service的定义规范：
//  [1] 以`S`开头，表示是RPC Service定义
//  [2] 以`To`来连接通信双方，如SClientToGate表示Client到Gate的协议，需要Gate
//      对定义RPC进行监听、并处理
//  [3] 对于请求返回的RPC函数，尽量以`on_`开头表示对请求的应答回调

// 客户端与Gate之间的基本通信协议
message EncryptString {
  bytes encrypt_str = 1; // 加密的字符串信息
}

message SessionSeed {
  int64 seed = 1; // 加密的随机数种子
}

message SessionKey {
  bytes random_padding_head = 1;
  bytes session_key = 2; // 加密的会话字符串
  int64 seed = 3; // 服务器返回给客户端的随机种子
  bytes random_padding_tail = 4;
}

service SClientToGate {
  // 客户端发送到Gate服务器的RPC请求，需要Gate实现

  // 向Gate服务器请求随机数种子
  rpc request_seed(Void) returns(Void);
  // 向Gate服务器注册通信密钥
  rpc session_key(EncryptString) returns(Void);
  // 连接Gate服务器，进行通信认证
  rpc connect_gate(ConnectRequest) returns(Void);
  // 客户端向服务器发起的RPC调用（这些调用通过Gate进行转发）
  rpc entity_message(EntityMessage) returns(Void);
  // 将客户端字符串的MD5对应索引注册到服务器
  rpc reg_md5index(Md5Index) returns(Void);
}

service SGateToClient {
  // Gate服务器返回给客户端的RPC消息，需要客户端实现

  // 返回客户端请求的随机数种子
  rpc on_request_seed(SessionSeed) returns(Void);
  // 告知客户端注册通信密钥成功
  rpc on_session_key(Void) returns(Void);
  // 回复客户端连接Gate的请求
  rpc on_connect_gate(ConnectResponse) returns(Void);
  // 服务器通知客户端创建Entity（Game通过Gate转发的RPC调用）
  rpc create_entity(EntityInfo) returns(Void);
  // 服务器通知客户端销毁Entity（Game通过Gate转发的RPC调用）
  rpc destroy_entity(EntityInfo) returns(Void);
  // 服务器向客户端发起的RPC调用（这些调用通过Gate进行转发）
  rpc entity_message(EntityMessage) returns(Void);
  // 服务器发送给客户端的带外数据信息
  rpc chat_to_client(OutbandInfo) returns(Void);
  // 将服务器字符串的MD5对应索引注册到客户端
  rpc reg_md5index(Md5Index) returns(Void);
}

// DB操作的基本通信协议（默认使用MongoDB，数据应该是BSON，以便C++化）
// [SUMMARY]
//  [1] - callback_id表示需要回调时的callback的id，必须大于0
//  [2] - query/fields/update/doc/docs应该是BSON编码
//  [3] - status表示DB操作的结果是否成功（bool类型）
message FindDocRequest {
  // 查找操作请求信息
  int32 callback_id = 1;
  bytes db = 2;
  bytes collection = 3;
  bytes query = 4;
  bytes fields = 5;
  int32 limit = 6; // 需要返回的结果数量
  bool seq_flag = 7; // 是否保证有序
  bytes seq_key = 8; // seq_flag操作的key
  bytes sort = 9; // 排序
  int32 read_pref = 10;
  bytes hint = 11;
  bytes skip = 12;
}

message FindDocResponse {
  int32 callback_id = 1;
  bool status = 2;
  bytes docs = 3; // 查询到的数据信息
}

message CountDocRequest {
  // 获取docs的条目数量
  int32 callback_id = 1;
  bytes db = 2;
  bytes collection = 3;
  bytes query = 4;
}

message CountDocResponse {
  int32 callback_id = 1;
  bool status = 2;
  int32 count = 3; // 返回docs的条目数量
}

message UpdateDocRequest {
  // 更新指定的doc数据信息
  int32 callback_id = 1;
  bytes db = 2;
  bytes collection = 3;
  bytes query = 4;
  bytes doc = 5;
  bool upsert = 6; // 如果记录不存在表示是否进行插入操作
  bool multi = 7; // 是否更新多个记录
  bool seq_flag = 8;
  bytes seq_key = 9;
}

message UpdateDocResponse {
  int32 callback_id = 1;
  bool status = 2;
}

message InsertDocRequest {
  // 插入新doc记录的操作
  int32 callback_id = 1;
  bytes db = 2;
  bytes collection = 3;
  bytes doc = 4;
  bool seq_flag = 5;
  bytes seq_key = 6;
}

message InsertDocResponse {
  int32 callback_id = 1;
  bool status = 2;
  bytes insert_id = 3; // 插入成功后返回的记录_id
}

message DeleteDocRequest {
  // 删除某doc的操作
  int32 callback_id = 1;
  bytes db = 2;
  bytes collection = 3;
  bytes query = 4;
  bool seq_flag = 5;
  bytes seq_key = 6;
}

message DeleteDocResponse {
  int32 callback_id = 1;
  bool status = 2;
}

message FindAndModifyDocRequest {
  // 查找并修改doc的操作
  int32 callback_id = 1;
  bytes db = 2;
  bytes collection = 3;
  bytes query = 4;
  bytes fields = 5;
  bytes update = 6;
  bool upsert = 7;
  bool new = 8; // 为真返回修改之后的结果
  bool seq_flag = 9;
  bytes seq_key =  10;
}

message FindAndModifyDocResponse {
  int32 callback_id = 1;
  bool status = 2;
  bytes doc = 3;
}

message OperationIndexRequest {
  // 索引操作请求
  enum OperationType {
    ENSURE = 0;
    DROP = 1;
    RESET = 2;
  }
  int32 callback_id = 1;
  bytes db = 2;
  bytes collection = 3;
  OperationType type = 4;
  bytes query = 5;
  bytes desc = 6;
}

message OperationIndexResponse {
  int32 callback_id = 1;
  bool status = 2;
}

message CreateCollectionRequest {
  // 创建Collection的操作
  int32 callback_id = 1;
  bytes db = 2;
  bytes collection = 3;
  bytes operations = 4; // 创建collection的选项
}

message CreateCollectionResponse {
  enum CreateResult {
    SUCCESS = 0; // 创建成功
    EXISTED = 1; // 创建失败，已经存在该collection
    FAILED = 2; // 创建失败，其他错误
  }
  int32 callback_id = 1;
  CreateResult result = 2;
}

message DBStatusMessage {
  enum StatusType {
    CONNECTED = 0; // DBManager和后台DB服务器连接正常
    CONNECTION_FAIL = 1; // DBManager和后台DB服务器连接失败
    BUSY = 2; // DBManager等待执行的操作队列过长
  }
  StatusType status = 1; // 查询的DBManager状态信息
}

message CallDBRequest {
  int32 callback_id = 1;
  bytes method = 2;
  bytes args = 3;
}

message CallDBResponse {
  int32 callback_id = 1;
  bytes args = 2;
}

service SClientToDBManager {
  // DBManager客户端访问DBManager的RPC操作请求，需要DBManager实现

  // 将Game等作为DBManager客户端的服务器信息注册到DBManager
  rpc reg_client(ServerInfo) returns(Void);
  // 同DBManager通信的RPC接口
  rpc call_db_method(CallDBRequest) returns(Void);
  rpc db_find_doc(FindDocRequest) returns(Void);
  rpc db_update_doc(UpdateDocRequest) returns(Void);
  rpc db_insert_doc(InsertDocRequest) returns(Void);
  rpc db_delete_doc(DeleteDocRequest) returns(Void);
  rpc db_count_doc(CountDocRequest) returns(Void);
  rpc db_find_and_modify_doc(FindAndModifyDocRequest) returns(Void);
  rpc db_operation_index(OperationIndexRequest) returns(Void);
  rpc db_create_collection(CreateCollectionRequest) returns(Void);
}

service SDBManagerToClient {
  // 返回DBManager客户端的通信RPC信息，可能是Game服务器，需DBManager客户端实现

  // 返回DBManager的状态信息
  rpc on_db_status(DBStatusMessage) returns(Void);
  rpc on_call_db_method(CallDBResponse) returns(Void);
  rpc on_db_find_doc(FindDocResponse) returns(Void);
  rpc on_db_update_doc(UpdateDocResponse) returns(Void);
  rpc on_db_insert_doc(InsertDocResponse) returns(Void);
  rpc on_db_delete_doc(DeleteDocResponse) returns(Void);
  rpc on_db_count_doc(CountDocResponse) returns(Void);
  rpc on_db_find_and_modify_doc(FindAndModifyDocResponse) returns(Void);
  rpc on_db_operation_index(OperationIndexResponse) returns(Void);
  rpc on_db_create_collection(CreateCollectionResponse) returns(Void);
}
