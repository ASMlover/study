// Copyright (c) 2017 ASMlover. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list ofconditions and the following disclaimer.
//
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in
//    the documentation and/or other materialsprovided with the
//    distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";
package Nyx.Core;

option cc_generic_services = true;
option py_generic_services = true;

message Void {
  // 用作RPC返回消息——返回一个空消息
}

message ConnectRequest {
  // 建立连接的请求，用于建立连接后的第一个RPC消息
  enum RequestType {
    NEWCONNECTION = 0; // 新的连接
    RECONNECTION = 1; // 断线重连
    BIND_AVATAR = 2; // 绑定entity对象到Avatar（成为玩家对象）
  }
  bytes routes = 1;
  RequestType type = 2; // 请求的认证类型
  bytes device_id = 3; // 表示客户端的设备id
  bytes entity_id = 4; // 断线重连或绑定到Avatar的entity id
  bytes auth_msg = 5; // 验证消息
}

message ConnectResponse {
  // 针对连接请求ConnectRequest的应答消息
  enum ResponseType {
    BUSY = 0; // 服务器忙
    CONNECTED = 1; // 连接成功
    RECONNECTION_OK = 2; // 断线重连成功
    RECONNECTION_FAIL = 3; // 断线重连失败
    FORBIDDEN = 4; // 服务器禁止某客户端的连接请求
    MAX_CONNECTION = 5; // 服务器的连接达到上限
  }
  bytes routes = 1;
  ResponseType type = 2; // 应答请求的认证类型（默认为BUSY）
  bytes entity_id = 3; // 当前连接所绑定Avatar的entity id，重连时恢复需要
  bytes extra_msg = 4; // 连接请求应答返回客户端的额外信息
}

message Md5Index {
  // 需要传递方法或类型的地方，在网络上传递字符串的md5数据或索引
  bytes md5 = 1; // 方法或类型的md5
  sint32 index = 2; // index信息（默认应该为-1）
}

message EntityMessage {
  // Entity之间RPC调用的消息数据信息
  bytes routes = 1;
  bytes entity_id = 2;
  Md5Index method = 3; // Entity的RPC方法名
  bytes parameters = 4; // RPC调用的参数信息，可以使用BSON、protobuf序列化
  bool reliable = 5; // hint，告诉RPC对方在重连时此包必须到达（默认为true）
}

message GlobalEntityMessage {
  // 全局Entity的RPC调用消息的数据信息
  bytes target = 1;
  Md5Index method = 2; // 全局RPC方法名
  bytes parameters = 3; // 全局RPC方法的参数信息，可使用BSON、protobuf序列化
  bool reliable = 4; // hint
}

message EntityInfo {
  bytes routes = 1;
  Md5Index type = 2; // 所创建的Entity的类型
  bytes entity_id = 3; // 所创建的指定类型Entity的entity id
  bytes infos = 4; // Entity的数据信息
}

message OutbandInfo {
  bytes routes = 1;
  bytes infos = 2; // 服务端发送给客户端的带外数据信息
}

message ServerInfo {
  // 服务器的数据信息
  enum ServerType {
    INVALID = 0; // 非法的服务器类型
    NORMAL = 1; // 常规的服务器类型
  }

  bytes ip = 1; // 服务器的IP地址信息
  int32 port = 2; // 服务器的端口信息
  int32 sid = 3; // GameManager分配的server id信息
  bool ban_client = 4; // 禁止客户端连接
  ServerType server_type = 5; // 游戏服务器的类型
}

message EntityMailbox {
  bytes entity_id = 1; // Entity的全局唯一id
  ServerInfo server_info = 2; // Entity所在的服务器信息
}
