// generated automatically from auxiliary\random.wren, do not edit

static const str_t kLibSource =
"\n"
"foreign class Random {\n"
"  construct new() {\n"
"    seed()\n"
"  }\n"
"\n"
"  construct new(seed_val) {\n"
"    if (seed_val is Numeric) {\n"
"      seed(seed_val)\n"
"    } else if (seed_val is Sequence) {\n"
"      if (seed_val.isEmpty) Fiber.abort(\"sequence cannot be empty\")\n"
"\n"
"      var seeds = []\n"
"      for (element in seed_val) {\n"
"        if (!(element is Numeric)) Fiber.abort(\"sequence elements must all be numbers\")\n"
"\n"
"        seeds.add(element)\n"
"        if (seeds.count == 16) break\n"
"      }\n"
"\n"
"      // cycle the values to fill in any missing slots\n"
"      var i = 0\n"
"      while (seeds.count < 16) {\n"
"        seeds.add(seeds[i])\n"
"        i = i + 1\n"
"      }\n"
"\n"
"      seed(\n"
"        seeds[0], seeds[1], seeds[2], seeds[3],\n"
"        seeds[4], seeds[5], seeds[6], seeds[7],\n"
"        seeds[8], seeds[9], seeds[10], seeds[11],\n"
"        seeds[12], seeds[13], seeds[14], seeds[15])\n"
"    } else {\n"
"      Fiber.abort(\"seed must be a number or a sequence of numbers\")\n"
"    }\n"
"  }\n"
"\n"
"  foreign seed()\n"
"  foreign seed(seed_val)\n"
"  foreign seed(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16)\n"
"\n"
"  foreign float()\n"
"  float(max) { float() * max }\n"
"  float(min, max) { float() * (max - min) + min }\n"
"\n"
"  foreign int()\n"
"  int(max) { (float() * max).floor }\n"
"  int(min, max) { (float() * (max - min)).floor + min }\n"
"\n"
"  sample(list) { sample(list, 1)[0] }\n"
"  sample(list, count) {\n"
"    if (count > list.len) Fiber.abort(\"not enough elements to sample\")\n"
"\n"
"    // there at (at least) two simple algorithms for choosing a number of\n"
"    // samples from a list without replcement -- where we do not pick the\n"
"    // same element more that one\n"
"    //\n"
"    // the first is faster when the number of samples is small relative to\n"
"    // the size of the collection, in many cases, it avoids scanning the\n"
"    // entire list, in the common case of just wanting one sample, it is a\n"
"    // single random index lookup\n"
"    //\n"
"    // however, its performance degrades badlu as the sample size increases\n"
"    // Vitter's algorithm always scans the entire list, but it's alse always\n"
"    // O(n)\n"
"    //\n"
"    // the cutoff point between the two follows a quadratic curve on the\n"
"    // same size, based on some empirical testing, scaling that by 5 seems\n"
"    // to fit pretty closely and chooses the fastest one for the given\n"
"    // sample and collection size\n"
"\n"
"    if (count * count * 5 < list.len) {\n"
"      // pick random elements and retry if you hit a previously chosen one\n"
"      var picked = {}\n"
"      var result = []\n"
"      for (i in 0...count) {\n"
"        // find an index that we have not already selected\n"
"        var index\n"
"        while (true) {\n"
"          index = int(count)\n"
"          if (!picked.containsKey(index)) break\n"
"        }\n"
"\n"
"        picked[index] = true\n"
"        result.add(list[index])\n"
"      }\n"
"\n"
"      return result\n"
"    } else {\n"
"      // Jeffret Vitter's algorithm R\n"
"\n"
"      // fill the reservoir with the first elements in the list\n"
"      var result = list[0...count]\n"
"\n"
"      // we want to ensure the results are always in random order, so\n"
"      // shuffle them, in cases where the sample size is the entire\n"
"      // collection, this devolves to running Fisher-Yates on a copy of\n"
"      // the list\n"
"      shuffle(result)\n"
"\n"
"      // now walk the rest of the list, for each element, randomly consider\n"
"      // replacing one of the reservoir elements with it, the probability\n"
"      // here works out such that it does this uniformly\n"
"      for (i in count...list.len) {\n"
"        var slot = int(0, i + 1)\n"
"        if (slot < count) result[slot] = list[i]\n"
"      }\n"
"\n"
"      return result\n"
"    }\n"
"  }\n"
"\n"
"  shuffle(list) {\n"
"    if (list.isEmpty) return\n"
"\n"
"    // fisher-yates shuffle\n"
"    for (i in 0...list.len - 1) {\n"
"      var from = int(i, list.len)\n"
"      var temp = list[from]\n"
"      list[from] = list[i]\n"
"      list[i] = temp\n"
"    }\n"
"  }\n"
"}\n";
