// Copyright (c) 2019 ASMlover. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list ofconditions and the following disclaimer.
//
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in
//    the documentation and/or other materialsprovided with the
//    distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
#pragma once

#include <functional>
#include <vector>
#include "common.hh"

namespace wrencc {

enum class ValueType : u8_t {
  NIL,
  TRUE,
  FALSE,
  NUMERIC,
  OBJECT,
};

enum class ObjType : u8_t {
  STRING,
  LIST,
  FUNCTION,
  UPVALUE,
  CLOSURE,
  CLASS,
  INSTANCE,
};

enum ObjFlag {
  UNMARK = 0x00,
  MARKED = 0x01,
};

class WrenVM;
class BaseObject;

class NilObject;
class BooleanObject;
class NumericObject;
class StringObject;
class ListObject;
class FunctionObject;
class UpvalueObject;
class ClosureObject;
class ClassObject;
class InstanceObject;

class BaseObject : private UnCopyable {
  ObjType type_ : 3;
  ObjFlag flag_ : 1;
public:
  BaseObject(ObjType type) noexcept : type_(type), flag_(ObjFlag::UNMARK) {}
  virtual ~BaseObject(void) {}

  inline ObjType type(void) const { return type_; }
  inline ObjFlag flag(void) const { return flag_; }
  template <typename T> inline void set_flag(T f) { flag_ = Xt::as_type<ObjFlag>(f); }

  virtual str_t stringify(void) const = 0;
  virtual void gc_mark(WrenVM& vm) {}
};

enum Tag {
  MASK = 7,

  NaN = 0,
  NIL,
  FALSE,
  TRUE,
  UNUSED1,
  UNUSED2,
  UNUSED3,
  UNUSED4,
};

class TagValue final : public Copyable {
  static constexpr u64_t kSignBit = 1llu << 63;
  static constexpr u64_t kQNaN = 0x7ffc000000000000llu;

  union {
    double num_;
    u64_t bits_;
  };

  template <typename T> inline void set_decimal(T x) {
    num_ = Xt::as_type<double>(x);
  }

  inline bool check(ObjType type) const {
    return is_object() && as_object()->type() == type;
  }
public:
  TagValue(void) noexcept {}
  TagValue(nil_t) noexcept { bits_ = (kQNaN | Tag::NIL); }
  TagValue(bool b) noexcept { bits_ = b ? (kQNaN | Tag::TRUE) : (kQNaN | Tag::FALSE); }
  TagValue(i8_t n) noexcept { set_decimal(n); }
  TagValue(u8_t n) noexcept { set_decimal(n); }
  TagValue(i16_t n) noexcept { set_decimal(n); }
  TagValue(u16_t n) noexcept { set_decimal(n); }
  TagValue(i32_t n) noexcept { set_decimal(n); }
  TagValue(u32_t n) noexcept { set_decimal(n); }
  TagValue(i64_t n) noexcept { set_decimal(n); }
  TagValue(u64_t n) noexcept { set_decimal(n); }
  TagValue(float n) noexcept { set_decimal(n); }
  TagValue(double d) noexcept { num_ = d; }
  TagValue(BaseObject* o) noexcept { bits_ = (kSignBit | kQNaN | (u64_t)(o)); }

  inline bool operator==(const TagValue& r) const noexcept { return bits_ == r.bits_; }
  inline bool operator!=(const TagValue& r) const noexcept { return bits_ != r.bits_; }

  inline int tag(void) const { return Xt::as_type<int>(bits_ & Tag::MASK); }
  inline ObjType objtype(void) const { return as_object()->type(); }

  inline bool is_nil(void) const { return bits_ == (kQNaN | Tag::NIL); }
  inline bool is_boolean(void) const { return (bits_ == (kQNaN | Tag::TRUE)) || (bits_ == (kQNaN | Tag::FALSE)); }
  inline bool is_numeric(void) const { return (bits_ & kQNaN) != kQNaN; }
  inline bool is_object(void) const { return (bits_ & (kSignBit | kQNaN)) == (kSignBit | kQNaN); }
  inline bool is_string(void) const { return check(ObjType::STRING); }
  inline bool is_list(void) const { return check(ObjType::LIST); }
  inline bool is_function(void) const { return check(ObjType::FUNCTION); }
  inline bool is_upvalue(void) const { return check(ObjType::UPVALUE); }
  inline bool is_closure(void) const { return check(ObjType::CLOSURE); }
  inline bool is_class(void) const { return check(ObjType::CLASS); }
  inline bool is_instance(void) const { return check(ObjType::INSTANCE); }

  inline bool is_falsely(void) const { return is_nil() || bits_ == (kQNaN | Tag::FALSE); }

  inline bool as_boolean(void) const { return bits_ == (kQNaN | Tag::TRUE); }
  inline double as_numeric(void) const { return num_; }
  inline BaseObject* as_object(void) const { return (BaseObject*)(bits_ & ~(kSignBit | kQNaN)); }

  StringObject* as_string(void) const;
  const char* as_cstring(void) const;
  ListObject* as_list(void) const;
  FunctionObject* as_function(void) const;
  UpvalueObject* as_upvalue(void) const;
  ClosureObject* as_closure(void) const;
  ClassObject* as_class(void) const;
  InstanceObject* as_instance(void) const;

  str_t stringify(void) const;
};

class ObjValue final : public Copyable {
  ValueType type_{};
  double num_{};
  BaseObject* obj_{};

  inline bool check(ObjType type) const { return is_object() && obj_->type() == type; }

  template <typename T> inline double to_decimal(T x) {
    return Xt::as_type<double>(x);
  }
public:
  ObjValue(void) noexcept : type_(ValueType::OBJECT) {}
  ObjValue(nil_t) noexcept : type_(ValueType::NIL) {}
  ObjValue(bool b) noexcept : type_(b ? ValueType::TRUE : ValueType::FALSE) {}
  ObjValue(i8_t n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(u8_t n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(i16_t n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(u16_t n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(i32_t n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(u32_t n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(i64_t n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(u64_t n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(float n) noexcept : type_(ValueType::NUMERIC), num_(to_decimal(n)) {}
  ObjValue(double d) noexcept : type_(ValueType::NUMERIC), num_(d) {}
  ObjValue(BaseObject* o) noexcept : type_(ValueType::OBJECT), obj_(o) {}

  inline ValueType type(void) const { return type_; }
  inline ObjType objtype(void) const { return obj_->type(); }
  inline bool is_valid(void) const { return type_ != ValueType::OBJECT || obj_ != nullptr; }

  inline bool is_nil(void) const { return type_ == ValueType::NIL; }
  inline bool is_boolean(void) const { return type_ == ValueType::TRUE || type_ == ValueType::FALSE; }
  inline bool is_numeric(void) const { return type_ == ValueType::NUMERIC; }
  inline bool is_object(void) const { return type_ == ValueType::OBJECT; }
  inline bool is_string(void) const { return check(ObjType::STRING); }
  inline bool is_list(void) const { return check(ObjType::LIST); }
  inline bool is_function(void) const { return check(ObjType::FUNCTION); }
  inline bool is_upvalue(void) const { return check(ObjType::UPVALUE); }
  inline bool is_closure(void) const { return check(ObjType::CLOSURE); }
  inline bool is_class(void) const { return check(ObjType::CLASS); }
  inline bool is_instance(void) const { return check(ObjType::INSTANCE); }

  inline bool is_falsely(void) const { return is_nil() || type_ == ValueType::FALSE; }

  inline BaseObject* as_object(void) const { return obj_; }
  inline bool as_boolean(void) const { return type_ == ValueType::TRUE; }
  inline double as_numeric(void) const { return num_; }

  StringObject* as_string(void) const;
  const char* as_cstring(void) const;
  ListObject* as_list(void) const;
  FunctionObject* as_function(void) const;
  UpvalueObject* as_upvalue(void) const;
  ClosureObject* as_closure(void) const;
  ClassObject* as_class(void) const;
  InstanceObject* as_instance(void) const;

  bool operator==(const ObjValue& r) const noexcept;
  bool operator!=(const ObjValue& r) const noexcept;
  str_t stringify(void) const;
};

#ifdef NAN_TAGGING
using Value = TagValue;
#else
using Value = ObjValue;
#endif

std::ostream& operator<<(std::ostream& out, const Value& val);

class StringObject final : public BaseObject {
  int size_{};
  char* value_{};

  StringObject(char c) noexcept;
  StringObject(const char* s, int n, bool replace_owner = false) noexcept;
  virtual ~StringObject(void);
public:
  inline int size(void) const { return size_; }
  inline const char* cstr(void) const { return value_; }
  inline char operator[](int i) const { return value_[i]; }
  inline char& operator[](int i) { return value_[i]; }

  virtual str_t stringify(void) const override;

  static StringObject* make_string(WrenVM& vm, char c);
  static StringObject* make_string(WrenVM& vm, const char* s, int n);
  static StringObject* make_string(WrenVM& vm, const str_t& s);
  static StringObject* make_string(WrenVM& vm, StringObject* s1, StringObject* s2);
};

class ListObject final : public BaseObject {
  std::vector<Value> elements_;

  ListObject(int num_elements = 0) noexcept;
public:
  inline int count(void) const { return Xt::as_type<int>(elements_.size()); }
  inline const Value& get_element(int i) const { return elements_[i]; }
  inline void set_element(int i, const Value& e) { elements_[i] = e; }
  inline void clear(void) { elements_.clear(); }
  inline void add_element(const Value& e) { elements_.push_back(e); }
  inline void insert(int i, const Value& e) { elements_.insert(elements_.begin() + i, e); }
  inline void remove(int i) { elements_.erase(elements_.begin() + i); }

  virtual str_t stringify(void) const override;
  virtual void gc_mark(WrenVM& vm) override;

  static ListObject* make_list(WrenVM& vm, int num_elements = 0);
};

class FunctionObject final : public BaseObject {
  int num_upvalues_{};
  std::vector<u8_t> codes_;
  std::vector<Value> constants_;

  FunctionObject(void) noexcept : BaseObject(ObjType::FUNCTION) {}
public:
  inline int num_upvalues(void) const { return num_upvalues_; }
  inline const u8_t* codes(void) const { return codes_.data(); }
  inline const Value* constants(void) const { return constants_.data(); }
  inline int codes_count(void) const { return Xt::as_type<int>(codes_.size()); }
  inline int constants_count(void) const { return Xt::as_type<int>(constants_.size()); }
  inline u8_t get_code(int i) const { return codes_[i]; }
  inline const Value& get_constant(int i) const { return constants_[i]; }

  template <typename T> inline int add_code(T c) {
    codes_.push_back(Xt::as_type<u8_t>(c));
    return Xt::as_type<int>(codes_.size()) - 1;
  }

  template <typename T> inline void set_code(int i, T c) {
    codes_[i] = Xt::as_type<u8_t>(c);
  }

  inline int add_constant(const Value& v) {
    constants_.push_back(v);
    return Xt::as_type<int>(constants_.size()) - 1;
  }

  virtual str_t stringify(void) const override;
  virtual void gc_mark(WrenVM& vm) override;

  static FunctionObject* make_function(WrenVM& vm);
};

// the dynamically allocated data structure for a variable that has been
// used by a closure. whenever a function accesses a variable declared in
// an enclosing function, it will get to it through this.
//
// an upvalue can be either `closed` or `open`, an open upvalue points
// directly to a [value] that is still stored on the fiber's stack because
// the local variable is still in scope in the function where it's declared.
//
// when that local variable goes out of scope, the upvalue pointing to it
// will be closed. when that happens, the value gets copied off the stack
// into the upvalue itself, that way, it can have a longer lifetime than
// the stack variable.
class UpvalueObject final : public BaseObject {
  Value* value_{}; // pointer to the variable this upvalue is referencing

  // if the upvalue is closed then the closed-over value will be hoisted out
  // of the stack into here. [value] will then be changed to point to this.
  Value closed_{};

  // open upvalues are stored in a linked list by the fiber. this points to
  // the next upvalue in that list.
  UpvalueObject* next_{};

  UpvalueObject(Value* value, UpvalueObject* next = nullptr) noexcept;
  virtual ~UpvalueObject(void) {}
public:
  inline Value* value(void) const { return value_; }
  inline Value* value_asptr(void) const { return value_; }
  inline const Value& value_asref(void) const { return *value_; }
  inline void set_value(Value* value) { value_ = value; }
  inline void set_value(const Value& value) { value_ = const_cast<Value*>(&value); }
  inline const Value& closed(void) const { return closed_; }
  inline Value* closed_asptr(void) const { return const_cast<Value*>(&closed_); }
  inline const Value& closed_asref(void) const { return closed_; }
  inline void set_closed(const Value& closed) { closed_ = closed; }
  inline void set_closed(Value* closed) { closed_ = *closed; }
  inline UpvalueObject* next(void) const { return next_; }
  inline void set_next(UpvalueObject* next) { next_ = next; }

  virtual str_t stringify(void) const override;
  virtual void gc_mark(WrenVM& vm) override;

  static UpvalueObject* make_upvalue(
      WrenVM& vm, Value* value, UpvalueObject* next = nullptr);
};

class ClosureObject final : public BaseObject {
  FunctionObject* fn_{}; // function that this closure is an instance of
  UpvalueObject** upvalues_{}; // the upvalues this function has closed over

  ClosureObject(FunctionObject* fn) noexcept;
  virtual ~ClosureObject(void);
public:
  inline FunctionObject* fn(void) const { return fn_; }
  inline bool has_upvalues(void) const { return upvalues_ != nullptr; }
  inline UpvalueObject** upvalues(void) const { return upvalues_; }
  inline UpvalueObject* get_upvalue(int i) const { return upvalues_[i]; }
  inline void set_upvalue(int i, UpvalueObject* upvalue) { upvalues_[i] = upvalue; }

  virtual str_t stringify(void) const override;
  virtual void gc_mark(WrenVM& vm) override;

  static ClosureObject* make_closure(WrenVM& vm, FunctionObject* fn);
};

class Fiber;
using PrimitiveFn = Value (*)(WrenVM& vm, Value* args);
using FiberPrimitiveFn = void (*)(WrenVM& vm, Fiber& fiber, Value* args);

enum class MethodType {
  NONE,     // no method for the given symbol
  PRIMITIVE,// a primitive method implemented in C that immediatelt returns a Value
  FIBER,    // a built-in method that modifies the fiber directly
  BLOCK,    // a normal user-defined method

  // a constructor, this will be defined on the metaclass, if [fn] is non-nil,
  // then it's a user-defined constructor and [fn] is the initialization code
  // otherwise, it's a default constructor
  CTOR,
};

struct Method {
  MethodType type{MethodType::NONE};
  union {
    PrimitiveFn primitive;
    FiberPrimitiveFn fiber_primitive;
    Value fn;
  };

  Method(void) {}
};

class ClassObject final : public BaseObject {
  static constexpr sz_t kMaxMethods = 256;

  ClassObject* meta_class_{};
  ClassObject* superclass_{};
  int num_fields_{};
  std::vector<Method> methods_{kMaxMethods};

  ClassObject(void) noexcept;
  ClassObject(ClassObject* meta_class,
      ClassObject* supercls = nullptr, int num_fields = 0) noexcept;
public:
  inline ClassObject* meta_class(void) const { return meta_class_; }
  inline ClassObject* superclass(void) const { return superclass_; }
  inline int num_fields(void) const { return num_fields_; }
  inline int methods_count(void) const { return Xt::as_type<int>(methods_.size()); }
  inline Method& get_method(int i) { return methods_[i]; }
  inline void set_method(int i, PrimitiveFn fn) {
    methods_[i].type = MethodType::PRIMITIVE;
    methods_[i].primitive = fn;
  }
  inline void set_method(int i, FiberPrimitiveFn fn) {
    methods_[i].type = MethodType::FIBER;
    methods_[i].fiber_primitive = fn;
  }
  inline void set_method(int i, const Value& fn) {
    methods_[i].type = MethodType::BLOCK;
    methods_[i].fn = fn;
  }
  inline void set_method(int i, MethodType fn_type, const Value& fn) {
    methods_[i].type = fn_type;
    methods_[i].fn = fn;
  }

  virtual str_t stringify(void) const override;
  virtual void gc_mark(WrenVM& vm) override;

  static ClassObject* make_class(WrenVM& vm,
      ClassObject* superclass = nullptr, int num_fields = 0);
};

class InstanceObject final : public BaseObject {
  ClassObject* cls_{};
  std::vector<Value> fields_;

  InstanceObject(ClassObject* cls) noexcept;
public:
  inline ClassObject* cls(void) const { return cls_; }
  inline const Value& get_field(int i) const { return fields_[i]; }
  inline void set_field(int i, const Value& v) { fields_[i] = v; }

  virtual str_t stringify(void) const override;
  virtual void gc_mark(WrenVM& vm) override;

  static InstanceObject* make_instance(WrenVM& vm, ClassObject* cls);
};

}
