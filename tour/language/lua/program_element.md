# **程序元素**
***


## **1. 表达式**
> ### **算术表达式**
    1) 算术操作: +, -, *, /, ^(指数), %
> ### **关系操作符**
    1) <, >, <=, >=, ==, ~=
    2) 操作符的运算结果都是true或false
    3) nil只与其自身相等
> ### **逻辑操作符**
    1) and or not
    2) 所有逻辑操作符将false和nil视为假, 其他的东西视为真
> ### **字符串连接符**
    1) 使用'..'连接两个字符串;
    2) 如果任意一个操作数是数字的话, lua会将数字转换成一个字符串;
    3) lua中字符串是不可变的, 连接操作符只会创建一个新的字符串;
> ### **优先级**
    1) 优先级从高到低:
        ^
        not #   -(一元)
        *   /   %
        +   -
        ..
        <   >   <=  >=  ~=  ==
        and
        or
    2) 二元操作符中^和..是右结合的, 其余都是左结合;
> ### **table构造式**
    1) 最简单的构造式就是{}, 用于创建一个空table;




## **2. 语句**
> ### **赋值**
    1) 允许多重赋值, 可一次将多个值赋予多个变量
        a, b = 1, 2
       多重赋值中, 会对=右边的所有元素求值, 然后再执行赋值操作;
    2) 若左边的变量多与右边的值, 那么多余的变量会被赋值为nil;
> ### **局部变量与块**
    1) 通过local语句来创建局部变量;
    2) 局部变量的作用域仅限于声明他们的那个块;
    3) 可以使用do-end来显式定义一个块;
> ### **控制结构**
    1) if then else
       lua不支持witch, 所以if then elseif then的语句很正常
    2) while
    3) repeat-until语句重复执行其循环体直到条件为真时结束
    4) 数字型for
        for var = beg, end, step do
        end
        如果没有step, 默认步长是1;
    5) 泛型for
        通过一个迭代器函数来遍历所有值;
        io.lines用于迭代文件中的每行;
        pairs用于迭代table元素;
        ipairs用于迭代数组元素;
        string.gmatch用于迭代字符串中的单词;
> ### **break与return**
    1) break和return语句用于跳出当前的块;
    2) break用于结束一个循环, 只会跳出包含它的那个内部循环(for,repeat,while)
       不会改变外层的循环;
    3) return用于从一个函数返回结果, 或用于简单地结束一个函数的执行;




## **3. 函数**
    无论函数有无参数都必须用括号括起来调用;
    冒号操作符使调用o.foo时将o隐含地作为函数的第一个参数;
> ### **多重返回值**
    1) 若将函数作为一个单独的语句, 丢弃函数的所有返回值
    2) 函数作为表达式的一部分来调用, Lua只保留函数的第一个返回值;
    3) 只有当函数调用是一系列表达式中的最后一个元素时, 才捕获所有的返回值;
> ### **变长参数**
> ### **具名实参**
    lua中参数传递机制是具有位置性的;
    但传递参数的时候可以传递一个table来实现具名实参(使用table构造式):
      rename{old='temp.lua', new='temp_new.lua'}
> ### **闭包函数(closure)**
    将一个函数写在另一个函数的内部, 那么这个位于内部的函数便可以访问外部函数
    的局部变量;
> ### **非全局的函数**
    1) 只要将一个函数存储到一个局部变量中, 就得到一个局部函数
    2) 局部函数还可以如下所示:
        local function function_name(<参数>)
          <函数体>
        end
> ### **正确的尾调用**
    1) 支持尾调用消除
    2) 是一种类似goto的函数调用
    3) 只有一个函数调用是另一个函数的最后一个动作时, 该调用才算尾调用;
    4) 只有return <func>(<args>)这样的调用形式才算尾调用;



## **4. 迭代器与泛型for**
> ### **迭代器与closure**
    1) 表示为函数, 每调用一次函数, 返回集合中的下一个元素, 最后返回nil
> ### **泛型for语义**
    1) 语法:
        for <var-list> in <exp-list> do
          <body>
        end




## **5. 协同程序(coroutine)**
    类似线程, 是一条执行序列, 有自己独立的栈, 局部变量和指令指针, 又与其他协
    同程序共享全局变量和其他大部分东西;
    一个多线程程序可以同时运行多个线程, 协同程序却需要彼此协作运行;
> ### **基础**
    1) coroutine.create创建协同程序, 返回thread类型; 参数是一个函数
    2) 有4种状态: 挂起, 运行, 死亡, 正常; 可以使用status来检查协同程序状态;
       新创建的协同程序处理挂起状态;
    3) coroutine.resume 启动或再次启动一个协同程序的执行, 并将其状态由挂起改
       为运行
    4) coroutine.yield会挂起协同程序, 直到被resume唤醒;
    5) 可以通过一对resume-yield来交换数据, 第一次调用resume时, 并没有对应的
       yield在等待, 因此所有传递给resume的参数将被视为是传递给协同程序的主
       函数的参数;
       resume的返回值, 第一个值为true表示没有出错, 后面的值表示yield传递的参
       数; yield返回的额外值就是resume传入的参数;
> ### **非抢占式多线程**
    1) 无法从外部停止它, 只有当协同程序显式地挂起时才会停止;
