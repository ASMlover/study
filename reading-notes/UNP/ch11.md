# **名字与地址转换**
***


## **1. 域名系统**
    1) 域名系统主要用于主机名字与IP地址之间的映射；
> ### **1.1 资源记录**
    1) DNS中的条目为资源记录：
        * A     => A记录把一个主机名映射成一个32位的IPv4地址；
        * AAAA  => 为'四A'记录的AAAA记录把一个主机映射成一个128位IPv6地址；
        * PTR   => 是'指针记录', PTR记录把IP地址映射成主机名；
        * MX    => MX记录把一个主机指定作为给定主机的“邮件交换器”；
        * CNAME => 代表(canonical name)(规范名字)，常见用法是为常用的服务指
                   派CNAME记录；
> ### **1.2 解析器和名字服务器**
    1) /etc/resolv.conf通常包含本地名字服务器主机的IP地址；
    2) 解析器使用UDP向本地名字服务器发出查询，如果本地名字服务器不知道，通常
       会使用UDP在整个英特网上查询其他名字服务器；
       如果名字太长，超出UDP消息的承载能力，会自动切换到TCP；
> ### **1.3 DNS替代方法**
    1) 不使用DNS也可能获取名字和地址信息；
    2) 常用的替代方法：
        * 静态主机文件(/etc/hosts)
        * 网络信息系统
        * 轻权目录访问协议
    3) Solaris2.x，HP-UX10及后续，FreeBSD5.x及后续使用/etc/nsswitch.conf;
       AIX使用/etc/netsvc.conf;
       BIND 9.2.2提供自己的名为信息检索服务的版本，使用/etc/irs.conf;
    4) 如使用名字服务器查找主机名，那所有这些系统都使用/etc/resolv.conf指定
       名字服务器的IP地址；


## **2. gethostbyname函数**
    1) 查找主机名最基本是使用gethostbyname，成功返回一个指向hostent的指针，
       该结构中含有所查找主机的所有IPv4地址；其局限是只能返回IPv4地址；
    2) gethostbyname定义
        #include <netdb.h>
        struct hostent* gethostbyname(const char* hostname);
                => 成功返回非空指针，出错返回NULL且设置h_errno
    3) 返回的hostent结构如下：
        struct hostent {
          char*  h_name;
          char** h_aliases;
          int    h_addrtype;
          int    h_length;
          char** h_addr_list;
        };
        * gethostbyname执行的是对A记录的查询，只能返回IPv4地址；
        * h_name为所查询主机的规范名字；
        * h_aliases是一个别名数组；
        * h_addrtype可取值为AF_INET；
        * h_addr_list是一个IP地址列表；
    4) gethostbyname与其他套接字函数不同在于：发生错误时不设置errno，而将全
       局整数变量设置为<netdb.h>定义的下列常量：
        * HOST_NOT_FOUND
        * TRY_AGAIN
        * NO_RECOVERY
        * NO_DATA(等同于NO_ADDRESS) => 表示指定名字有效，但没有A记录；

## **3. gethostbyaddr函数**
        #include <netdb.h>
        struct hostent* gethostbyaddr(
                const char* addr, socklen_t len, int family);
                => 成功返回非空指针，出错返回NULL且设置h_errno
    1) 由一个二进制的IP地址找到对应的主机名，与gethostbyname相反；
    2) addr是一个指向存放IPv4地址的某个in_addr结构的指针；len是结构大小；
       family是AF_INET；


## **4. getservbyname和getservbyport函数**
    1) 如在程序中通过名字而非端口号来指代一个服务，且从名字到端口号的映射关
       系保存在一个文件(/etc/services)，那端口发生了改动，我们只需要修改这个
       文件的某行而不用重新编译程序；
    2) getservbyname的定义：
        #include <netdb.h>
        struct servent* getservbyname(
                const char* servname, const char* protoname);
                => 成功返回非空指针，出错返回NULL
        * 返回的结构如下：
          struct servent {
            char*   s_name;
            char**  s_aliases;
            int     s_port;
            char*   s_proto;
          };
        * servname必须指定，如果同时指定了协议，那指定服务必须有匹配的协议；
    3) 根据给定端口号和可选协议查找相应服务：
        #include <netdb.h>
        struct servent* getservbyport(int port, const char* protoname);
                => 成功返回非空指针，出错返回NULL
        * port必须是网络字节序
