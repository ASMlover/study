# **基本SCTP套接字编程**
***


## **1. 概述**
    1) SCTP是一个可靠的面向消息的协议，在端点之间提供多个流，并为多宿提供传
       输级支持；
    2) 对使用SCTP开发的程序，建议使用一到多的接口；


## **2. 接口模型**
    1) SCTP套接字分为：一到一套接字和一到多套接字；
        * 一到一对应一个单独的SCTP关联；
        * 一到多，一个给定套接字上可以同时有多个活跃的SCTP关联；
> ### **2.1 一到一形式**
    1) 任何TCP套接字选项必须转换成等效的SCTP套解析选项；
    2) SCTP保存消息边界，因而应用层消息边界并非必须；
    3) 有些TCP应用进程使用半关闭来告知对端去往它的数据流已经结束；
    4) send函数能够以普通方式使用；
    5) 一到一SCTP套接字是一个SOCK_STREAM，协议是IPPROTO_SCTP；
> ### **2.2 一到多形式**
    1) 一到多形式编写的服务器无需管理大量的套接字描述符；
    2) 当一个客户关闭其关联时，其服务器也将自动关闭同一个关联，服务器主机内
       核不再有该关联的状态；
    3) 可用于致使在四路握手的第三个或第四个分组中捎带用户数据的唯一办法是使
       用一到多形式；
    4) 对于一个与它还没有关联存在的IP地址，任何以它为目的地的sendto，sendmsg
       或sctp_sendmsg将导致主动打开的尝试，从而建立一个与该地址的新关联；
    5) 用户必须使用sendto、sendmsg或sctp_sendmsg这3个函数；不能使用send或
       write这样的函数；除非已经使用sctp_peeloff从一个一到多剥离出一个一到一
       套接字；
    6) 任何时候调用其中任何一个分组发送函数时，所用的目的地址是由系统在关联
       建立阶段选定的主目的地址，除非调用者在所提供的sctp_sndrcvinfo结构中
       设置了MSG_ADDR_OVER标志；
    7) 关联事件可能被启用，因此要是应用程序不希望收到这些事件，就得使用
       SCTP_EVENTS套接字选项显示禁止它们；
    8) SCTP中一个一到多套接字也能结合使用sctp_peeloff允许组合迭代服务器模型
       和并发服务器模型，关系如下：
        * sctp_peeloff用于从一个一到多剥离出某个特定的关联独自构成一个一到一
          的套接字
        * 剥离出的关联所在的一到一套接字随后就可以遣送给它自己的线程，或遣送
          给为它派生的进程
        * 主线程继续在原来的套接字上以迭代方式处理来自任何剩余关联的消息；


## **3. `sctp_bindx`函数**
        #include <netinet/sctp.h>
        int sctp_bindx(int sockfd, const struct sockaddr* addrs, 
                int addrcnt, int flags);
                => 成功返回0，否则出错返回-1
    1) sctp_bindx允许SCTP套接字绑定一个特定地址子集；
    2) flags知道sctp_bindx调用执行入如下:
        * SCTP_BINDX_ADD_ADDR 往套接字中添加地址
        * SCTP_BINDX_REM_ADDR 从套接字中删除地址

## **4. `sctp_connectx`函数**
        #include <netinet/sctp.h>
        int sctp_connectx(int sockfd, 
                const struct sockaddr* addrs, int addrcnt);
                => 成功返回0，出错返回-1
    1) 用于连接一个多宿对端主机
    2) SCTP栈使用其中一个或多个地址建立关联
    3) addrs中的所有地址都被认为是有效的经过证实的地址


## **5. `sctp_getpaddrs`函数**
        #include <netinet/sctp.h>
        int sctp_getpaddrs(int sockfd, 
                sctp_assoc_t id, struct sockaddr** addrs);
                => 成功返回存放在addrs中的对端地址数，出错返回-1
    1) 返回主目的地址
    2) id参数是一到多式套接字的关联标识，而一到一使套接字忽略该字段；
    3) 调用者应该使用sctp_freepaddrs释放分配的资源(addrs)

## **6. `sctp_freepaddrs`函数**
        #include <netinet/sctp.h>
        void sctp_freepaddrs(struct sockaddr* addrs);
    1) 释放有sctp_getpaddrs函数分配的资源

## **7. `sctp_getladdrs`函数**
        #include <netinet/sctp.h>
        int sctp_getladdrs(int sockfd, 
                sctp_assoc_t id, struct sockaddr** addrs);
                => 成功返回存放在addrs中的本端地址数，出错返回-1
        1) 获取属于某个关联的本地地址；
        2) id是一到多式套接字的关联标识，一到一套接字忽略它；
        3) 调用者应该调用sctp_freeladdrs释放所分配的资源；

# **8. `sctp_freeladdrs`函数**
        #include <netinet/sctp.h>
        void sctp_freeladdrs(struct sockaddr* addrs);
    1) sctp_freeladdrs释放由sctp_getladdrs所分配的资源；


## **9. `sctp_sendmsg`函数**
        #include <netinet/sctp.h>
        ssize_t sctp_sendmsg(int sockfd, const void* msg, size_t, msgsz,
                const struct sockaddr* to, socklen_t tolen, 
                uint32_t ppid, 
                uint32_t flags, uint16_t stream, 
                uint32_t timetolive, uint32_t context);
                => 成功返回所写字节数，出错返回-1
    1) ppid指定将随数据块传递的净荷协议标示符；
    2) flags传递给SCTP栈，用以标识任何SCTP选项；
    3) stream指定一个SCTP流号；
    4) timetolive指定消息的生命期(毫秒)，0表示无限生命期；
    5) context指定可能有的用户上下文；

## **10. `sctp_recvmsg`函数**
        #include <netinet/sctp.h>
        ssize_t sctp_recvmsg(int sockfd, void* msg, size_t msgsz, 
                struct sockaddr* from, socklen_t* fromlen, 
                struct sctp_sndrcvinfo* sinfo, int* msg_flags);
                => 成功返回所读的字节数，出错返回-1
    1) 不仅获取对端的地址，也获取通常伴随recvmsg调用返回的msg_flags
    2) 也允许获取已读入消息缓冲区中的伴随所接收消息的sctp_sndrcvinfo
    3) 如果想接收sctp_sndrcvinfo，必须使用SCTP_EVENTS预订sctp_data_io_event
    4) 如果sctp_recvmsg映射成recvmsg，recvmsg的flags参数为0

## **11. `sctp_opt_info`函数**
    1) 为无法为SCTP使用getsockopt函数的那些实现提供的；
        #include <netinet/sctp.h>
        int sctp_opt_info(int sockfd, sctp_assoc_t assoc_id, int opt, 
                void* arg, socklen_t* siz);
                => 成功返回0，出错返回-1
    2) assoc_id给出可能存爱的关联标识
    3) opt是SCTP套接字选项
    4) arg是套接字选项参数
    5) siz存放参数的大小
