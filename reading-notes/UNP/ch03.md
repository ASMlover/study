# **套接字编程简介**
***


## **1. 套接字地址结构**
> ### **1.1 IPv4套接字地址结构**
    1) 也称网际套接字地址结构, 在<netinet/in.h>中定义;
        struct in_addr {
          in_addr_t s_addr;
        };
        struct sockaddr_in {
          uint8_t         sin_len;
          sa_family_t     sin_family;
          in_port_t       sin_port;
          struct in_addr  sin_addr;
          char            sin_zero[8];
        };
        * sin_len是为增加对OSI协议的支持而添加的;
        * 即时有长度字段, 也不需要设置和检查它, 除非涉及路由套接字;
        * POSIX规范只需要这个结构中的3个字段: sin_family,sin_addr,sin_port;
        * in_addr_t必须是一个至少32位的无符号整数类型, in_port_t必须是一个至
          少16位的无符号整数类型, sa_family_t可以是任何无符号整数类型;
        * sin_zero未曾使用, 不过在填写这种结构时, 总是设置为0;
        * 套接字地址结构仅在给定的主机上使用; 结构本身不在主机间传递;
> ### **1.2 通用套接字地址结构**
    1) 必须处理来自所支持的任何协议族的套接字地址结构;
    2) <sys/socket.h>中的通用套接字地址结构:
        struct sockaddr {
          uint8_t     sa_len;
          sa_family_t sa_family;    // AF_xxx value
          char        sa_data[14];  // protocol-specific address
        };
> ### **1.3 IPv6套接字地址结构**
    1) 在<netinet/in.h>定义
        struct in6_addr {
          uint8_t s6_addr[16];  // 128-bit IPv6 address
        };
        #define SIN6_LEN        // required for compile-time tests
        struct sockaddr_in6 {
          uint8_t         sin6_len;       // length of this struct(28)
          sa_family_t     sin6_family;    // AF_INET6
          in_port_t       sin6_port;
          uint32_t        sin6_flowinfo;  // flow information, undefined
          struct in6_addr sin6_addr;      // IPv6 address
          uint32_t        sin6_scope_id;  // set of interfaces for a scope
        };
        * 如果支持套接字地址结构中的长度字段, 那SIN6_LEN必须定义;
        * IPv6地址族是AF_INET6, 而IPv4是AF_INET;
        * 结构中字段的先后顺序做过编排, 使得如果sockaddr_in6结构本事是64位对
          齐的, 那么128位的sin6_addr也是64位对齐的;
        * sin6_flowinfo分为低20位是流标, 高序12位保留;
        * 对具备范围的地址, sin6_scope_id标识其范围;
> ### **1.4 新的通用套接字地址结构**
    1) 在<netinet/in.h>中定义
        struct sockaddr_storage {
          uint8_t     ss_len;
          sa_family_t ss_family;
        };
    2) 如果系统支持的任何套接字地址结构有对齐需求, 那sockaddr_storage满足最
       苛刻的对齐要求;
    3) sockaddr_storage足够大, 能容纳系统支持的任何套接字地址结构;


## **2. 值-结果参数**
    1) 从进程到内核传递套接字地址结构的函数有: bind,connect和sendto;
    2) 从内核到进程传递套接字地址结构的函数有: accept,recvfrom,getsockname和
       getpeername;


## **3. 字节排序函数**
    1) 16位整数, 内存中有两种存储方法: 
        * 将低序字节存储在起始位置 -> 小端字节序;
        * 将高序字节存储在起始位置 -> 大端字节序;
    2) 主机字节序: 某给定系统所用的字节序;
    3) 网络字节序: 按照大端字节序来处理;
    4) 两种字节序转换函数<netinet/in.h>
        uint16_t htons(uint16_t host16bitvalue);
        uint32_t htonl(uint32_t host32bitvalue);
        uint16_t ntohs(uint16_t net16bitvalue);
        uint32_t ntohl(uint32_t net32bitvalue);
          * h 代表host
          * n 代表network
          * s 代表short
          * l 代表long(将l视为一个32bit值)
