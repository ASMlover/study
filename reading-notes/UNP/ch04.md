# **基本TCP套接字编程**
***

## **1. socket函数**
        #include <sys/socket.h>
        int socket(int family, int type, int protocol);
          => 返回: 非负描述符, 出错返回-1
    1) family常值:
        * AF_INET   => IPv4协议
        * AF_INET6  => IPv6协议
        * AF_LOCAL  => Unix域地址
        * AF_ROUTE  => 路由套接字
        * AF_KEY    => 密钥套接字
    2) type常值:
        * SOCK_STREAM     => 字节流套接字
        * SOCK_DGRAM      => 数据报套接字
        * SOCK_SEQPACKET  => 有序分组套接字
        * SOCK_RAW        => 原始套接字
    3) protocol常值:
        * IPPROTO_TCP   => TCP传输协议
        * IPPROTO_UDP   => UDP传输协议
        * IPPROTO_SCTP  => SCTP传输协议
    4) `AF_XXX`和`PF_XXX`
        * AF_表示地址族, PF_表示协议族;
        * 历史原因曾想PF_创建套解析而AF_创建套接字地址结构, 单个协议可支持多
          个地址族; 但支持多个地址族的协议从未实现; 仅使用AF_;

## **2. connect函数**
        #include <sys/socket.h>
        int connect(int sockfd, 
            const struct sockaddr* servaddr, socklen_t addrlen);
            => 返回: 成功返回0, 出错返回-1
    1) 客户在调用connect前不必非调用bind; 如果需要, 内核会确定源IP地址并选一
       个临时端口作为源端口;
    2) 出错可能:
        * TCP客户没收到SYN的响应, 返回ETIMEDOUT错误;
        * 对客户的SYN的响应是RST(复位), 表明该服务器主机在我们指定的端口上没
          有进程在等待与之连接; 客户收到RST就返回ECONNREFUSED错误;
        * 客户发出的SYN在中间的某路由上引发一个目的地不可达ICMP错误, 客户内
          核保存该消息, 按第一种情况中所述的时间间隔继续发送SYN, 若规定时间
          后仍未收到响应则返回EHOSTUNREACH或ENETUNREACH错误;
    3) 在每次connect失败后, 必须close当前套接字描述符并重新调用socket;
