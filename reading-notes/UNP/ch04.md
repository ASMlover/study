# **基本TCP套接字编程**
***

## **1. socket函数**
        #include <sys/socket.h>
        int socket(int family, int type, int protocol);
          => 返回: 非负描述符, 出错返回-1
    1) family常值:
        * AF_INET   => IPv4协议
        * AF_INET6  => IPv6协议
        * AF_LOCAL  => Unix域地址
        * AF_ROUTE  => 路由套接字
        * AF_KEY    => 密钥套接字
    2) type常值:
        * SOCK_STREAM     => 字节流套接字
        * SOCK_DGRAM      => 数据报套接字
        * SOCK_SEQPACKET  => 有序分组套接字
        * SOCK_RAW        => 原始套接字
    3) protocol常值:
        * IPPROTO_TCP   => TCP传输协议
        * IPPROTO_UDP   => UDP传输协议
        * IPPROTO_SCTP  => SCTP传输协议
    4) `AF_XXX`和`PF_XXX`
        * AF_表示地址族, PF_表示协议族;
        * 历史原因曾想PF_创建套解析而AF_创建套接字地址结构, 单个协议可支持多
          个地址族; 但支持多个地址族的协议从未实现; 仅使用AF_;

## **2. connect函数**
        #include <sys/socket.h>
        int connect(int sockfd, 
            const struct sockaddr* servaddr, socklen_t addrlen);
            => 返回: 成功返回0, 出错返回-1
    1) 客户在调用connect前不必非调用bind; 如果需要, 内核会确定源IP地址并选一
       个临时端口作为源端口;
    2) 出错可能:
        * TCP客户没收到SYN的响应, 返回ETIMEDOUT错误;
        * 对客户的SYN的响应是RST(复位), 表明该服务器主机在我们指定的端口上没
          有进程在等待与之连接; 客户收到RST就返回ECONNREFUSED错误;
        * 客户发出的SYN在中间的某路由上引发一个目的地不可达ICMP错误, 客户内
          核保存该消息, 按第一种情况中所述的时间间隔继续发送SYN, 若规定时间
          后仍未收到响应则返回EHOSTUNREACH或ENETUNREACH错误;
    3) 在每次connect失败后, 必须close当前套接字描述符并重新调用socket;


## **3. bind函数**
        将一个本地协议地址赋予一个套接字;
        #include <sys/socket.h>
        int bind(int sockfd, 
            const struct sockaddr* myaddr, socklen_t addrlen);
            => 返回: 成功返回0, 否则返回-1
    1) 进程可以把一个特定的IP地址绑定到它的套接字上, 不过这个IP地址必须属于
       其所在主机的网络接口之一;
    2) 给bind指定要绑定的IP地址/端口的结果:
        * 通配地址:0      => 内核选择IP地址或端口
        * 通配地址:非0    => 内核选择IP地址, 进程指定端口
        * 本地IP地址:0    => 进程指定IP地址, 内核选择端口
        * 本地IP地址:非0  => 进程指定IP地址, 内核指定端口
    3) IPv4通配地址是INADDR_ANY; IPv6通配地址是in6addr_any, 其初始值通常为
       IN6ADDR_ANY_INT, 在<netinet/in.h>中含有定义;
    4) 如何让内核选择一个临时端口号, 那bind并不返回所选择的值; 为了得到内核
       选择的这个临时端口号, 那么必须调用getsockname来返回协议地址;
    5) bind返回EADDRINUSE错误来表示地址已经使用;


## **4. listen函数**
        #include <sys/socket.h>
        int listen(int sockfd, int backlog);  => 返回: 成功返回0, 否则返回-1
    1) 仅由TCP服务器调用;
    2) listen将一个未连接的套接字转换成一个被动套接字, 指示内核应接收指向该
       套接字的连接请求;
    3) 调用listen导致套接字从CLOSED转换到LISTEN状态;
    4) 第二个参数规定了内核应该为相应套接字排队的最大连接个数;
    5) backlog维护着两个队列:
        * 未完成连接队列: 已由某客户端发出并到达服务器, 而服务器正在等待完成
          相应的TCP三路握手过程, 套接字处于SYN_RCVD状态;
        * 已完成连接队列: 每个已完成TCP三路握手过程的客户(ESTABLISHED状态);
    6) 如果三路握手正常完成, 则从未完成队列移到已完成连接队列的队尾; 当调用
       accept时, 已完成连接队列中的队头返回给进程; 如果该队列为空, 那进程进
       入睡眠状态直到TCP在该队列中放入一项为止;
    7) 当一个客户SYN到达, 若队列是满的, TCP就忽略该分节不发送RST;
    8) 在三路握手完成后, 但服务器调用accept之前到达的数据应由服务器TCP排队,
       最大数据量为相应已连接套接字的接收缓冲区大小;
