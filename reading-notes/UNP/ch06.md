# **I/O复用: select和poll函数**
***

## **1. IO复用典型场合**
  * 客户处理多个描述符时
  * 一个客户同时处理多个套接字
  * 一个TCP服务器既要处理监听套接字, 又要处理已连接套接字
  * 一个服务器既要处理TCP又要处理UDP
  * 一个服务器要处理多个服务或多个协议


## **2. IO模型**
    1) Unix下可用的IO模型:
        * 阻塞式IO
        * 非阻塞式IO
        * IO复用(select和poll)
        * 信号驱动式IO(SIGIO)
        * 异步IO(POSIX的aio_系列函数)
> ### **2.1 阻塞式IO模型**
    1) 默认所有套接字都是阻塞的
    2) 就UDP而言, 数据准备好就是: 要么整个数据报已经收到, 要么没有;
    3) 进程调用recvfrom, 系统调用直到数据报到达且被复制到应用进程的缓存区
       或发生错误才返回;
> ### **2.2 非阻塞式IO模型**
    1) 把一个套接字设置成非阻塞是通知内核:
        当所请求的IO操作非得把本进程放到睡眠才能完成时, 不要把本进程投入
        睡眠, 而是返回一个错误;
    2) 一个应用对一个非阻塞描述符循环调用recvfrom时, 就是轮询;
> ### **2.3 IO复用模型**
    1) 调用select或poll, 阻塞在这两个系统调用之上, 而不是阻塞在真正的IO调
       用之上;
    2) 阻塞与select或poll上, 等待数据报套接字变为可读; 当满足这个条件时,
       再调用recvfrom将所读数据复制到进程缓存区;
> ### **2.4 信号驱动式IO模型**
    1) 用信号, 让内核在描述符就绪的时候发送SIGIO信号通知我们;
    2) 开启套接字的信号驱动式IO功能, 并安装一个信号处理函数; 该函数立即返
       回, 我们继续工作; 当有数据准备好之后, 系统产生一个SIGIO信号, 然后
       我们再处理...
> ### **2.5 异步IO模型**
    1) 告知内核启动某个操作, 并让内核在真个操作完成后通知我们;
    2) 和信号驱动式的区别是:
        * 信号驱动式是由内核通知我们何时可以启动一个IO操作;
        * 异步IO是内核通知我们IO操作合适完成;
