# **I/O复用: select和poll函数**
***

## **1. IO复用典型场合**
  * 客户处理多个描述符时
  * 一个客户同时处理多个套接字
  * 一个TCP服务器既要处理监听套接字, 又要处理已连接套接字
  * 一个服务器既要处理TCP又要处理UDP
  * 一个服务器要处理多个服务或多个协议


## **2. IO模型**
    1) Unix下可用的IO模型:
        * 阻塞式IO
        * 非阻塞式IO
        * IO复用(select和poll)
        * 信号驱动式IO(SIGIO)
        * 异步IO(POSIX的aio_系列函数)
> ### **2.1 阻塞式IO模型**
    1) 默认所有套接字都是阻塞的
    2) 就UDP而言, 数据准备好就是: 要么整个数据报已经收到, 要么没有;
    3) 进程调用recvfrom, 系统调用直到数据报到达且被复制到应用进程的缓存区
       或发生错误才返回;
> ### **2.2 非阻塞式IO模型**
    1) 把一个套接字设置成非阻塞是通知内核:
        当所请求的IO操作非得把本进程放到睡眠才能完成时, 不要把本进程投入
        睡眠, 而是返回一个错误;
    2) 一个应用对一个非阻塞描述符循环调用recvfrom时, 就是轮询;
> ### **2.3 IO复用模型**
    1) 调用select或poll, 阻塞在这两个系统调用之上, 而不是阻塞在真正的IO调
       用之上;
    2) 阻塞与select或poll上, 等待数据报套接字变为可读; 当满足这个条件时,
       再调用recvfrom将所读数据复制到进程缓存区;
> ### **2.4 信号驱动式IO模型**
    1) 用信号, 让内核在描述符就绪的时候发送SIGIO信号通知我们;
    2) 开启套接字的信号驱动式IO功能, 并安装一个信号处理函数; 该函数立即返
       回, 我们继续工作; 当有数据准备好之后, 系统产生一个SIGIO信号, 然后
       我们再处理...
> ### **2.5 异步IO模型**
    1) 告知内核启动某个操作, 并让内核在真个操作完成后通知我们;
    2) 和信号驱动式的区别是:
        * 信号驱动式是由内核通知我们何时可以启动一个IO操作;
        * 异步IO是内核通知我们IO操作合适完成;


## **3. select函数**
        #include <sys/select.h>
        #include <sys/time.h>
        int select(int maxfdp1, fd_set* readset, fd_set* writeset,
            fd_set* exceptset, const struct timeval* timeout);
            => 若有就绪描述符则为其数目, 若超时返回0, 出错返回-1
    1) 允许进程指示内核等待多个事件中任何一个发生, 并只在有一个或多个事件发
       生或经历一段指定的时间后才唤醒它;
    2) 调用select告知内核对哪些描述符感兴趣以及等待多长时间;
    3) 对于timeout参数:
        * 永远等下去, 仅在有一个描述符准备好IO时才返回; 需要将参数设为NULL;
        * 等待一段固定时间, 在有一个描述符准备好IO时返回, 但不超过该参数指定
          的时间;
        * 不等待: 检查后立即返回(轮询); timeout参数的秒和微秒必须为0;
    4) select的中间3个参数, 如果我们不感兴趣可以直接设置为NULL;
    5) maxfdp1指定待测试的描述符个数, 是待测试的最大描述符加1;
