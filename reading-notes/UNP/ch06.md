# **I/O复用: select和poll函数**
***

## **1. IO复用典型场合**
  * 客户处理多个描述符时
  * 一个客户同时处理多个套接字
  * 一个TCP服务器既要处理监听套接字, 又要处理已连接套接字
  * 一个服务器既要处理TCP又要处理UDP
  * 一个服务器要处理多个服务或多个协议
  * IO复用并非限制于网络编程，许多重要的应用程序也需要使用这个技术

## **2. IO模型**
    1) Unix下可用的IO模型:
        * 阻塞式IO
        * 非阻塞式IO
        * IO复用(select和poll)
        * 信号驱动式IO(SIGIO)
        * 异步IO(POSIX的aio_系列函数)
> ### **2.1 阻塞式IO模型**
![阻塞式IO](./pic/6-1.png "阻塞式IO")

    1) 默认所有套接字都是阻塞的
    2) 就UDP而言, 数据准备好就是: 要么整个数据报已经收到, 要么没有;
       对于recvfrom调用一般都会从应用进程空间中运行切换到在内核空间中运行，一段
       时间之后再切换回来。
    3) 进程调用recvfrom, 系统调用直到数据报到达且被复制到应用进程的缓存区
       或发生错误才返回; 常见错误是系统调用被信号终端，recvfrom返回成功后，应用
       进程开始处理数据报。
> ### **2.2 非阻塞式IO模型**
![非阻塞式IO](./pic/6-2.png "非阻塞式IO")

    1) 把一个套接字设置成非阻塞是通知内核:
        当所请求的IO操作非得把本进程放到睡眠才能完成时, 不要把本进程投入
        睡眠, 而是返回一个错误;
    2) 一个应用对一个非阻塞描述符循环调用recvfrom时, 就是轮询; 应用进程持续轮询
       内核，以查看某个操作是否就绪。
> ### **2.3 IO复用模型**
    1) 调用select或poll, 阻塞在这两个系统调用之上, 而不是阻塞在真正的IO调
       用之上;
    2) 阻塞与select或poll上, 等待数据报套接字变为可读; 当满足这个条件时,
       再调用recvfrom将所读数据复制到进程缓存区;
> ### **2.4 信号驱动式IO模型**
    1) 用信号, 让内核在描述符就绪的时候发送SIGIO信号通知我们;
    2) 开启套接字的信号驱动式IO功能, 并安装一个信号处理函数; 该函数立即返
       回, 我们继续工作; 当有数据准备好之后, 系统产生一个SIGIO信号, 然后
       我们再处理...
> ### **2.5 异步IO模型**
    1) 告知内核启动某个操作, 并让内核在真个操作完成后通知我们;
    2) 和信号驱动式的区别是:
        * 信号驱动式是由内核通知我们何时可以启动一个IO操作;
        * 异步IO是内核通知我们IO操作合适完成;

## **3. select函数**
        #include <sys/select.h>
        #include <sys/time.h>
        int select(int maxfdp1, fd_set* readset, fd_set* writeset,
            fd_set* exceptset, const struct timeval* timeout);
            => 若有就绪描述符则为其数目, 若超时返回0, 出错返回-1
    1) 允许进程指示内核等待多个事件中任何一个发生, 并只在有一个或多个事件发
       生或经历一段指定的时间后才唤醒它;
    2) 调用select告知内核对哪些描述符感兴趣以及等待多长时间;
    3) 对于timeout参数:
        * 永远等下去, 仅在有一个描述符准备好IO时才返回; 需要将参数设为NULL;
        * 等待一段固定时间, 在有一个描述符准备好IO时返回, 但不超过该参数指定
          的时间;
        * 不等待: 检查后立即返回(轮询); timeout参数的秒和微秒必须为0;
    4) select的中间3个参数, 如果我们不感兴趣可以直接设置为NULL;
    5) maxfdp1指定待测试的描述符个数, 是待测试的最大描述符加1;
> ### **3.1 描述符就绪条件**
    1) 套接字准备好读的条件:
        * 该套接字接收缓冲区的数据字节大于等于套接字接收缓存区低水位标记的当
          前大小;
        * 该连接的读半步关闭(接收了FIN的TCP连接);
        * 该套接字是一个监听套接字且已完成的连接数不为0;
        * 其上有一个套接字错误等待处理;
    2) 套接字准备好写的条件:
        * 该套接字发送缓冲区的可用空间大于等于套接字发送缓存区低水位标记的当
          前大小, 或者该套接字已连接, 或该套接字不需要连接;
          可以使用SO_SNDLOWAT来设置低水位标记, 对TCP和UDP默认是2048;
        * 该连接的写半部关闭;
        * 使用非阻塞connect的套接字已建立连接, 或connect已经以失败告终;
        * 其上有一个套接字错误等待处理;
    3) 如果一个套接字存在带外数据或仍处于带外标记, 那么它有异常等待处理;
    4) 总结如下:
        * 有数据可读                => 可读
        * 关闭连接读一半            => 可读
        * 给监听套接口准备好新连接  => 可读
        * 有可用于写的空间          => 可写
        * 关闭连接的写一半          => 可写
        * 待处理错误                => 可读, 可写
        * TCP带外数据               => 异常


## **4. shutdown函数**
    1) close函数的限制:
        * 将描述符的引用计数减1, 仅在计数变为0的时候才关闭套接字;
        * close终止读和写两个方向的数据传送;
    2) shutdown
        #include <sys/socket.h>
        int shutdown(int sockfd, int howto);  => 返回: 成功返回0, 否则返回-1
    3) howto参数的取值:
        * SHUT_RD => 关闭连接的读一半, 套接字中不再有数据可接收, 而套接字接
          收缓冲区中的现有数据被丢弃; 不能再对进行任何读操作;
        * SHUT_WR => 关闭连接的写一半; 这就是半关闭; 套接字发送缓冲区的数据
          被发送掉, 后跟TCP的正常连接终止序列; 不能再进行任何写操作;
        * SHUT_RDWR => 连接的读半部和写半部都关闭;


## **5. pselect函数**
        #include <sys/select.h>
        #include <signal.h>
        #include <time.h>
        int pselect(int maxfdp1, fd_set* readset, fd_set* writeset,
            fd_set* exceptset, const struct timespec* timeout,
            const sigset_t* sigmask);
            => 若有就绪描述符返回其数目, 超时返回0, 出错返回-1
    1) 相对select的变换：
        * 使用timespec结构而不是timeval, 可精确到纳秒
        * pselect增加了第6个参数：一个指向信号掩码的指针


## **6. poll函数**
        #include <poll.h>
        int poll(struct pollfd* fdarray, unsigned long nfds, int timeout);
            => 若有就绪描述符则为其数目, 超时返回0, 出错返回-1
    1) 提供的功能与poll类似，不过在处理流设备时，提供额外的信息
    2) 第一个参数是一个pollfd结构的数组
        struct pollfd {
          int fd;
          short events;
          short revents;
        };
        要测试的成员由events指定，函数在相应的revents中返回该描述符的状态;
    3) poll的events和revents
        POLLIN: 可输入可结果; 普通或优先级带数据可读
        POLLRDNORM: 可输入可结果; 普通数据可读
        POLLRDBAND: 可输入可结果; 优先带数据可读
        POLLPRI: 可输入可结果; 高优先级数据可读
        POLLOUT: 可输入可结果; 普通数据可写
        POLLWRNORM: 可输入可结果; 普通数据可写
        POLLWRBAND: 可输入可结果; 优先级带数据可写
        POLLERR: 可结果; 发生错误
        POLLHUP: 可结果; 发生挂起
        POLLNVAL: 可结果; 描述符不是一个打开的文件
    4) poll识别3类数据: 普通，优先级带和高优先级
    5) TCP和UDP，以下条件poll返回特定revent
        * 所有正规TCP数据和所有UDP数据都被认为是普通数据
        * TCP的带外数据被认为是优先级带数据
        * 当TCP的读半部关闭时，也认为是普通数据，随后读操作返回0
        * TCP连接存在错误即可认为是普通数据，也可认为是错误，随后的读返回-1
        * 监听套接字上有新连接既可认为是普通数据，也可认为是优先级数据
        * 非阻塞式connect完成被认为是使相应套接字可写


## **7. 小结**
    1) 不同的IO模型：
        * 阻塞式IO模型
        * 非阻塞式IO模型
        * IO复用模型
        * 信号驱动式IO模型
        * 异步IO模型
    2)  默认是阻塞式IO模型，它是最常用的IO模型
    3) IO复用模型最常用的函数是select
