# **I/O复用: select和poll函数**
***

## **1. IO复用典型场合**
  * 客户处理多个描述符时
  * 一个客户同时处理多个套接字
  * 一个TCP服务器既要处理监听套接字, 又要处理已连接套接字
  * 一个服务器既要处理TCP又要处理UDP
  * 一个服务器要处理多个服务或多个协议


## **2. IO模型**
    1) Unix下可用的IO模型:
        * 阻塞式IO
        * 非阻塞式IO
        * IO复用(select和poll)
        * 信号驱动式IO(SIGIO)
        * 异步IO(POSIX的aio_系列函数)
> ### **2.1 阻塞式IO模型**
    1) 默认所有套接字都是阻塞的
    2) 就UDP而言, 数据准备好就是: 要么整个数据报已经收到, 要么没有;
    3) 进程调用recvfrom, 系统调用直到数据报到达且被复制到应用进程的缓存区
       或发生错误才返回;
> ### **2.2 非阻塞式IO模型**
    1) 把一个套接字设置成非阻塞是通知内核:
        当所请求的IO操作非得把本进程放到睡眠才能完成时, 不要把本进程投入
        睡眠, 而是返回一个错误;
    2) 一个应用对一个非阻塞描述符循环调用recvfrom时, 就是轮询;
> ### **2.3 IO复用模型**
    1) 调用select或poll, 阻塞在这两个系统调用之上, 而不是阻塞在真正的IO调
       用之上;
    2) 阻塞与select或poll上, 等待数据报套接字变为可读; 当满足这个条件时,
       再调用recvfrom将所读数据复制到进程缓存区;
> ### **2.4 信号驱动式IO模型**
    1) 用信号, 让内核在描述符就绪的时候发送SIGIO信号通知我们;
    2) 开启套接字的信号驱动式IO功能, 并安装一个信号处理函数; 该函数立即返
       回, 我们继续工作; 当有数据准备好之后, 系统产生一个SIGIO信号, 然后
       我们再处理...
> ### **2.5 异步IO模型**
    1) 告知内核启动某个操作, 并让内核在真个操作完成后通知我们;
    2) 和信号驱动式的区别是:
        * 信号驱动式是由内核通知我们何时可以启动一个IO操作;
        * 异步IO是内核通知我们IO操作合适完成;


## **3. select函数**
        #include <sys/select.h>
        #include <sys/time.h>
        int select(int maxfdp1, fd_set* readset, fd_set* writeset,
            fd_set* exceptset, const struct timeval* timeout);
            => 若有就绪描述符则为其数目, 若超时返回0, 出错返回-1
    1) 允许进程指示内核等待多个事件中任何一个发生, 并只在有一个或多个事件发
       生或经历一段指定的时间后才唤醒它;
    2) 调用select告知内核对哪些描述符感兴趣以及等待多长时间;
    3) 对于timeout参数:
        * 永远等下去, 仅在有一个描述符准备好IO时才返回; 需要将参数设为NULL;
        * 等待一段固定时间, 在有一个描述符准备好IO时返回, 但不超过该参数指定
          的时间;
        * 不等待: 检查后立即返回(轮询); timeout参数的秒和微秒必须为0;
    4) select的中间3个参数, 如果我们不感兴趣可以直接设置为NULL;
    5) maxfdp1指定待测试的描述符个数, 是待测试的最大描述符加1;
> ### **3.1 描述符就绪条件**
    1) 套接字准备好读的条件:
        * 该套接字接收缓冲区的数据字节大于等于套接字接收缓存区低水位标记的当
          前大小;
        * 该连接的读半步关闭(接收了FIN的TCP连接);
        * 该套接字是一个监听套接字且已完成的连接数不为0;
        * 其上有一个套接字错误等待处理;
    2) 套接字准备好写的条件:
        * 该套接字发送缓冲区的可用空间大于等于套接字发送缓存区低水位标记的当
          前大小, 或者该套接字已连接, 或该套接字不需要连接;
          可以使用SO_SNDLOWAT来设置低水位标记, 对TCP和UDP默认是2048;
        * 该连接的写半部关闭;
        * 使用非阻塞connect的套接字已建立连接, 或connect已经以失败告终;
        * 其上有一个套接字错误等待处理;
    3) 如果一个套接字存在带外数据或仍处于带外标记, 那么它有异常等待处理;
    4) 总结如下:
        * 有数据可读                => 可读
        * 关闭连接读一半            => 可读
        * 给监听套接口准备好新连接  => 可读
        * 有可用于写的空间          => 可写
        * 关闭连接的写一半          => 可写
        * 待处理错误                => 可读, 可写
        * TCP带外数据               => 异常


## **4. shutdown函数**
    1) close函数的限制:
        * 将描述符的引用计数减1, 仅在计数变为0的时候才关闭套接字;
        * close终止读和写两个方向的数据传送;
    2) shutdown
        #include <sys/socket.h>
        int shutdown(int sockfd, int howto);  => 返回: 成功返回0, 否则返回-1
    3) howto参数的取值:
        * SHUT_RD => 关闭连接的读一半, 套接字中不再有数据可接收, 而套接字接
          收缓冲区中的现有数据被丢弃; 不能再对进行任何读操作;
        * SHUT_WR => 关闭连接的写一半; 这就是半关闭; 套接字发送缓冲区的数据
          被发送掉, 后跟TCP的正常连接终止序列; 不能再进行任何写操作;
        * SHUT_RDWR => 连接的读半部和写半部都关闭;
