# **基本UDP套接字编程**
***


## **1. recvfrom和sendto函数**
        #include <sys/socket.h>
        ssize_t recvfrom(int sockfd, void* buff, size_t nbytes, int flags,
                struct sockaddr* from, socklen_t* addrlen);
        ssize_t sendto(int sockfd, const void* buff, size_t nbytes, 
                int flags, const struct sockaddr* to, socklen_t addrlen);
                => 返回：成功返回读或写的字节数，出错返回-1；
    1) sendto的to指向一个含有数据报接收者的协议地址的套接字地址结构；
    2) recvfrom的from指向一个将由该函数在返回时填写数据报发送者的协议地址的
       套接字地址结构；
    3) 这两个函数都把所读写数据的长度作为函数返回值；
    4) 写一个长度为0的数据报是可以的；UDP下会形成一个只包含一个IP首部(IPv4是
       20字节，IPv6是40字节)和一个8字节UDP首部而没有数据的IP数据报；
    5) recvfrom返回0是可接受的，UDP是无连接的，没有关闭一个UDP连接之类的事；
    6) 如果recvfrom的from是一个空指针，那么addrlen也必须是一个空指针；


## **2. 数据报的丢失**
    1) UDP是不可靠的，如果一个客户数据报丢失，客户将永远阻塞在recvfrom上；
       为了防止这样永久的阻塞需要给客户的recvfrom调用设置一个超时；
    2) 仅recvfrom设置超时是不够的，我们无法判断超时是我们的数据没有达到服务
       器还是服务器的应答没有回到客户；
