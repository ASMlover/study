# **高级IO函数**
***

## **1. 套接字超时**
    1) 涉及套接字的IO上设置超时的方法有3种：
        * 调用alarm，在指定超时期满时产生SIGALRM信号；
        * 在select中阻塞等待IO，以此代替直接阻塞在read或write调用上；
        * 使用SO_RCVTIMEO和SO_SNDTIMEO套接字选项；


## **2. recv和send函数**
      #include <sys/socket.h>
      ssize_t recv(int sockfd, void* buff, size_t nbytes, int flags);
      ssize_t send(int sockfd, const void* buff, size_t nbytes, int flags);
                => 成功返回读入或写出的字节数，出错返回-1
    1) flags参数如下：
        * MSG_DONTROUTE 告知内核目的主机在某个直接连接的本地网络上，因而无需
                        执行路由表查找；
        * MSG_DONTWAIT  在无需打开相应套接字的非阻塞标志的前提下，把单个IO操
                        作临时指定为非阻塞，接着执行IO操作，然后关闭非阻塞
                        标志；
        * MSG_OOB       对send指明即将发送带外数据；对recv指明即将读入的是带
                        外数据而不是普通数据；
        * MSG_PEEK      适用于recv和recvfrom，允许我们查看已可读的数据，而系
                        统不在recv和recvfrom返回后丢弃这些数据；
        * MSG_WAITALL   告知内核不要在尚未读入请求数目的字节之前让一个读操作
                        返回；

## **3. readv和writev函数**
        #include <sys/uio.h>
        ssize_t readv(int filedes, const struct iovec* iov, int iovcnt);
        ssize_t writev(int filedes, const struct iovec* iov, int iovcnt);
                => 成功返回读入或写出的字节数，出错返回-1
    1) 类似read和write，但允许单个系统调用读入到或写出自一个或多个缓冲区；
    2) iovec结构如下：
        struct iovec {
          void* iov_base;
          size_t iov_len;
        };
        * iovec结构数组中元素的数目存在某个限制，具体取决于实现；IOV_MAX至少
          是16；
    3) writev是一个原子操作；
