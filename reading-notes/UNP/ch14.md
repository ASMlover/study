# **高级IO函数**
***

## **1. 套接字超时**
    1) 涉及套接字的IO上设置超时的方法有3种：
        * 调用alarm，在指定超时期满时产生SIGALRM信号；
        * 在select中阻塞等待IO，以此代替直接阻塞在read或write调用上；
        * 使用SO_RCVTIMEO和SO_SNDTIMEO套接字选项；


## **2. recv和send函数**
      #include <sys/socket.h>
      ssize_t recv(int sockfd, void* buff, size_t nbytes, int flags);
      ssize_t send(int sockfd, const void* buff, size_t nbytes, int flags);
                => 成功返回读入或写出的字节数，出错返回-1
    1) flags参数如下：
        * MSG_DONTROUTE 告知内核目的主机在某个直接连接的本地网络上，因而无需
                        执行路由表查找；
        * MSG_DONTWAIT  在无需打开相应套接字的非阻塞标志的前提下，把单个IO操
                        作临时指定为非阻塞，接着执行IO操作，然后关闭非阻塞
                        标志；
        * MSG_OOB       对send指明即将发送带外数据；对recv指明即将读入的是带
                        外数据而不是普通数据；
        * MSG_PEEK      适用于recv和recvfrom，允许我们查看已可读的数据，而系
                        统不在recv和recvfrom返回后丢弃这些数据；
        * MSG_WAITALL   告知内核不要在尚未读入请求数目的字节之前让一个读操作
                        返回；

## **3. readv和writev函数**
        #include <sys/uio.h>
        ssize_t readv(int filedes, const struct iovec* iov, int iovcnt);
        ssize_t writev(int filedes, const struct iovec* iov, int iovcnt);
                => 成功返回读入或写出的字节数，出错返回-1
    1) 类似read和write，但允许单个系统调用读入到或写出自一个或多个缓冲区；
    2) iovec结构如下：
        struct iovec {
          void* iov_base;
          size_t iov_len;
        };
        * iovec结构数组中元素的数目存在某个限制，具体取决于实现；IOV_MAX至少
          是16；
    3) writev是一个原子操作；


## **4. recvmsg和sendmsg函数**
        #include <sys/socket.h>
        ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);
        ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);
                => 成功返回读入或写出的字节数，出错返回-1
    1) msghdr结构如下：
        struct msghdr {
          void*         msg_name;
          socklen_t     msg_namelen;
          struct iovec* msg_iov;
          int           msg_iovlen;
          void*         msg_control;
          socklen_t     msg_controllen;
          int           msg_flags;
        };
        * msg_name和msg_namelen这两个成员用于套接字未连接的场合；
        * msg_name指向一个套接字地址结构，调用者在其中存放接收者或发送者的协
          议地址；如果无需指明协议地址，msg_name应设为NULL；
        * msg_iov和msg_iovlen指定输入或输出缓冲区数组；
        * msg_control和msg_controllen指定可选的辅助数据的位置和大小；
        * 只有recvmsg使用msg_flags成员；
        * sendmsg忽略msg_flags成员，它直接使用flags从那数驱动发送处理过程；

## **5. 辅助数据**
    1) 可通过sendmsg和recvmsg，使用msghdr结构中的msg_control和msg_controllen
       来实现发送和接收；
    2) 辅助数据的用途总结：
        * IPv4  IPPROTO_IP       IP_RECVDSTADDR 随UDP数据报接收目的地址
                                 IP_RECVIF      随UDP数据报接收接口索引
        * IPv6  IPPROTO_IPV6     IPV6_DSTOPTS   指定/接收目的地选项
                                 IPV6_HOPLIMIT  指定/接收跳限
                                 IPV6_HOPOPTS   指定/接收步跳选项
                                 IPV6_NEXTHOP   指定下一跳地址
                                 IPV6_PKTINFO   指定/接收分组信息
                                 IPV6_PTHDR     指定/接收路由首部
                                 IPV6_TCLASS    指定/接收分组流通类别
        * Unix域 SOL_SOCKET      SCM_RIGHTS     发送/接收描述符
                                 SCM_CREDS      发送/接收用户凭证
    3) msg_control填充的cmsghdr结构如下：
        struct cmsghdr {
          socklen_t cmsg_len;
          int       cmsg_level;
          int       cmsg_type;
        };
    4) 简化对辅助数据处理的宏：
        #include <sys/socket.h>
        #include <sys/param.h>
        struct cmsghdr* CMSG_FIRSTHDR(struct msghdr* mhdrptr);
                => 返回：指向第一个cmsghdr结构的指针，若无辅助数据则为NULL
        struct cmsghdr* CMSG_NXTHDR(
                struct msghdr* mhdrptr, struct cmsghdr* cmsgptr);
                => 返回指向下一个cmsghdr的指针，不再有辅助数据则为NULL
        unsigned char* CMSG_DATA(struct cmsghdr* cmsgptr);
                => 返回指向与cmsghdr结构关联的数据的第一个字节的指针
        unsigned int CMSG_LEN(unsigned int length);
                => 返回：给定数据量下存放到cmsg_len中的值
        unsigned int CMSG_SPACE(unsigned int length);
                => 返回：给定数据量下一个辅助数据对象总的大小
