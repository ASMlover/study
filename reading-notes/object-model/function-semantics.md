# **Function语意学** #
***


## **1. 成员的各种调用方式** ##
> ### **1.1 非静态成员函数** ###
    1) C++设计准则之一是, 非静态成员函数至少必须和一般的非成员函数具有相同的
       效率
    2) 成员函数被内化为非成员的形式, 具体转换步骤如下:
        改写函数原型以安插一个额外的参数到成员函数中, 用以提供一个存取管道, 
        使类对象得以调用该函数(额外的参数就是this指针);
        将每一个对非静态数据成员的存取操作修改为经由this指针来存取;
        将成员函数重新写成一个外部函数, 对函数名称进行"manging"处理, 使它在
        程序中成为独一无二的词汇;
> ### **1.2 名称的特殊处理** ###
    1) 一般而言, 成员的名称前面会被加上类名称, 形成独一无二的名字
        //! C++
        class Bar {
        public:
          int ival;
        };
        其中ival经过特殊处理可能是ival_3Bar;
        这样当Bar的子类同样有个ival成员的时候, 则其经过特殊处理后仍是唯一的:
        class Foo : pubilc Bar {
        public:
          int ival;
        };
        那在Foo内部则可能被转化为:
        class Foo {
        public:
          int ival_3Bar;
          int ival_3Foo;
        };
        对成员函数的处理也是如此, 当两个函数重载的时候, 加上函数的参数列表, 
        既可以让成员函数独一无二了:
        class Point {
        public:
          void x(float newX);
          float x(void);
        };
        可能被处理为:
        class Point {
        public:
          void x_5PointFf(float newX);
          float x_5PointFv(void);
        };
> ### **1.3 虚拟成员函数** ###
    1) 如果normalize是一个虚成员函数, 那么下面的调用:
        ptr->normalize();
        将会被转换为:
        (*ptr->vptr[1])(ptr);
        * vptr表示由编译器产生的指针, 指向虚表; 它被安插在每一个"声明有(或继
          承自)一个或多个虚函数"的类对象中;
        * 1表示虚表slot的索引值, 关联到normalize函数
        * 第二个ptr是this指针
> ### **1.4 静态成员函数** ###
    1) 如果normalize是一个静态成员函数, 那么下面的调用操作:
        obj.normalize();
        ptr->normalize();
        会被转换为一般的非成员函数的调用, 如下:
        // obj.normalize();
        normalize_7Point3dSFv();
        // ptr->normalize();
        normalize_7Point3dSFv();
    2) 静态成员函数的主要特征就是它没有this指针
        * 不能够直接存取其类中的非静态成员
        * 不能被声明为const, volatile或virtual
        * 不需要经由类对象才被调用——虽然大部分时候它是这样被调用的
    3) 静态成员函数由于缺乏this指针, 因此差不多等同于非成员函数; 其提供的一
       个好处就是成为一个回调函数




## **2. 虚拟成员函数** ##
        每个类有一个虚表, 内含该类中有作用的虚函数的地址, 然后每个对象有一个
    vptr, 指向虚表的所在。
    1) 以下的调用操作将需要ptr在执行期间的某些相关信息:
        ptr->z();
        一个指针含有两项信息:
        * 它所参考到的对象的地址
        * 对象类型的某种编码, 或是某个结构的地址
    2) 我们可以在每一个多态的类对象身上增加两个成员:
        * 一个字符串火数字, 表示类的类型
        * 一个指针, 指向某表格, 表格中带有程序的虚函数的执行期地址
    3) 首先需要在执行期备妥那些函数地址, 然后找到那些地址:
        * 为了找到表格, 每个类对象被安插上一个由编译器内部产生的指针, 指向该
          表格 
        * 为了找到函数地址, 每一个虚函数被指派一个表格索引值
    4) 一个类只会有一个虚表, 每个表内含其对应的类对象中所有的活跃虚函数实体
       的地址; 这些活跃虚函数包括:
        * 这个类所定义的函数实体; 它会改写一个可能存在的基类虚函数的函数实体
        * 继承自基类的函数实体; 这实在子类决定不改写虚函数时才会出现
        * 一个pure_virtual_called()函数实体, 它既可以扮演纯虚函数的空间保卫
          角色, 也可以当做执行期异常处理函数
    5) 例子:
        //! 基类如下:
        class Point {
        public:
          virtual ~Point(void);
          virtual Point& mult(float) = 0;
          //! ...
          float x(void) const { return x_; }
          virtual float y(void) const { return 0; }
          virtual float z(void) const { return 0; }
        protected:
          Point(float x = 0.0);
          float x_;
        };
        当一个类派生自Point时:
        * 可以继承基类所声明的虚函数的函数实体; 即是该函数实体的地址会被拷贝
          到子类的虚表相对应的slot中
        * 可以使用自己的函数实体; 它自己的函数实体的地址必须放在对于的slot中
        * 可以加入一个新的虚函数; 这时虚表的尺寸会增大一个slot, 而新的函数实
          体地址会被放进该slot中
    6) 如果有一个ptr->z();的调用, 那么在编译期间:
        * 并不知道ptr所指对象的真正类型, 但是经由ptr可以存取到该对象的虚表
        * 虽然不知道哪一个z函数实体会被调用, 但是每一个z函数的地址都被放在了
          slot 4(以上面继承Point的类为例子)
> ### **2.1 多重继承下的虚函数** ###
        在多重继承中的虚函数, 其复杂度围绕在第二个及后继的基类身上, 以及"必
    须在执行期调整this指针"这一点上
    1) 对于下面的操作:
        Base1* pbase1 = new Derived;
        Base2* pbase2 = new Derived;
        delete pbase1;
        delete pbase2;
        虽然两个delete操作导致相同的Derived析构函数, 但是它们需要两个不同的
        虚表slots:
        * pbase1不需要调整this指针(因为Base1是最左端基类, 它已经指向Derived
          对象的起始处)
        * pbase2需要调整this指针, 其虚表slot需要相关的thunk地址
    2) 多重继承之下, 一个继承类内含n - 1个额外的虚表, n表示其上一层基类的数
       目(单一继承将不会有额外的虚表):
        * 一个主要实体, 与Base1(最左端基类)共享
        * 一个次要实体, 与Base2(第二个急了)有关
> ### **2.2 虚拟继承下的虚函数** ###
    1) 在虚继承下, 即使是单一继承, 在对象转换的时候也需要进行this指针调整
    2) 不要在一个虚基类中声明非静态数据成员(否则, 经进入复杂的深渊)



## **3. 指向成员函数的指针** ##
    1) 指向成员啊函数的指针的声明语法, 以及指向"member selection运算符"的指
       针, 作用是作为this指针的空间保留着; 其就是静态成员函数的类型是函数指
       针, 而不是指向成员函数的指针
    2) 使用一个成员函数指针, 如果并不用于虚函数, 多重继承, 虚基类等情况的话,
       并不会比使用一个非成员函数指针的成本高
> ### **3.1 支持"指向虚成员函数"之指针** ###
    1) 对一个虚成员函数取其地址, 所能获得的只是一个索引值
> ### **3.2 在多重继承之下, 指向成员函数的指针** ###
        //! 支持在多重继承下指向成员函数的指针
        struct __mptr {
          int delta;
          int index;
          union {
            ptrtofunc faddr;
            int       v_offset;
          };
        };
    许多编译器在自身内部根据不同的类特性提供多种指向成员函数的指针形式, 微软
    的如下:
    1) 一个单一继承实例(其中带有vcall thunk地址或函数地址)
    2) 一个多重继承实例(其中带有faddr和delta两个members)
    3) 一个虚拟继承实例(其中带有四个members)



## **4. 内联函数** ##
    1) 关键字inline只是一项请求, 如果该请求被接受, 编译器就必须认为它可以用
       一个表达式合理的将这个函数扩展开来
    2) 处理一个inline函数有两个阶段
        * 分析函数定义, 以决定函数的"本质内联能力"
          如果函数因为其复杂度, 或其构造问题被判断不可成员inline, 它会被转换
          为一个静态函数, 并在被编译模块内产生对应的函数定义;
        * 真正的inline函数扩展操作是在调用的哪一点上, 这会带来参数的求值操作
          以及临时性对象的管理
> ### **4.1 形式参数** ###
    1) 如果实际参数是一个常量表达式, 我们可以在替换之前先完成其求值操作; 后
       继的inline替换, 就可以把常量直接绑上去; 如果既不是常量表达式, 也不是
       带有副作用的表达式就直接替换
    2) 例子:
        //! 假设inline函数如下
        inline int 
        min(int x, int y)
        {
          return (x < y ? x : y);
        }
        //! 调用例子如下:
        inline int 
        bar(void)
        {
          int minval;
          int val1 = 1024;
          int val2 = 2048;
          minval = min(val1, val2);       //! 1
          minval = min(1024, 2048);       //! 2
          minval = min(foo(), bar() + 1); //! 3
          return minval;
        }
        * 标示1的那一行会被替换为:
          minval = val1 < val2 ? val1 : val2;
        * 标示2的那一行直接使用常量:
          minval = 1024
        * 标示3的那一行, 会引发副作用, 需要导入一个临时变量来避免重复求值:
          int t1, t2;
          minval = (t1 = foo()), (t2 = bar() + 1), t1 < t2 ? t1 : t2;
> ### **4.2 局部变量** ###
    1) inline函数中的每一个局部变量都必须被放在函数调用的一个封闭区段中, 拥
       有一个独一无二的名称; 
       如果inline函数以单一表达式扩展多次, 那么每次扩展都需要自己的一组局部
       变量;
       如果inline函数以分离的多个式子被扩展多次, 那么只需要一组局部变量就可
       以重复使用;
    2) inline函数中的局部变量, 在加上有副作用的参数, 可能会导致大量临时性对
       象的产生式
    3) inline函数对于封装提供了一种必要的支持, 可以有效的存取封装于类中的非
       公有数据; 也是C程序中大量使用#define的一个安全替代品; 然而一个inline
       函数如果被调用太多次的话, 会产生大量的扩展码, 使程序的大小暴涨
