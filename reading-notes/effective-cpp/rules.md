# **Effective C++ Rules**
***


## **All Rules**
 * 01. 视C++为一个语言联邦
 * 02. 尽量以以const, enum, inline替换#define
 * 03. 尽量使用const 
 * 04. 确定对象被使用前已先被初始化
 * 05. 了解C++默默编写并调用哪些函数
 * 06. 若不想使用编译器自动生成的函数, 就该明确拒绝
 * 07. 为多态基类声明虚析构函数
 * 08. 别让异常逃离析构函数
 * 09. 绝不在构造和析构函数中调用虚函数
 * 10. 让赋值函数返回一个指向*this的引用
 * 11. 在赋值函数中处理"自我赋值"
 * 12. 复制对象时不要忘记其每一个成分
 * 13. 以对象管理资源
 * 14. 在资源管理类中小心拷贝行为
 * 15. 在资源管理类中提供对原始资源的访问
 * 16. 成对使用new和delete时要采取相同形式
 * 17. 以独立语句将new的对象放到智能指针中
 * 18. 让接口容易被正确使用, 不易被误用
 * 19. 像设计类型来设计类(我们设计的类的行为应该如语言内置类型一样)
 * 20. 以pass by reference to const替换pass by value
 * 21. 必须返回对象时, 不要返回其引用
 * 22. 将成员变量声明为为私有的
 * 23. 以non-member和no-friend替换掉member函数
 * 24. 若所有参数都需要类型转换, 请采用non-member函数 
 * 25. 写一个不抛出异常的swap函数 
 * 26. 尽量延后变量定义式的出现时间
 * 27. 尽量少做转型动作 
 * 28. 避免返回指向对象内部成分的句柄 
 * 29. 值得为"异常安全"而努力 
 * 30. 透彻了解inlining的里里外外
 * 31. 将文件间的编译依存关系降至最低
 * 32. 确定你的公有继承模型是is-a关系
 * 33. 避免遮掩继承而来的名称
 * 34. 区分接口继承和实现继承
 * 35. 考虑虚函数以外的其他选择
 * 36. 绝不重新定义继承而来的非虚函数
 * 37. 绝不重新定义继承而来的缺省参数值
 * 38. 通过复合塑模出has-a或根据某物实现出
 * 39. 明智而审慎地使用私有继承
 * 40. 明智而审慎地使用多重继承
