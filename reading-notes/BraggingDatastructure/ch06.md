# **树**
***


## **1. 树的定义**
    1) 定义
        * 是n个结点的有限集;
        * n=0为空树;
        * 非空树:
          - 有且仅有一个特定的根结点
          - n>1, 其余结点为m个互不相交的优先集
          - 每一个集合本身又是一颗树(子树)
    2) 结点的子树的根为该结点的孩子, 该结点为孩子的双亲
    3) 结点的层次从根开始定义, 根为第一层, 根的孩子为第二层
    4) 如将树中结点的各子树看成从左到右是有次序的, 不可互换, 则为有序树, 否
       则为无序树
    5) 森林是m棵互不相交的树的集合


## **2. 树的存储结构**
    1) 以一组连续空间存储, 同时在每个结点中, 附设一个指示器指示其双亲结点到
       链表中的位置;
    2) 每个结点多个指针域, 每个指针指向一棵树的根结点, 这就是多重链表表示法
    3) 任意一棵树, 它的结点的第一个孩子如果存在就是唯一的, 它的右兄弟如果存
       在也是唯一的; 设两个指针, 分别指向该结点的第一个孩子和此结点的右兄弟


## **3. 二叉树的定义**
    1) 是那个结点的有限集合; 该集合或为空集, 或由一个根结点和两棵互不相交的
       分别为根结点的左子树和右子树的二叉树组成
    2) 二叉树的特点:
        * 每个结点最多有两棵子树;
        * 左子树和右子树是有序的, 次序不能任意颠倒;
        * 即使树中某结点只有一棵子树, 也要区分它是左子树还是右子树;
    3) 二叉树的五种基本形态:
        * 空二叉树
        * 只有一个根结点
        * 根结点只有左子树
        * 根结点只有右子树
        * 根结点既有左子树, 又有右子树
    4) 所有结点都只有左子树的二叉树是左斜树, 所有结点都只有右子树的二叉树是
       右斜树; 就是斜树
    5) 所有分支结点都存在左子树和右子树, 且所有叶子都在同一层; 这就是满二叉
       树
    6) 对具有n个结点的二叉树按层序编号, 如果编号为i(i<=i<=n)的结点与同样深度
       的满二叉树中的编号i的结点在二叉树中的位置完全相同; 则是完全二叉树
    7) 完全二叉树的特点:
        * 叶子结点只能出现在最下两层
        * 最下层的叶子一定集中在左部连续位置
        * 倒数二层, 若有叶子结点, 一定都在右部连续位置
        * 如结点度为1, 则该结点只有左孩子, 即不存在只有右子树的情况
        * 同样结点数的二叉树, 完全二叉树的深度最小


## **4. 二叉树的性质**
    1) 在二叉树的第i层上至多2^(i-1)个结点(i >= 1)
    2) 深度为k的二叉树至多有2^k-1个结点(k >= 1)
    3) 对任何一棵二叉树T, 如其终端结点数为n0, 度为2的结点数为n2, n0=n2+1
    4) 具有n个结点的完全二叉树的深度为[log2n]+1
    5) 如对一棵有n个结点的完全二叉树的结点按层序编号, 对任一结点i(1<=i<=n)
        * 如i=1, 则结点i是二叉树的根, 无双亲; 如i>1, 双亲是结点[i/2]
        * 如2i>n, 结点i无左孩子; 否则其左孩子是结点2i
        * 如2i+1>n, 则结点i无右孩子; 否则其右孩子是结点2i+1


## **5. 二叉树的存储结构**
    1) 二叉树每个结点最多有2个孩子, 设计为一个数据域和两个指针域, 这样的链表
       为二叉链表


## **6. 遍历二叉树**
    1) 从根结点出发, 按某种次序依次访问二叉树中的所有结点, 使得每个结点被访
       问且仅访问一次
    2) 前序遍历: 
        若树为空, 则空操作返回, 否则先访问根结点, 然后谦虚遍历左子树再前序遍
        历右子树;
    3) 中序遍历:
        若树为空, 则空操作返回, 否则从根结点开始, 中序遍历根结点的左子树, 然
        后访问根结点, 最后中序遍历右子树;
    4) 后序遍历:
        若树为空, 则空操作返回, 否则从左到右先叶子后结点的方式遍历访问左右子
        树, 最后访问根结点;
    5) 层序遍历:
        若树为空, 则空操作返回, 否则从树的第一层, 也就是根结点开始访问, 从上
        而下逐层遍历, 在同一层中, 按从左到右的顺序对结点逐个访问;


## **7. 二叉树的建立**
    1) 建立二叉树也是利用递归的原理



## **8. 线索二叉树**
    1) 线索二叉树结构:
         --------------------------------------
        | lchild | ltag | data | rtag | rchild |
         --------------------------------------
        * ltag为0时指向该结点的左孩子, 为1时指向该结点的前驱;
        * rtag为0时指向该结点的右孩子, 为1时指向该结点的后继;
    2) 如所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继, 
       那么最好选用线索二叉链表的存储结构


## **9. 树、森林与二叉树的转换**
    1) 树转换为二叉树:
        * 加线; 在所有兄弟结点之间加一条连线;
        * 去线; 对树中每个结点, 只保留它与第一个孩子结点的连线, 删除它与其他
                孩子结点之间的连线;
        * 层次调整; 以树的根结点为轴心, 将整棵树顺时针旋转一定的角度, 使之结
                    点的右孩子;
    2) 森林转换为二叉树:
        * 把每个树转换为二叉树;
        * 第一棵二叉树不动, 从第二棵二叉树开始, 依次把后一棵二叉树的根结点做
          为前一棵二叉树的根结点的右孩子, 用线连接起来;
    3) 二叉树转换为树:
        * 加线; 若某结点的左孩子结点存在, 则将这个左孩子的右孩子结点, 右孩子
                的右孩子结点, 右孩子的右孩子的右孩子结点;
        * 去线; 删除原二叉树中所有结点与其右孩子结点的连线;
        * 层次调整; 使之结构层次分明;
    4) 二叉树转换为森林:
        * 从根结点开始, 右孩子存在则把与右孩子结点的连线删除, 再查看分离后的
          二叉树, 若右孩子存在, 则连线删除...
        * 再将每棵分离后的二叉树转换为树即可;


## **10. 总结**
    1) 二叉树每个结点最多两棵子树, 有左右之分;
