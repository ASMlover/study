# **异常**
***



## **9. 使用析构函数防止资源泄露**
    1) 使用auto_ptr代替raw指针, 可以在处理内部异常的情况下清除资源
        void ProcessAdoptions(istream& data_source) {
          while (data_source) {
            auto_ptr<ALA> pa(ReadALA(data_source));
            pa->ProcessAdoption();
          }
        }
       这样pa->ProcessAdoption()抛出异常的时候, 也可以正常清理资源;
    2) 对于C-like的接口, 需要释放资源可以使用类似如下方式:
        class WindowHandle : private UnCopyable {
          WINDOW_HANDLE w_;
        public:
          explicit WindowHandle(WINDOW_HANDLE w) 
            : w_(w) {
          }

          ~WindowHandle(void) {
            DestroyWindow(w_);
          }

          operator WINDOW_HANDLE(void) const {
            return w_;
          }
        };



## **10. 在构造函数中防止资源泄露**
    1) 用对应的auto_ptr对象替换指针成员变量就可以防止构造函数在存在异常时发
       生资源泄露, 就可以不用手工在析构函数中释放资源



## **11. 禁止异常信息传递到析构函数外**
    1) 如果在一个异常被激活的同时, 析构函数也会抛出异常, 并导致程序控制权转
       移到析构函数外, C++将调用terminate函数; 它将终止你程序的运行, 而且是
       立即终止, 甚至连局部对象都没有被释放;
    2) 禁止异常传递到析构函数外有两个原因: 
       * 能在异常转递的堆栈辗转开解的过程中防止terminate调用
       * 能帮助确保析构函数总能完成我们希望它做的所有事情


## **12. 理解"抛出一个异常"与"传递一个参数"或"调用一个虚函数"间的差异**
    1) 调用函数时, 程序的控制权最终还会返回到函数的调用处; 但是抛出一个异常
       时, 控制权永远不会回到抛出异常的地方;
    2) 不管对象是否进行析构, 抛出异常的时候都会对对象进行拷贝; 对异常对象进
       行强制复制拷贝, 由此抛出异常运行速度比传递参数要慢;
    3) 异常对象被拷贝的时候, 拷贝操作是由对象的拷贝构造函数完成的, 该拷贝构
       造函数是对象的镜头类型所对应的拷贝构造函数(也就是基类);
    4) catch(Widget w) ...
       会建立两个被抛出对象的拷贝, 一个是所有异常都必须建立的临时对象, 一个
       是把临时对象拷贝进w中

       catch(Widget& w) ...
       catch(const Widget& w) ...
       仍旧会建立一个被抛出对象的拷贝, 拷贝同样是一个临时对象
    5) 抛异常创建的一个临时对象, 应该是在一个全局的或者是堆栈上的, 因为当异
       常离开抛出异常的作用域时, 局部变量就已经被释放了;
    6) 函数调用者或抛出异常者与被调用者或异常捕获者之间的类型匹配过程不同;
        double sqrt(double);
        sqrt(1);
        函数中允许int到double的隐式类型转换, 而在try块中抛出的int异常不会被
        处理double异常的catch捕获;
        catch子句中进行异常匹配时可以进行两种转换, 继承类与基类间的转换(用来
        捕获基类的catch也可以处理派生类类型的异常), 允许从一个类型化指针转变
        成无类型指针(void*指针的catch能捕获任何类型的指针异常);
    7) 传递参数和传递异常间的最后一点区别是catch子句匹配顺序总是取决于它们在
       程序中出现的顺序;
    8) 3个主要区别:
        * 异常对象在传递时总是进行拷贝, 通过传值方式捕获时异常对象被拷贝2次,
          对象作为参数传递给函数时不一定需要拷贝;
        * 对象作为异常被抛出与作为参数传递给函数比, 前者类型转换比后者少;
        * catch子句进行异常类型匹配的顺序是它们在源码中出现的顺序, 第一个类
          型匹配成功的catch将被用来执行; 当调用虚函数时, 被选择的函数是与对
          象类型匹配最佳的类里, 即使该类不在源代码最前面;
