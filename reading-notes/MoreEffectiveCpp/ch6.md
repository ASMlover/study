# **效率**
***



## **16. 牢记80-20准则**
    1) 准则说的是大约20%的代码使用了80%的程序资源, 大约20%的代码耗用了大约
       80%的运行时间, 大约20%的代码使用了80%的内存, 大约20%的代码执行了80%
       的磁盘访问, 80%的维护投入与大约20%的代码上;



## **17. 考虑使用懒惰计算法(lazy evaluation)**
    1) 引用计数
        std::string就是这样的, 除非你确实需要, 不去为任何东西制作拷贝, 只要
        可能就共享使用其他值;
    2) 区别对待读取和写入
    3) 懒惰提取(lazy fetching)
    4) 懒惰表达式计算(Lazy expression evaluation)
    5) 懒惰计算的作用:
        * 能避免不需要的对象拷贝
        * 通过使用operator[]区分出读操作
        * 避免不需要的数据库读取操作
        * 避免不需要的数字操作


## **18. 分期摊还期望的计算**
    最简单的方法就是缓存那些已经被计算出来而以后还有可能需要的值;
    (对于使用(*it).second, 而不是it->second, 这是为了遵守STL规则, iterator是
     一个对象不是指针, 不保证->一定有效, 但是STL要求'.'和'*'是合法的);
    另一种方法是预提取(Prefetching);



## **19. 理解临时对象的来源**
    1) 建立一个没有命名的非堆(non-heap)对象会产生临时对象;
        这种未命名对象产生的情况: 为了是函数成功钓鱼而进行隐式类型转换和函数
                                　返回对象时;
    2) 为使函数成功调用而建立临时对象:
        * 仅当通过传值方式传递或传递g常量引用参数时才会发生此类转换;
        * C++禁止为非常量引用产生临时对象;
    3) 函数返回对象时(会产生临时对象);
    4) 任何时候只要见到常量引用参数就存在建立临时对象而绑定在参数上的可能性,
       任何时候只要见到函数返回对象就会有一个临时对象被建立;


## **20. 协助完成返回值优化**
    1) 以某种方法返回对象, 能让编译器消除临时对象的开销, 这样编写函数通常是
       很普遍的; 这种技巧就是返回Constructor argument而不是直接返回对象;
       C++规则允许编译器优化不出现的临时对象;
       这就是命名返回值优化, 但是这种优化对普通的赋值运算无效, 编译器不能用
       拷贝构造函数取代赋值运算动作;



## **21. 通过重载避免隐式类型转换**
      const UPInt operator+(const UPInt& lhs, const UPInt& rhs);
      const UPInt operator+(const UPInt& lhs, int rhs);
      const UPInt operator+(int lhs, const UPInt& rhs);
      没必要实现大量的重载, 除非有理由确信程序使用重载函数以后其整体效率会有
      显著提高;



## **22. 考虑用运算符的赋值形式(op=)取代其单独形式(op)**
    1) 确保operator的赋值形式与一个operator的单独形式之间存在正常的关系, 一
       个好方法就是让后者根据前者来实现;
    2) * operator的赋值形式比其单独形式效率更高, 因为单独形式要返回一个新对
         象, 从而在临时对象的构造和释放上有一些开销; operator的赋值形式把结
         果写在左边的参数里, 因此不需要生成临时对象来容纳operator的返回值;
       * 提供operator赋值形式的同时也要提供其标准形式, 允许类的客户端在便利
         与效率上做出折中选择;
       * operator单独形式的实现应该如下:
          template <typename T>
          const T operator+(const T& lhs, const T& rhs) {
            return T(lhs) + rhs;
          }
          不会产生临时变量, 会使用返回值优化;
    3) 未命名对象在历史上比命名对象更容易清除, 因此当我们面对在命名对象和临
       时对象之间选择的时候, 用临时对象会更好一些;
