# **文件IO**
***



## **1.文件描述符**
    文件描述符都是正数;
    0 -> 进程标准输入, STDIN_FILENO
    1 -> 进程标准输出, STDOUT_FILENO
    2 -> 进程标准错误输出, STDERR_FILENO
    文件描述符的变化范围是0 ~ OPEN_MAX(16)



## **2. open函数**
    打开或创建文件(成功返回文件描述符, 失败返回-1)
        #include <fcntl.h>
        int open(const char* path, int oflag, .../* mode_t mode*/);
    oflag参数取值:
      * O_RDONLY  只读打开
      * O_WRONLY  只写打开
      * O_RDWR    读写打开
      O_RDONLY, O_WRONLY, O_RDWR参数必须指定且只能指定一个;
    oflag的可选参数:
      * O_APPEND  每次写都追加到文件尾
      * O_CREAT   文件不存在, 则创建; 使用O_CREAT需要mode参数, 表示访问权限
      * O_EXCL    如文件已存在, 则出错; 可测试一个文件是否存在, 不存在则创建
      * O_TRUNC   文件存在, 且为只写或读写方式打开, 长度截断为0
      * O_NOCTTY  如path是终端设备, 则不讲该设备分配作为次进程的控制终端
      * O_NONBLOCK  文件本次打开和后续IO操作为非阻塞模式
      * O_DSYNC   每次write等待物理IO操作完成, 如写不影响刚才写如的数据, 则
                  不等待文件属性被修改
      * O_RSYNC   每一个一文件描述符为参数的read等待, 直到任何对文件同一部分
                  进行的未决写操作都完成
      * O_SYNC    每次write都等到物理IO操作完成;


## **3. creat函数**
    创建一个新文件(成功返回文件描述符, 失败返回-1)
        #include <fcntl.h>
        int creat(const char* pathname, mode_t mode);
    此函数等效于open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);
    此函数的不足是以只写方式创建文件;



## **4. close函数**
    关闭一个打开的文件(成功返回0, 失败返回-1)
        #include <unistd.h>
        int close(int filedes);



## **5. lseek函数**
    通常读写操作都是从当前文件偏移处开始并使偏移量增加所读写的字节数;
    显式的为一个打开的文件设置偏移量(成功返回新的偏移量, 出错返回-1)
        #include <unistd.h>
        off_t lseek(int filedes, off_t offset, int where);
    where的取值:
    * SEEK_SET  该文件的偏移量设置为距文件开始处offset字节
    * SEEK_CUR  文件偏移量为当前值加offset, offset可正可负
    * SEEK_END  文件偏移量为文件长度加offset, offset可正可负

    注意: 如果文件描述符是管道, FIFO或套接字, 返回-1, errno设置为ESPIPE

    文件偏移量可大于当前长度, 这样对该文件的写一次写将加长文件, 形成空洞; 空
    洞中的字节都被读为0;



## **6. read函数**
