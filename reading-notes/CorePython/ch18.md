# **多线程编程**
***


## **1. 线程和全局解释器锁**
> ### **1.1 全局解释器锁(GIL)**
    对Python虚拟机的访问由全局解释器锁(global interpreter lock, GIL)来控制,
    它保证了同一时刻只有一个线程在运行;
    1) 多线程环境, 虚拟机执行方式:
        * 设置GIL;
        * 切换到一个线程去运行;
        * 运行
          - 指定数量的字节码的指令, 或者
          - 线程主动让出控制(可以调用time.sleep(0))
        * 把线程设置为睡眠状态;
        * 解锁GIL;
        * 再次重复以上所有步骤;
        调用外部代码(C/C++扩展函数)的时候, GIL将会被锁定, 直到这个函数结束为
        止;
> ### **1.2 退出线程**
    线程可以调用thread.exit()退出函数, 也可以使用Python退出进程的标准方法,
    sys.exit()或抛出一个SystemExit异常; 不可以直接kill一个线程;
> ### **1.3  Python中的threading模块**
    1) 避免使用thread模块
        * 更高级的threading模块更先进, 对线程支持更完善, thread中的属性可能
          会与threading冲突;
        * 低级别的thread模块的同步原语很少, threading则很多;




## **2. thread模块**
    1) thread模块和所对象
        模块函数
        * start_new_thread(function,args[,kwargs=None])
          产生一个新线程, 在新线程中用指定的参数和可选kwargs来调用这个函数;
        * allocate_lock()     分配一个LockType类型的锁对象
        * exit()              让线程退出
        LockType类型锁对象方法
        * acquire(wait=None)  尝试获取锁对象
        * locked()            如获取了锁对象返回True, 否则返回False
        * release()           释放锁
    2) Demo
        ./src/ms_sleep.py 
        ./src/ms_sleep2.py
