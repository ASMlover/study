# **错误和异常**
***



## **1. 异常**
    * 是因为程序出现了错误而在正常控制流以外采取的行为;
    * 异常分两个阶段:
      1) 引起异常发生的错误
      2) 检测(和采取可能的措施)阶段



## **2. Python中的异常**
 * NameError: 尝试访问一个未申明的变量
 * ZeroDivisionError: 除数为零
 * SyntaxError: Python解释器语法错误
 * IndexError: 请求的索引超出序列范围
 * KeyError: 请求一个不存在的字典关键字
 * IOError: 输入/输出错误
 * AttributeError: 尝试访问未知的对象属性




## **3. 检测和处理异常**
    可以通过try语句来检测, 任何在try语句块里的代码都会被检测, 检查有无异常
    发生;
    try有两种形式:
      * try-except
      * try-finally
      这个两个语句互斥, 一个try可以对应多个except;一个try只能对应一个finally
      可以使用复合语句try-except-finally 
    1) try-except语句 
        try:
          try_suite                       # 监控这里的异常
        except Exception1[, reason1]:
          suite_for_exception_Exception1  # 异常处理代码
        except Exception2[, reason2]:
          suite_for_exception_Exception2  # 异常处理代码
                .
                .
                .
    2) 处理多个异常的except语句
        可以在一个except子句里处理多个异常, except语句在处理多个异常时需要异
        常被放在一个元组里面:
          except (Exception1, Exception2[, ...ExceptionN])[, reason]:
            suite_for_Exception1_to_ExceptionN
    3) 捕获所有异常:
        try:
          ...
        except Exception, e:
          ...
    4) 有些异常不是由于错误条件引起的, 他们是SystemExit和KeyboardInterrupt, 
       SystemExit是由于当前的程序需要推出, KeyboardInterrupt代表用户按下了
       CTRL-C(^C)想要关闭Python;
        try:
          ...
        except (KeyboardInterrupt, SystemExit):
          # user wants to quit
          # reraise back to caller
          raise
        except Exception:
          # handle real errors
    5) else子句
        在try范围中没有异常被检测到时, 执行else子句, 在else范围中的任何代码
        运行前, try范围中的所有代码必须完全成功;
    6) finally子句 
        finally子句是无论异常是否发生, 是否捕捉都会执行的一段代码;
    7) try-except-else-finally
        try:
          try_suite
        except Exception1:
          suite_for_Exception1 
        except (Exception2, Exception3, Exception4):
          suite_for_Exception_2_3_and_4
        except Exception5, Argument5:
          suite_for_Exception5_plus_argument
        except (Exception6, Exception7), Argument67:
          suite_for_Exception6_and_7_plus_argument
        except:
          suite_for_all_other_exceptions
        else:
          no_exceptions_detected_suite
        finally:
          always_execute_suite




## **4. 上下文管理**
> ### **4.1 with语句**
    with语法的基本用法如下:
      with context_expr [as var]:
        with_suite
    只有内建了"上下文管理"的对象可以和with一起使用;
    支持的对象如下:
      * file
      * decimal.Context 
      * thread.LockType
      * threading.Lock 
      * threading.RLock
      * threading.Condition
      * threading.Semaphore
      * threading.BoundedSemaphore
    Demo:
      with open('/etc/passwd', 'w') as f:
        for eachLine in f:
          # ... do stuff with eachLine or f ...
> ### **4.2 *上下文管理协议**
    1) 上下文表达式(context_expr), 上下文管理器
        上下文管理器需要提供一个上下文对象, 通过调用__context__()来实现;
    2) 上下文对象, with语句块 
        一旦获得上下文对象, 就会调用它的__enter__()方法; 它将完成with语句块
        执行前的所有准备工作;
        当with语句块执行结束, 无论是"和谐地"还是由于异常, 都会调用上下文对象
        的__exit__()方法, __exit__()有3个参数;
        如果with语句块正常结束, 3个参数其全部时None, 如果发生异常, 3个参数的
        值分别等于调用sys.exc_info()函数返回的3个值: 类型(异常),值(异常实例)
        和跟踪记录(traceback)
