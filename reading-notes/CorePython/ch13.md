# **面向对象编程**
***



## **1. 类与实例**
        class MyNewObjectType(bases):
          class_suite

        class MyNewObjectType:
          class_suite
    1) 创建一个实例的过程是实例化:
          myFirstObject = MyNewObjectType()
        可以创建一个空类, 对空类的实例对象添加动态属性, 新加的属性不属于类, 
        是实例的独有属性;
    2) 类的方法都有一个self参数, 代表实例对象本身, 由解释器传递给方法, 不需
       子集传递
       类的__init__()方法类似于类构造器, 会在实例化过程中调用__init__()方法;



## **2. 类属性**
    1) 数据属性
        是所定义的类的变量, 可像任何其他变量一样在类创建后被使用, 要么由类中
        的方法来更新, 要么在主程序其他地方被更新;
        也就是类的静态数据;
            class C(object):
              foo = 100
            print C.foo 
    2) 没有实例, 类的方法是不能被调用的; 方法必须绑定到一个实例才能调用;
    3) 通过dir()内建函数和访问类的字典属性__dict__来获知类有哪些属性;
    4) 特殊类属性
        * C.__name__    类的名字
        * C.__doc__     类的文档字符串
        * C.__bases__   类的所有父类构成的元组
        * C.__dict__    类的属性
        * C.__module__  类定义所在的模块
        * C.__class__   实例对应的类



## **3. 实例**
    1) __init__()构造器方法
        创建实例对象 -> 检查是否实现__init__() -> 没实现 -> 实例化完毕
                                               |
                                               -> 实现 -> 调用__init__()
    2) __new__()构造器方法
        可对内建类型进行派生, 需要一种途径来实例化不可变对象;
        调用类的__new__()方法, 一个静态方法;
        __new__()会调用父类的__new__()来创建对象;
        __new__()必须返回一个合法的实例;
    3) __del__()解构器方法
        一个特殊的destructor方法__del__()
        * 不要忘记首先调用父类的__del__()
        * 调用del x不表示调用x.__del__(), 仅减少x的引用计数
        * 如果你有一个循环引用或其他的原因, 让一个实例的引用逗留下去, 该对象
          的__del__()可能永远不会被执行
        * __del__()未捕获的异常会被忽略, 不要在__del__()中干和实例无关的事
        * 除非你知道你正在干什么, 否则不要区实现__del__()
        * 如果你定义了__del__, 且实例时某个循环的一部分, 垃圾回收器不会终止
          这个循环————需要自己显式调用del
    4) 特殊实例属性
        * I.__class__   实例化I的类
        * I.__dict__    I的属性



## **4. 静态方法和类方法**
> ### **4.1 staticmethod()和classmethod()内建函数**
        class TestStaticMethod:
          def foo():
            pass
            foo = staticmethod(foo)
        class TestClassMethod:
          def foo(cls):
            pass
          foo = classmethod(foo)
    如果没有调用这两个函数, 二者都会在Python编译器中产生错误, 显式需要带self
    的常规方法声明;
    可以通过类或者实例调用这些函数;


## **5. 继承**
    1) __bases__类属性
        是一个包含其父类的集合的元组
    2) 重写__init__不会自动调用基类的__init__
    3) 从标准类型派生
        * 不可变类型
          class RoundFloat(float):
            def __new__(cls, val):
              return float.__new__(cls, round(val, 2))
          所有的__new__()方法都是类方法;
          最好是使用super内建函数去捕获对应的父类以调用它的__new__()方法 
          class RoundFloat(float):
            def __new__(cls, val):
              return super(RoundFloat, cls).__new__(cls, round(val, 2))
        * 可变类型
          不需要使用__new__()(甚至__init__())
          class SortedKeyDict(dict):
            def keys(self):
              return sorted(super(SortedKeyDict, self).keys())
