# **面向对象编程**
***



## **1. 类与实例**
        class MyNewObjectType(bases):
          class_suite

        class MyNewObjectType:
          class_suite
    1) 创建一个实例的过程是实例化:
          myFirstObject = MyNewObjectType()
        可以创建一个空类, 对空类的实例对象添加动态属性, 新加的属性不属于类, 
        是实例的独有属性;
    2) 类的方法都有一个self参数, 代表实例对象本身, 由解释器传递给方法, 不需
       子集传递
       类的__init__()方法类似于类构造器, 会在实例化过程中调用__init__()方法;



## **2. 类属性**
    1) 数据属性
        是所定义的类的变量, 可像任何其他变量一样在类创建后被使用, 要么由类中
        的方法来更新, 要么在主程序其他地方被更新;
        也就是类的静态数据;
            class C(object):
              foo = 100
            print C.foo 
    2) 没有实例, 类的方法是不能被调用的; 方法必须绑定到一个实例才能调用;
    3) 通过dir()内建函数和访问类的字典属性__dict__来获知类有哪些属性;
    4) 特殊类属性
        * C.__name__    类的名字
        * C.__doc__     类的文档字符串
        * C.__bases__   类的所有父类构成的元组
        * C.__dict__    类的属性
        * C.__module__  类定义所在的模块
        * C.__class__   实例对应的类



## **3. 实例**
    1) __init__()构造器方法
        创建实例对象 -> 检查是否实现__init__() -> 没实现 -> 实例化完毕
                                               |
                                               -> 实现 -> 调用__init__()
    2) __new__()构造器方法
        可对内建类型进行派生, 需要一种途径来实例化不可变对象;
        调用类的__new__()方法, 一个静态方法;
        __new__()会调用父类的__new__()来创建对象;
        __new__()必须返回一个合法的实例;
    3) __del__()解构器方法
        一个特殊的destructor方法__del__()
        * 不要忘记首先调用父类的__del__()
        * 调用del x不表示调用x.__del__(), 仅减少x的引用计数
        * 如果你有一个循环引用或其他的原因, 让一个实例的引用逗留下去, 该对象
          的__del__()可能永远不会被执行
        * __del__()未捕获的异常会被忽略, 不要在__del__()中干和实例无关的事
        * 除非你知道你正在干什么, 否则不要区实现__del__()
        * 如果你定义了__del__, 且实例时某个循环的一部分, 垃圾回收器不会终止
          这个循环————需要自己显式调用del

