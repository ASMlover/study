# **PyDictObject**
***

原则上关联容器的设计总会关注索引效率，实现会基于设计良好的数据结构，与C++中的map类似，map是基于RBTree实现的，RBTree是一种平衡二叉树，搜索效率为O(log2N)；python中的dict由于需要在实现中被大量使用所以对搜索效率要求很苛刻（比如会通过PyDictObject建立执行python字节码的运行环境，存放变量名和变量值的元素对），因此采用了hash table，理论上的最优情况能提供O(1)的搜索效率；最新的C++中如`unordered_map`

## **1、散列表**
研究表明散列表的装载率（已用空间和总空间的比值）超过2/3的时候，冲突的概率的就会大大增加；

解决冲突的方法很多，SGI STL使用的开链法；Python中使用的开放定址法，当发生冲突的时候通过一个二次探测函数f，计算下一个候选位置addr，如果可用则将待插入元素放到addr，如果不可用则继续使用探测函数f直到找到一个可用的位置为止；

但是多次使用探测函数从一个位置达到多个位置，这就形成来“冲突探测链”；当需要删除位于探测链中间的元素的时候，如果直接删除就永远不能到达位于探测链尾部的元素；所以使用开发定址的冲突解决方案的散列表，删除某条探测链上的元素时不能真正的删除而要进行一种“假删除”的操作；
