# **制作计算器** #
***


## **1. yacc/lex是什么** ##
    1) 词法分析: 将源代码分割成若干记号(token)的处理
    2) 语法分析: 从token构建分析树(parse tree)的处理
    3) 语义分析: 检查程序中是否含有语法正确但是存在逻辑问题的错误
    4) 生成代码: 如果是C这样生成机器码的编译器或Java这样生成字节码的编译器, 
                 在分析树构建完成之后进入代码生成阶段
        执行词法分析的程序为词法分析器 => lex
        执行语法分析的程序为解析器 => yacc


## **2. 做一个计算器** ##
> ### **2.1 lex** ###
    1) %%之前为定义区块
    2) %{ %}包裹的部分是想让词法分析器将这部分代码原样输出
    3) %{ %}之间需要定义yywarp函数, 如果没有这个函数就需要手动链接lex库文件
    4) %% %%包裹的部分为规则区块;
       规则区块的书写方式为: 一个正则表达式后面紧跟若干个空格, 后面接C代码;
       如果输入的字符串匹配正则表达式, 则执行后面的C代码(即动作)
    5) 记号的原始字符会在相应动作中被称为yytext的全局变量中, 动作解析出的值
       会存放在yylval的全局变量中
    6) 在规则区块之后的代码被称为用户代码区块, 可以编写任意C代码, 不需要使用
       %{ %}包裹 
> ### **2.2 正则表达式** ###
    1) []表示匹配此范围内的任意字符, 支持连接符
    2) []之后的*代表匹配前面的字符0次或多次
    3) | 表示或的意思
    4) 加上圆括号()是将这部分作为一个集合才能通过|与0并列
    5) + 表示匹配前面的字符1次或多次
    6) . 会匹配任意一个字符
    7) 常用元字符
        *       匹配0个或多个前面的字符
        +       匹配1个或多个前面的字符
        .       匹配任意一个字符
        [abc]   匹配a或b或c
        [a-c]   匹配a~c的字符
        [^a-c]  匹配a~c以外的字符
        ""      被包裹的字符不会被作为元字符, 而是匹配其字面含义
        \       转义后面的字符
> ### **2.3 yacc** ###
    1) a
        : b c 
        | d
        ;
        即a的定义是b与c的组合或着是d
    2) 其他详细使用请参见yacc文档或则书籍
