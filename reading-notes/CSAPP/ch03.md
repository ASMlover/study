# **程序的机器级表示**
***



## **1. 数据格式**
    1) gcc汇编指令都有一个字符后缀, 表明操作数大小; 数据传送指令有3个变种:
       movb(传送字节), movw(传送字), movl(传送双字);



## **2. 访问信息**
    1) 一个IA32的CPU包含一组8个存储32位值的寄存器; 这些寄存器用来存储整数数
       据和指针;
    2) eax, ecx, edx, ebx, esi, edi是通用寄存器, 对它们的使用没有限制;
    3) esp, ebp保存指向程序栈中重要位置的指针;
    4) 大多数指令有一个或多个操作数, 指示出执行一个操作中要引用的源数据值, 
       以及放置结果的目标位置;
    5) 操作数可以分为:
        * 立即数, 常数值;
        * 寄存器, 表示某个寄存器的内容; 对双字操作来说是8个32位寄存器中的一 
          个; 对单字操作来说可以是8个16位寄存器中的一个; 对字节来说可以是8个
          单字节寄存器元素中的一个(%al, %ah);
        * 存储器引用, 会根据计算出来的地址访问某个存储器的位置;
    6) mov类传送指令
        * mov s, d  -> (d<-s)
          movb -> 传送字节
          movw -> 传送字节
          movl -> 传送双字
        * movs s, d -> (d<-扩展符号s)
          movsbw -> 将做了符号扩展的字节传入到字
          movsbl -> 将做了符号扩展的字节传入双字
          movswl -> 将做了符号扩展的字传入到双字
        * movz s, d -> (d<-零扩展s)
          movzbw -> 将做了零扩展的字节传送到字
          movzbl -> 将做了零扩展的字节传送到双字
          movzwl -> 将做了零扩展的字传送到双字
          pushl -> 将双字压栈
          popl -> 将双字出栈
    7) pushl %ebp相当于:
          subl $4, %esp
          movl %ebp, (%esp)
       popl %eax相当于:
          movl (%esp), %eax
          addl $4, %esp



## **3. 算术和逻辑操作**
    1) 给出的每个指令类都有对字节, 字和双字数据进行操作的指令; 这些操作被分
       为4组: 加载有效地址, 一元操作, 二元操作和位移;
    2) 加载有效地址leal(load effective address)从存储器读数据到寄存器, 但没
       有引用存储器;
        leal s, d (d<-&s)
    3) 一元操作只有一个操作数, 即是源又是目的; 可以是一个寄存器也可以是一个
       存储器位置;
    4) 二元操作中第二个操作数既是源有时目的; 源操作数是第一个, 目的操作数是
       第二个;
    5) 位移操作, 第一个操作数是位移量, 第二个操作数是要位移的位数; 可以是算
       术位移也可以是逻辑位移;
    6) 特殊算术操作:
        imull S => R[%edx]:R[%eax] <- S*R[%eax] => 有符号全64位乘法
        mull S => R[%edx]:R[%eax] <- S*R[%eax] => 无符号全64位乘法
        cltd => R[%edx]:R[%eax] <- SignExtend(R[%eax]) => 转为4字
        idivl S => R[%edx] <- R[%edx]:R[%eax] mod S;
                   R[%eax] <- R[%edx]:R[%eax] / S => 有符号除法
        divl S => R[%edx] <- R[%edx]:R[%eax] mod S;
                  R[%eax] <- R[%edx]:R[%eax] / S => 无符号除法



## **4. 控制**
    1) 条件码寄存器, 它们描述了最近的算术或逻辑操作的属性; 可以检测这些寄存
       器来执行条件分支指令;
        * CF -> 进位标志;
        * ZF -> 零标志;
        * SF -> 符号标志;
        * OF -> 溢出标志;
    2) 比较和测试指令:
        CMP S2, S1        S1 - S2
        cmpb              Compare byte
        cmpw              Compare word
        cmpl              Compare double word
        TEST S2, S1       S1 & S2
        testb             Test byte
        testw             Test word
        testl             Test double word
    3) 访问条件码
        不会直接读取, 常用的使用方法有3种:
          * 可以根据条件码的某个组合, 将一个字节设置为0或1;
          * 可以条件跳转到程序的某个其他的部分;
          * 可以有条件地传送数据;
    4) SET指令:
        sete D    => D <- ZF                => 相等/零
        setne D   => D <- ~ZF               => 不等/非零
        sets D    => D <- SF                => 负数
        setns D   => D <- ~SF               => 非负数
        setg D    => D <- ~(SF ^ OF) & ~ZF  => 大于(有符号>)
        setge D   => D <- ~(SF ^ OF)        => 大于等于(有符号>=)
        setl D    => D <- SF ^ OF           => 小于(有符号<)
        setle D   => D <- (SF ^ OF) | ZF    => 小于等于(有符号<=)
        seta D    => D <- ~CF & ~ZF         => 超过(无符号>)
        setae D   => D <- ~CF               => 超过或相等(无符号>=)
        setb D    => D <- CF                => 低于(无符号<)
        setbe D   => D <- CF | ZF           => 低于或相等(无符号<=)
    5) 跳转指令会导致执行切换到程序中一个全新的位置; jmp是无条件跳转;
    6) jump指令:
        jmp Label     => 1                  => 直接跳转
        jmp *Operand  => 1                  => 间接跳转
        je  Label     => ZF                 => 相等/零
        jne Label     => ~ZF                => 不想等/非零
        js  Label     => SF                 => 负数
        jns Label     => ~SF                => 非负数
        jg  Label     => ~(SF ^ OF) & ~ZF   => 大于(有符号>)
        jge Label     => ~(SF ^ OF)         => 大于或等于(有符号>=)
        jl  Label     => SF ^ OF            => 小于(有符号<=)
        jle Label     => (SF ^ OF) | ZF     => 小于或等于(有符号<=)
        ja  Label     => ~CF & ~ZF          => 超过(无符号>)
        jae Label     => ~CF                => 超过或相等(无符号>=)
        jb  Label     => CF                 => 低于(无符号<)
        jbe Label     => CF | ZF            => 低于或相等(无符号<=)
    7) %eax被用来返回函数的值, 所以常常选择它存放要返回的程序值;
    8) 循环
       转换成汇编码的策略是将while和for转换成do while模式;
    9) 条件传送指令(达到条件S值复制到R)
        cmove S, R    => ZF                 => 相等/零
        cmovne S, R   => ~ZF                => 不想等/非零
        cmovs S, R    => SF                 => 负数
        cmovns S, R   => ~SF                => 非负数
        cmovg S, R    => ~(SF ^ OF) & ~ZF   => 大于(有符号>)
        cmovge S, R   => ~(SF ^ OF)         => 大于等于(有符号>=)
        cmovl S, R    => SF ^ OF            => 小于(有符号<)
        cmovle S, R   => (SF ^ OF) | ZF     => 小于等于(有符号<=)
        cmova S, R    => ~CF & ~ZF          => 超过(无符号>)
        cmovae S, R   => ~CF                => 超过或相等(无符号>=)
        cmovb S, R    => CF                 => 低于(无符号<)
        cmovbe S, R   => CF | ZF            => 低于或相等(无符号<=)
    10) switch语句通过使用跳转表数据结构使得实现更加高效; GCC根据开关情况的
        数量和开关情况值的稀少程度来翻译开关语句, 当开关情况数量比较多并且值
        的范围跨度比较小时就会使用跳转表;


## **5. 过程**
    过程调用包括将数据和控制从代码的一部分传递到另一部分; 还必须在进入时为过
    程的局部变量分配空间, 并在退出的时候释放这些空间;
> ### **5.1 栈帧结构**
    结构如图./pic/stack_frame.png
    1) 使用栈来传递过程参数, 存储返回信息, 保存寄存器用于以后恢复, 以及本地
       存储; 
       为单个过程分配的那部分栈称为栈帧; %ebp是帧指针, %esp是栈指针; 程序运
       行的时候, 栈指针可以移动, 因此大多数信息的访问都是相对于帧指针的;
    2) 在被调用的过程中, 第一个参数放在相对于%ebp偏移量为8的位置处, 剩下的参
       数存储在后续的4字节块中, 所以参数i就在相对于%ebp偏移量为4+4i的地方; 
       较大的参数需要栈上更大的区域;

> ### **5.2 转移控制**
    1) 调用和返回指令
        * call Label    => 过程调用
        * call *Operand => 过程调用
        * leave         => 为返回准备栈
        * ret           => 从过程调用中返回
    2) call的目标是指明被调用过程起始的指令地址, 其效果是将返回地址入栈, 并
       跳转到被调用过程的起始地址, 返回地址是在程序中紧跟在call后面的那条指
       令的地址;
       ret指令从栈中弹出地址, 并跳转到call后面的那个位置;
