# **程序的机器级表示**
***



## **1. 数据格式**
    1) gcc汇编指令都有一个字符后缀, 表明操作数大小; 数据传送指令有3个变种:
       movb(传送字节), movw(传送字), movl(传送双字);



## **2. 访问信息**
    1) 一个IA32的CPU包含一组8个存储32位值的寄存器; 这些寄存器用来存储整数数
       据和指针;
    2) eax, ecx, edx, ebx, esi, edi是通用寄存器, 对它们的使用没有限制;
    3) esp, ebp保存指向程序栈中重要位置的指针;
    4) 大多数指令有一个或多个操作数, 指示出执行一个操作中要引用的源数据值, 
       以及放置结果的目标位置;
    5) 操作数可以分为:
        * 立即数, 常数值;
        * 寄存器, 表示某个寄存器的内容; 对双字操作来说是8个32位寄存器中的一 
          个; 对单字操作来说可以是8个16位寄存器中的一个; 对字节来说可以是8个
          单字节寄存器元素中的一个(%al, %ah);
        * 存储器引用, 会根据计算出来的地址访问某个存储器的位置;
    6) mov类传送指令
        * mov s, d  -> (d<-s)
          movb -> 传送字节
          movw -> 传送字节
          movl -> 传送双字
        * movs s, d -> (d<-扩展符号s)
          movsbw -> 将做了符号扩展的字节传入到字
          movsbl -> 将做了符号扩展的字节传入双字
          movswl -> 将做了符号扩展的字传入到双字
        * movz s, d -> (d<-零扩展s)
          movzbw -> 将做了零扩展的字节传送到字
          movzbl -> 将做了零扩展的字节传送到双字
          movzwl -> 将做了零扩展的字传送到双字
          pushl -> 将双字压栈
          popl -> 将双字出栈
    7) pushl %ebp相当于:
          subl $4, %esp
          movl %ebp, (%esp)
       popl %eax相当于:
          movl (%esp), %eax
          addl $4, %esp



## **3. 算术和逻辑操作**
    1) 给出的每个指令类都有对字节, 字和双字数据进行操作的指令; 这些操作被分
       为4组: 加载有效地址, 一元操作, 二元操作和位移;
    2) 加载有效地址leal(load effective address)从存储器读数据到寄存器, 但没
       有引用存储器;
        leal s, d (d<-&s)
    3) 一元操作只有一个操作数, 即是源又是目的; 可以是一个寄存器也可以是一个
       存储器位置;
    4) 二元操作中第二个操作数既是源有时目的; 源操作数是第一个, 目的操作数是
       第二个;
    5) 位移操作, 第一个操作数是位移量, 第二个操作数是要位移的位数; 可以是算
       术位移也可以是逻辑位移;
    6) 特殊算术操作:
        imull S => R[%edx]:R[%eax] <- S*R[%eax] => 有符号全64位乘法
        mull S => R[%edx]:R[%eax] <- S*R[%eax] => 无符号全64位乘法
        cltd => R[%edx]:R[%eax] <- SignExtend(R[%eax]) => 转为4字
        idivl S => R[%edx] <- R[%edx]:R[%eax] mod S;
                   R[%eax] <- R[%edx]:R[%eax] / S => 有符号除法
        divl S => R[%edx] <- R[%edx]:R[%eax] mod S;
                  R[%eax] <- R[%edx]:R[%eax] / S => 无符号除法



## **4. 控制**
    1) 条件码寄存器, 它们描述了最近的算术或逻辑操作的属性; 可以检测这些寄存
       器来执行条件分支指令;
        * CF -> 进位标志;
        * ZF -> 零标志;
        * SF -> 符号标志;
        * OF -> 溢出标志;
    2) 比较和测试指令:
        CMP S2, S1        S1 - S2
        cmpb              Compare byte
        cmpw              Compare word
        cmpl              Compare double word
        TEST S2, S1       S1 & S2
        testb             Test byte
        testw             Test word
        testl             Test double word
    3) 访问条件码
        不会直接读取, 常用的使用方法有3种:
          * 可以根据条件码的某个组合, 将一个字节设置为0或1;
          * 可以条件跳转到程序的某个其他的部分;
          * 可以有条件地传送数据;
    4) SET指令:
        sete D    => D <- ZF                => 相等/零
        setne D   => D <- ~ZF               => 不等/非零
        sets D    => D <- SF                => 负数
        setns D   => D <- ~SF               => 非负数
        setg D    => D <- ~(SF ^ OF) & ~ZF  => 大于(有符号>)
        setge D   => D <- ~(SF ^ OF)        => 大于等于(有符号>=)
        setl D    => D <- SF ^ OF           => 小于(有符号<)
        setle D   => D <- (SF ^ OF) | ZF    => 小于等于(有符号<=)
        seta D    => D <- ~CF & ~ZF         => 超过(无符号>)
        setae D   => D <- ~CF               => 超过或相等(无符号>=)
        setb D    => D <- CF                => 低于(无符号<)
        setbe D   => D <- CF | ZF           => 低于或相等(无符号<=)
    5) 跳转指令会导致执行切换到程序中一个全新的位置; jmp是无条件跳转;
    6) jump指令:
        jmp Label     => 1                  => 直接跳转
        jmp *Operand  => 1                  => 间接跳转
        je  Label     => ZF                 => 相等/零
        jne Label     => ~ZF                => 不想等/非零
        js  Label     => SF                 => 负数
        jns Label     => ~SF                => 非负数
        jg  Label     => ~(SF ^ OF) & ~ZF   => 大于(有符号>)
        jge Label     => ~(SF ^ OF)         => 大于或等于(有符号>=)
        jl  Label     => SF ^ OF            => 小于(有符号<=)
        jle Label     => (SF ^ OF) | ZF     => 小于或等于(有符号<=)
        ja  Label     => ~CF & ~ZF          => 超过(无符号>)
        jae Label     => ~CF                => 超过或相等(无符号>=)
        jb  Label     => CF                 => 低于(无符号<)
        jbe Label     => CF | ZF            => 低于或相等(无符号<=)
