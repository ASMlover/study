# **程序的机器级表示**
***



## **1. 数据格式**
    1) gcc汇编指令都有一个字符后缀, 表明操作数大小; 数据传送指令有3个变种:
       movb(传送字节), movw(传送字), movl(传送双字);



## **2. 访问信息**
    1) 一个IA32的CPU包含一组8个存储32位值的寄存器; 这些寄存器用来存储整数数
       据和指针;
    2) eax, ecx, edx, ebx, esi, edi是通用寄存器, 对它们的使用没有限制;
    3) esp, ebp保存指向程序栈中重要位置的指针;
    4) 大多数指令有一个或多个操作数, 指示出执行一个操作中要引用的源数据值, 
       以及放置结果的目标位置;
    5) 操作数可以分为:
        * 立即数, 常数值;
        * 寄存器, 表示某个寄存器的内容; 对双字操作来说是8个32位寄存器中的一 
          个; 对单字操作来说可以是8个16位寄存器中的一个; 对字节来说可以是8个
          单字节寄存器元素中的一个(%al, %ah);
        * 存储器引用, 会根据计算出来的地址访问某个存储器的位置;
    6) mov类传送指令
        * mov s, d  -> (d<-s)
          movb -> 传送字节
          movw -> 传送字节
          movl -> 传送双字
        * movs s, d -> (d<-扩展符号s)
          movsbw -> 将做了符号扩展的字节传入到字
          movsbl -> 将做了符号扩展的字节传入双字
          movswl -> 将做了符号扩展的字传入到双字
        * movz s, d -> (d<-零扩展s)
          movzbw -> 将做了零扩展的字节传送到字
          movzbl -> 将做了零扩展的字节传送到双字
          movzwl -> 将做了零扩展的字传送到双字
          pushl -> 将双字压栈
          popl -> 将双字出栈
    7) pushl %ebp相当于:
          subl $4, %esp
          movl %ebp, (%esp)
       popl %eax相当于:
          movl (%esp), %eax
          addl $4, %esp



## **3. 算术和逻辑操作**
    1) 给出的每个指令类都有对字节, 字和双字数据进行操作的指令; 这些操作被分
       为4组: 加载有效地址, 一元操作, 二元操作和位移;
    2) 加载有效地址leal(load effective address)从存储器读数据到寄存器, 但没
       有引用存储器;
        leal s, d (d<-&s)
    3) 一元操作只有一个操作数, 即是源又是目的; 可以是一个寄存器也可以是一个
       存储器位置;
    4) 二元操作中第二个操作数既是源有时目的; 源操作数是第一个, 目的操作数是
       第二个;
    5) 位移操作, 第一个操作数是位移量, 第二个操作数是要位移的位数; 可以是算
       术位移也可以是逻辑位移;
    6) 特殊算术操作:
        imull S => R[%edx]:R[%eax] <- S*R[%eax] => 有符号全64位乘法
        mull S => R[%edx]:R[%eax] <- S*R[%eax] => 无符号全64位乘法
        cltd => R[%edx]:R[%eax] <- SignExtend(R[%eax]) => 转为4字
        idivl S => R[%edx] <- R[%edx]:R[%eax] mod S;
                   R[%eax] <- R[%edx]:R[%eax] / S => 有符号除法
        divl S => R[%edx] <- R[%edx]:R[%eax] mod S;
                  R[%eax] <- R[%edx]:R[%eax] / S => 无符号除法
