# **程序的机器级表示**
***



## **1. 数据格式**
    1) gcc汇编指令都有一个字符后缀, 表明操作数大小; 数据传送指令有3个变种:
       movb(传送字节), movw(传送字), movl(传送双字);



## **2. 访问信息**
    1) 一个IA32的CPU包含一组8个存储32位值的寄存器; 这些寄存器用来存储整数数
       据和指针;
    2) eax, ecx, edx, ebx, esi, edi是通用寄存器, 对它们的使用没有限制;
    3) esp, ebp保存指向程序栈中重要位置的指针;
    4) 大多数指令有一个或多个操作数, 指示出执行一个操作中要引用的源数据值, 
       以及放置结果的目标位置;
    5) 操作数可以分为:
        * 立即数, 常数值;
        * 寄存器, 表示某个寄存器的内容; 对双字操作来说是8个32位寄存器中的一 
          个; 对单字操作来说可以是8个16位寄存器中的一个; 对字节来说可以是8个
          单字节寄存器元素中的一个(%al, %ah);
        * 存储器引用, 会根据计算出来的地址访问某个存储器的位置;
    6) mov类传送指令
        * mov s, d  -> (d<-s)
          movb -> 传送字节
          movw -> 传送字节
          movl -> 传送双字
        * movs s, d -> (d<-扩展符号s)
          movsbw -> 将做了符号扩展的字节传入到字
          movsbl -> 将做了符号扩展的字节传入双字
          movswl -> 将做了符号扩展的字传入到双字
        * movz s, d -> (d<-零扩展s)
          movzbw -> 将做了零扩展的字节传送到字
          movzbl -> 将做了零扩展的字节传送到双字
          movzwl -> 将做了零扩展的字传送到双字
          pushl -> 将双字压栈
          popl -> 将双字出栈
    7) pushl %ebp相当于:
          subl $4, %esp
          movl %ebp, (%esp)
       popl %eax相当于:
          movl (%esp), %eax
          addl $4, %esp



## **3. 算术和逻辑操作**
    1) 给出的每个指令类都有对字节, 字和双字数据进行操作的指令; 这些操作被分
       为4组: 加载有效地址, 一元操作, 二元操作和位移;
    2) 加载有效地址leal(load effective address)从存储器读数据到寄存器, 但没
       有引用存储器;
        leal s, d (d<-&s)
    3) 一元操作只有一个操作数, 即是源又是目的; 可以是一个寄存器也可以是一个
       存储器位置;
    4) 二元操作中第二个操作数既是源有时目的; 源操作数是第一个, 目的操作数是
       第二个;
    5) 位移操作, 第一个操作数是位移量, 第二个操作数是要位移的位数; 可以是算
       术位移也可以是逻辑位移;
    6) 特殊算术操作:
        imull S => R[%edx]:R[%eax] <- S*R[%eax] => 有符号全64位乘法
        mull S => R[%edx]:R[%eax] <- S*R[%eax] => 无符号全64位乘法
        cltd => R[%edx]:R[%eax] <- SignExtend(R[%eax]) => 转为4字
        idivl S => R[%edx] <- R[%edx]:R[%eax] mod S;
                   R[%eax] <- R[%edx]:R[%eax] / S => 有符号除法
        divl S => R[%edx] <- R[%edx]:R[%eax] mod S;
                  R[%eax] <- R[%edx]:R[%eax] / S => 无符号除法



## **4. 控制**
    1) 条件码寄存器, 它们描述了最近的算术或逻辑操作的属性; 可以检测这些寄存
       器来执行条件分支指令;
        * CF -> 进位标志;
        * ZF -> 零标志;
        * SF -> 符号标志;
        * OF -> 溢出标志;
    2) 比较和测试指令:
        CMP S2, S1        S1 - S2
        cmpb              Compare byte
        cmpw              Compare word
        cmpl              Compare double word
        TEST S2, S1       S1 & S2
        testb             Test byte
        testw             Test word
        testl             Test double word
    3) 访问条件码
        不会直接读取, 常用的使用方法有3种:
          * 可以根据条件码的某个组合, 将一个字节设置为0或1;
          * 可以条件跳转到程序的某个其他的部分;
          * 可以有条件地传送数据;
    4) SET指令:
        sete D    => D <- ZF                => 相等/零
        setne D   => D <- ~ZF               => 不等/非零
        sets D    => D <- SF                => 负数
        setns D   => D <- ~SF               => 非负数
        setg D    => D <- ~(SF ^ OF) & ~ZF  => 大于(有符号>)
        setge D   => D <- ~(SF ^ OF)        => 大于等于(有符号>=)
        setl D    => D <- SF ^ OF           => 小于(有符号<)
        setle D   => D <- (SF ^ OF) | ZF    => 小于等于(有符号<=)
        seta D    => D <- ~CF & ~ZF         => 超过(无符号>)
        setae D   => D <- ~CF               => 超过或相等(无符号>=)
        setb D    => D <- CF                => 低于(无符号<)
        setbe D   => D <- CF | ZF           => 低于或相等(无符号<=)
    5) 跳转指令会导致执行切换到程序中一个全新的位置; jmp是无条件跳转;
    6) jump指令:
        jmp Label     => 1                  => 直接跳转
        jmp *Operand  => 1                  => 间接跳转
        je  Label     => ZF                 => 相等/零
        jne Label     => ~ZF                => 不想等/非零
        js  Label     => SF                 => 负数
        jns Label     => ~SF                => 非负数
        jg  Label     => ~(SF ^ OF) & ~ZF   => 大于(有符号>)
        jge Label     => ~(SF ^ OF)         => 大于或等于(有符号>=)
        jl  Label     => SF ^ OF            => 小于(有符号<=)
        jle Label     => (SF ^ OF) | ZF     => 小于或等于(有符号<=)
        ja  Label     => ~CF & ~ZF          => 超过(无符号>)
        jae Label     => ~CF                => 超过或相等(无符号>=)
        jb  Label     => CF                 => 低于(无符号<)
        jbe Label     => CF | ZF            => 低于或相等(无符号<=)
    7) %eax被用来返回函数的值, 所以常常选择它存放要返回的程序值;
    8) 循环
       转换成汇编码的策略是将while和for转换成do while模式;
    9) 条件传送指令(达到条件S值复制到R)
        cmove S, R    => ZF                 => 相等/零
        cmovne S, R   => ~ZF                => 不想等/非零
        cmovs S, R    => SF                 => 负数
        cmovns S, R   => ~SF                => 非负数
        cmovg S, R    => ~(SF ^ OF) & ~ZF   => 大于(有符号>)
        cmovge S, R   => ~(SF ^ OF)         => 大于等于(有符号>=)
        cmovl S, R    => SF ^ OF            => 小于(有符号<)
        cmovle S, R   => (SF ^ OF) | ZF     => 小于等于(有符号<=)
        cmova S, R    => ~CF & ~ZF          => 超过(无符号>)
        cmovae S, R   => ~CF                => 超过或相等(无符号>=)
        cmovb S, R    => CF                 => 低于(无符号<)
        cmovbe S, R   => CF | ZF            => 低于或相等(无符号<=)
    10) switch语句通过使用跳转表数据结构使得实现更加高效; GCC根据开关情况的
        数量和开关情况值的稀少程度来翻译开关语句, 当开关情况数量比较多并且值
        的范围跨度比较小时就会使用跳转表;


## **5. 过程**
    过程调用包括将数据和控制从代码的一部分传递到另一部分; 还必须在进入时为过
    程的局部变量分配空间, 并在退出的时候释放这些空间;
> ### **5.1 栈帧结构**
    结构如图./pic/stack_frame.png
    1) 使用栈来传递过程参数, 存储返回信息, 保存寄存器用于以后恢复, 以及本地
       存储; 
       为单个过程分配的那部分栈称为栈帧; %ebp是帧指针, %esp是栈指针; 程序运
       行的时候, 栈指针可以移动, 因此大多数信息的访问都是相对于帧指针的;
    2) 在被调用的过程中, 第一个参数放在相对于%ebp偏移量为8的位置处, 剩下的参
       数存储在后续的4字节块中, 所以参数i就在相对于%ebp偏移量为4+4i的地方; 
       较大的参数需要栈上更大的区域;

> ### **5.2 转移控制**
    1) 调用和返回指令
        * call Label    => 过程调用
        * call *Operand => 过程调用
        * leave         => 为返回准备栈
        * ret           => 从过程调用中返回
    2) call的目标是指明被调用过程起始的指令地址, 其效果是将返回地址入栈, 并
       跳转到被调用过程的起始地址, 返回地址是在程序中紧跟在call后面的那条指
       令的地址;
       ret指令从栈中弹出地址, 并跳转到call后面的那个位置;

> ### **5.3 寄存器使用惯例**
    假设P为调用者, Q为被调用者;
    1) 寄存器%eax, %edx和%ecx被划分为调用者保存寄存器, P调用Q时Q可以覆盖这些
       寄存器, 而不会破坏P所需要的数据; %ebx, %esi和%edi被划分为被调用者保存
       寄存器, Q必须在覆盖这些寄存器之前将它们保存到栈中, 并在返回前恢复它们
    2) 对以下代码中保存y的情况:
          int P(int x) {
            int y = x * x;
            int z = Q(y);
            return y + z;
          }
        * 可在调用Q之前, 将y保存在自己的栈帧中; Q返回时, P从栈中取出;
        * 可将y的值保存在被调用者的保存寄存器中;



## **6. 数组分配和访问**
> ### **6.1 基本原则**
    1) T A[N] 会在存储器中分配一个L(T类型的大小) * N的连续空间; 并引入标示符
       A, 可以用A作为指向数组开头的指针;
    2) movl (%edx, %ecx, 4), %eax; 数组E的地址放在寄存器%edx中, i放在%ecx中,
       1, 2, 4, 8覆盖了所有基本简单数据类型的大小; 
       访问的是E[i], 执行Xe+4i来读这个存储器位置的值;

> ### **6.2 指针运算**
    1) 例子
        * E         => int*       => movl %edx, %eax
        * E[0]      => int        => movl (%edx), %eax
        * E[i]      => int        => movl (%edx, %ecx, 4), %eax
        * &E[2]     => int*       => leal 8(%edx), %eax
        * E+i-1     => int*       => leal -4(%edx, %ecx, 4), %eax
        * *(E+i-3)  => int*       => movl -12(%edx, %ecx, 4), %eax
        * &E[i]-E   => int        => movl %ecx, %eax
        leal指令用来产生地址, movl用来引用存储器;



## **7. 指针**
    * 每个指针都有一个值(某个指定类型对象的地址);
    * 指针用&运算符创建;
    * 操作符用于指针的间接引用;
    * 数组和指针紧密联系, p+i得到的是p+L*i, L是与p关联的数据类型的大小;
    * 指针也可以指向函数;



## **8. GDB命令**
> ### **8.1 开始和停止**
    $ quit                      => 退出GDB
    $ run                       => 运行程序(在此给出命令行参数)
    $ kill                      => 停止程序

> ### **8.2 断点**
    $ break sum                 => 在函数sum入口设置断点
    $ break *0x8048394          => 在地址0x8048394设置断点
    $ delete 1                  => 删除断点1 
    $ delete                    => 删除所有断点

> ### **8.3 执行**
    $ stepi                     => 执行一条指令
    $ stepi 4                   => 执行4条指令
    $ nexti                     => 类似stepi, 但是以函数调用为单位
    $ continue                  => 继续执行
    $ finish                    => 运行直到当前函数返回

> ### **8.4 检查代码**
    $ disas                     => 反汇编当前函数
    $ disas sum                 => 反汇编函数sum
    $ disas 0x8048397           => 反汇编位于地址0x8048397附近的函数
    $ disas 0x8048394 0x8048397 => 反汇编指定地址范围内的代码
    $ print /x $eip             => 以16进制输出程序计数器的值

> ### **8.5 检查数据**
    $ print $eax                => 以10进制输出%eax的内容
    $ print /x $eax             => 以16进制输出%eax的内容
    $ print /t $eax             => 以二进制输出%eax的内容
    $ print 0x100               => 输出0x100的十进制表示
    $ print /x 555              => 输出555的十六进制表示
    $ print /x ($ebp+8)         => 以十六进制输出%ebp的内容加上8
    $ print *(int*) 0xfff076b0  => 输出位于地址0xfff076b0的整数
    $ print *(inr*) $(ebp+8)    => 输出位于地址%ebp+8处的整数
    $ x/2w 0xfff076b0           => 检查从地址0xfff076b0开始的双(4字节)字
    $ x/20b sum                 => 检查函数sum前20个字节

> ### **8.6 有用的信息**
    $ info frame                => 有关当前栈帧的信息
    $ info registers            => 所有寄存器的值
    $ help                      => 获取有关GDB的信息
