# **系统级IO**
***


## **1. Unix IO**
    1) Unix IO是将设备优雅地映射为文件的方式, 允许Unix内核引出一个简单、低级
       的应用接口;
    2) 所有的输入输出都能以一种统一且一致的方式来执行:
        * 打开文件: 应用程序通过要求内核打开相应的文件来宣告它想要访问一个
          IO设备;
        * 改变当前的文件位置: 对于打开的文件, 内核保持着一个文件位置k; 可以
          通过执行seek操作来显示设置文件的当前位置k;
        * 读写文件
        * 关闭文件: 应用完成了对文件的访问之后就通知内核关闭这个文件;


## **2. 打开和关闭文件**
    1) 通过open来打开一个已存在的文件或创建一个新文件:
          #include <sys/types.h>
          #include <sys/stat.h>
          #include <fcntl.h>
          int open(char* filename, int flags, mode_t mode);
        * 将filename转换为一个文件描述符并返回描述符数字;
        * 返回的描述符总是在进程中当前没有打开的最小描述符;
        * flags -> O_RDONLY(只读), O_WRONLY(只写), O_RDWR(可读可写)
    2) 通过close函数关闭一个打开的文件:
          #include <unistd.h>
          int close(int fd);


## **3. 读和写文件**
    1) 通过read和write来执行输入和输出;
          #include <unistd.h>
          ssize_t read(int fd, void* buf, size_t n);
          ssize_t write(int fd, const void* buf, size_t n);
    2) read从描述符为fd的当前文件位置拷贝最多n个字节到存储器位置buf, 返回-1
       表示一个错误, 返回0表示EOF; 否则返回值表示的是实际传送的字节数量;
    3) write从存储器位置buf拷贝至多n个字节到描述符fd的当前文件位置;
    4) 读写出现传送的字节比应用程序要求的少, 出现的原因如下:
        * 读时遇到EOF;
        * 从终端读文本文件;
        * 读和写网络套接字;
