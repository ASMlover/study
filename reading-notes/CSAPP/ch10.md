# **系统级IO**
***


## **1. Unix IO**
    1) Unix IO是将设备优雅地映射为文件的方式, 允许Unix内核引出一个简单、低级
       的应用接口;
    2) 所有的输入输出都能以一种统一且一致的方式来执行:
        * 打开文件: 应用程序通过要求内核打开相应的文件来宣告它想要访问一个
          IO设备;
        * 改变当前的文件位置: 对于打开的文件, 内核保持着一个文件位置k; 可以
          通过执行seek操作来显示设置文件的当前位置k;
        * 读写文件
        * 关闭文件: 应用完成了对文件的访问之后就通知内核关闭这个文件;


## **2. 打开和关闭文件**
    1) 通过open来打开一个已存在的文件或创建一个新文件:
          #include <sys/types.h>
          #include <sys/stat.h>
          #include <fcntl.h>
          int open(char* filename, int flags, mode_t mode);
        * 将filename转换为一个文件描述符并返回描述符数字;
        * 返回的描述符总是在进程中当前没有打开的最小描述符;
        * flags -> O_RDONLY(只读), O_WRONLY(只写), O_RDWR(可读可写)
    2) 通过close函数关闭一个打开的文件:
          #include <unistd.h>
          int close(int fd);


## **3. 读和写文件**
    1) 通过read和write来执行输入和输出;
          #include <unistd.h>
          ssize_t read(int fd, void* buf, size_t n);
          ssize_t write(int fd, const void* buf, size_t n);
    2) read从描述符为fd的当前文件位置拷贝最多n个字节到存储器位置buf, 返回-1
       表示一个错误, 返回0表示EOF; 否则返回值表示的是实际传送的字节数量;
    3) write从存储器位置buf拷贝至多n个字节到描述符fd的当前文件位置;
    4) 读写出现传送的字节比应用程序要求的少, 出现的原因如下:
        * 读时遇到EOF;
        * 从终端读文本文件;
        * 读和写网络套接字;


## **4. 用RIO包健壮地读写**
    1) 包括两种函数:
        * 无缓冲的输入输出函数
        * 带缓冲的输入输出函数
    2) DEMO
        ./source/rio


## **5. 共享文件**
    1) 内核使用3个相关的数据结构来表示打开的文件:
        * 描述符表: 每个进程都有独立的描述符表, 表项是由进程打开的文件描述符
          来索引的;
        * 文件表: 打开文件的集合是由一张文件表来表示的, 所有进程共享这张表;
        * v-node表: 所有的进程共享这张v-node表;
    2) 多个描述符也可以通过不同的文件表表项来引用同一个文件;
    3) 对于父进程打开了文件, fork之后子进程也拥有这个打开文件的描述符表; 当
       内核删除相应文件表表项的时候, 父子进程必须都关闭了它们的描述符;


## **6. IO重定向**
    1) Unix外壳允许通过重定向操作符将磁盘文件和标准输入输出联系起来;
    2) 如何实现IO重定向:
        * 使用dup2
              #include <unistd.h>
              int dup2(int oldfd, int newfd);
          拷贝描述符表表项oldfd到描述符表表项newfd, 覆盖newfd以前的内容; 如
          果newfd已经打开, 会在拷贝oldfd之前先关闭newfd;
