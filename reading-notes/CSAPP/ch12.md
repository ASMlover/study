# **并发编程**
***



## **1. 基于进程的并发编程**
    1) 最简单的方法就是使用进程
    2) 进程有一个非常清晰的模型: 共享文件表但不共享用户地址空间;
    3) 进程是有独立地址空间就使一个进程不可能覆盖另一个进程的虚拟存储器, 但
       使得进程共享状态信息变得困难;


## **2. 基于IO多路复用的并发编程**
    1) 使用select函数要求内核挂起进程, 只有再一个或多个IO事件发生后才将控制
       返回给应用程序;
          #include <unistd.h>
          #include <sys/types.h>
          int select(int n, fd_set* fdset, NULL, NULL, NULL);
          FD_ZERO(fd_set* fdset);
          FD_CLR(int fd, fd_set* fdset):
          FD_SET(int fd, fd_set* fdset);
          FD_ISSET(int fd, fd_set* fdset);
    2) 优势
        * 比基于进程的设计给程序员更多的对程序行为的控制;
        * 是运行再单一进程上下文的, 每个逻辑流程都能访问该进程的全部地址空间
