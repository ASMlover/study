# **处理器体系结构**
***
    

  * **设计一个自己的处理器Y86**



## **1. Y86指令集体系结构**
> ### **1.1 程序员可见的状态**
    请参见./pic/Y86_state.png
    1) 每条指令都会读取或修改处理器状态的某些部分, 这就是程序员可见状态;
    2) 有8个程序寄存器: %eax, %ecx, %edx, %ebx, %esi, %edi, %esp, %ebp, 各自
       存储一个字;
       %esp被入栈, 出栈, 调用和返回指令作为栈指针;
       3个一位的条件码: ZF, SF, OF, 保存最近的算术或逻辑指令所造成影响的有关
       信息;
       程序计数器(PC)存放当前正在执行指令的地址;
       存储器, 就是一个很大的字节数组, 保存程序和数据;
       状态码Stat, 表明程序执行的总体状态;

> ### **1.2 Y86指令**
    请参见./pic/Y86_IS.png
    1) movl指令分成4个不同的指令: irmovl, rrmovl, mrmovl, rmmovl; 分别显式指
       明源和目的的格式;
       源可以是立即数(i), 寄存器(r), 存储器(m);
       目的可以是寄存器(r), 存储器(m);
    2) OPl有4个整数操作指令: addl, subl, andl, xorl; 只对寄存器数据进程操作,
       会设置3个条件码ZF, SF和OF;
    3) JXX跳转指令有7个: jmp, jle, jl, je, jne, jge, jg; 根据分支指令的类型
       和条件码的设置来选择分支;
    4) cmovXXX条件传送指令有6个: cmovle, cmovl, cmove, cmovne, cmovge, cmovg
       它们的格式与寄存器-寄存器传送指令rrmovl一样, 但只有当条件满足所需要的
       约束才更新目的寄存器的值;
    5) call指令将返回地址入栈然后跳转到目的地址; ret指令从这样的过程调用返回
    6) halt指令停止指令的执行;

> ### **1.3 指令编码**
    1) 每条指令的第一个字节表明指令的类型, 这个字节分为两部分: 高4位是代码部
       分, 低4位是功能部分;
       请参见 ./pic/Y86_functional.png
    2) Y86寄存器标示符
        0 => %eax
        1 => %ecx
        2 => %edx
        3 => %ebx
        4 => %esp
        5 => %ebp
        6 => %esi
        7 => %edi
        F => 无寄存器

> ### **1.4 Y86异常**
    1) Y86状态码
        * 1   => AOK  => 正常操作
        * 2   => HLT  => 处理器执行halt指令
        * 3   => ADR  => 遇到非法地址
        * 4   => INS  => 遇到非法指令
    2) 对Y86来说, 遇到这些异常的时候, 让处理器停止执行指令就可以;




## **2. Y86的顺序实现**
> ### **2.1 将处理组织成阶段**
    1) 取指(fetch): 从存储器读取指令字节, 地址为PC的值; 
    2) 译码(decode): 从寄存器文件读入最多两个操作数, 得到值valA/valB;
    3) 执行(execute): 执行指令指明的操作, 计算存储器引用的有效地址, 增加或
       减少栈指针;
    4) 访存(memory): 将数据写入存储器, 或从存储器独处数据;
    5) 写回(write back): 最多可以写两个结果到寄存器文件;
    6) 更新PC(PC update): 将PC设置成下一条指令的地址;
