# **链接**
***

    链接是将各种代码和数据部分收集起来并组合成一个单一文件的过程, 这个文件可
    被加载到存储器并执行;


## **1. 编译器驱动程序**
    1) 对于main.c
    2) gcc -O2 -g -o -v out main.c
        * 先运行C预处理器(cpp), 将main.c生成main.i
        * 运行C编译器(ccl), 将main.i翻译成汇编语言文件main.s
        * 运行汇编器(as), 将main.s翻译成可重定位目标文件main.o
        * 运行链接器(la), 将main.o和一些必要的系统目标文件组合起来创建一个可
          执行目标文件out

## **2. 静态链接**
    为了构造可执行文件, 链接器必须完成两个主要任务:
    1) 符号解析: 将每个符号引用刚好和一个符号定义联系起来;
    2) 重定位: 编译器和汇编器生成从地址0开始的代码和数据节; 通过把每个符号定
       义与一个存储器位置联系起来, 然后修改所有对这些符号的引用, 使得它们指
       向这个存储器位置, 从而重定位这些节;

## **3. 目标文件**
    1) 可重定位目标文件: 含二进制代码和数据, 可在编译时与其他可重定位目标文
       件合并起来创建一个可执行目标文件;
    2) 可执行目标文件: 含二进制代码和数据, 可直接拷贝到存储器并执行;
    3) 共享目标文件: 特殊类型的可重定位目标文件, 可在加载或运行时被动态加载
       到存储器并链接;

## **4. 可重定位目标文件**
    1) ELF头以一个16字节的序列开始, 描述了生成该文件的系统的字的大小和字节
       顺序;
    2) ELF包含以下几个节:
        * .text: 已编译程序的机器代码;
        * .rodata: 只读数据(如printf语句中的格式串和开关语句的跳转表);
        * .data: 已初始化的全局C变量; 局部变量在运行时栈中, 既不在.data中也
          不在.bss中;
        * .bss: 未初始化的全局C变量; 未初始化变量不需要占据任何实际磁盘空间;
        * .symtab: 存放在程序中定义和引用的函数和全局变量的信息的符号表;
        * .rel.text: 一个.text节中位置的列表, 当链接器把这个目标文件和其他文
          件结合时, 需要修改这些位置;
        * .rel.data: 被模块引用或定义的任何全局变量的重定位信息;
        * .debug: 一个调试符号表, 其条目是程序中定义的局部变量和类型定义, 程
          序中定义和引用的全局变量, 以及原始的C源文件;
        * .line: 原始C源程序中的行号和.text节中机器指令之间的映射;
        * .strtab: 一个字符串表, 包括.symtab和.debug节中的符号表, 以及节头部
          中的节名字;

## **5. 符号和符号表**
    每个可重定位目标模块m都有一个符号表, 包含m所定义和引用的符号的信息; 在链
    接器上下文中, 有3中不同的符号:
    1) 由m定义并能被其他模块引用的全局符号;
    2) 由其他模块定义并被模块m引用的全局符号;
    3) 只被模块m定义和引用的本地符号;

## **6. 符号解析**
    1) 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号
       表中的一个确定的符号定义联系起来;
> ### **6.1 链接器如何解析多重定义的全局符号**
    1) UNIX链接器使用下面的规则来处理多重定义的符号:
        * 不允许有多个强符号;
        * 如果有一个强符号和多个弱符号, 那么选择强符号;
        * 如果有多个弱符号, 那么从这些弱符号中任意选择一个;
> ### **6.2 与静态库链接**
    1) 静态库: 将所有相关的目标模块打包成一个单独的文件;
    2) 静态库优点:
        * 将编译器的实现与标准函数的实现分离开来, 并对程序员保持适度便利;
    3) 静态库缺点:
        * 每个可执行文件都包含一份标准函数集合的完全拷贝, 很浪费磁盘空间;
        * 对任何标准函数的任何改变, 无论多小的改变都要求重新编译整个源文件;
> ### **6.3 链接器如何使用静态库来解析引用**
    E -> 可重定位目标文件集合;
    U -> 未解析的符号集合;
    D -> 已经定义的符号集合;
    1) 对每个输入文件f, 判断是目标文件还是存档文件; 如果是目标文件, 将f添加
       到E, 修改U和D来反映f中的符号定义和引用, 继续下一个输入文件;
    2) 如果是存档文件, 匹配U中未解析的符号和由存档文件成员定义的符号; 如果某
       存档文件成员m定义了一个符号来解析U中的一个引用, 将m加到E, 并修改U和D 
       来反映m中的符号定义和引用; 对存档文件中所有的成员目标文件反复执行该过
       程, 直到U和D不在发生变化; 
       任何不包含在E中的成员目标文件被简单丢弃, 而链接器继续处理下一个输入
       文件;
    3) 如果完成输入文件的扫描后U是非空, 那会输出错误并终止; 否则合并和重定位
       E中的目标文件, 构建输出可执行文件;

## **7. 重定位**
    1) 重定位节和符号定义, 将所有相同类型的节合并为同一类型的新的聚合节;
    2) 重定位节中的符号引用, 修改代码节和数据节中对每个符号的引用, 使它们指
       向正确的运行时地址;

## **8. 可执行目标文件**
    1) ELF文件格式请见./pic/ELF_file.png
    2) ELF文件
        * 头部描述文件的总体格式;
        * 包含程序的入口点(程序运行是要执行的第一条指令的地址);
        * .text, .rodata, .data和可重定位目标文件中的节是相似的;
        * .init节定义了一个小函数(_init), 程序的初始化代码会调用它;
        * 因为可执行文件是完全链接的, 所以不再需要.rel节;
