# **异常控制流**
***


## **1. 异常**
    1) 异常控制流的一种形式, 一部分由硬件实现, 一部分由操作系统实现;
    2) 是控制流中的突变, 用来响应处理器状态中的某些变化;
    3) 异常处理程序完成处理后, 根据引起异常的事件的类型, 会发生3种情况:
        * 处理程序将控制返回事件发生时正在执行的指令;
        * 处理程序将控制返回没有发生异常将指向的下一条指令;
        * 处理程序终止被中断的程序;
> ### **1.1 异常处理**
    1) 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号;
> ### **1.2 异常的类别**
    1) 异常分为: 中断, 陷阱, 故障和终止;
    2) 中断是异步发生的, 是来自处理器外部的IO设备的信号的结果;
    3) 陷阱, 故障和终止是同步发生的, 是执行当前指令的结果;
    4) 陷阱是有意的异常, 是执行一条指令的结果, 就像中断处理程序一样, 陷阱处
       理程序将控制返回到下一条指令;
    5) 故障由错误情况引起, 可能能够被故障处理程序修正; 故障发生时, 处理器将
       控制转移给故障处理程序; 如处理程序能够修正这个错误就将控制返回到引起
       故障的指令重新执行它, 否则返回到内核的abort;
    6) 终止是不可恢复的致命错误造成的结果, 通常是一些硬件错误; 终止处理程序
       从不将控制返回给应用程序;

## **2. 进程**
    1) 是一个执行中的程序的实例; 
    2) 每个程序都是运行在某个进程的上下文中的;
> ### **2.1 逻辑控制流**
    1) 用调制器单步执行程序, 会看到一系列的程序计数器(PC)的值, 这些值唯一对
       应包含在程序的可执行目标文件中的指令, 或是包含在运行时动态链接到程序
       的共享对象中的指令; 该PC值的序列就是逻辑控制流;
> ### **2.2 并发流**
    1) 一个逻辑流的执行在时间上与另一个流重叠, 就是并发流;
    2) 一个流并发地执行的一般现象就是并发;
> ### **2.3 私有地址空间**
    1) 一个进程为每个程序提供它自己的私有地址空间; 和这个空间中某个地址相关
       联的那个存储器字节是不能被其他进程读或写; 
> ### **2.4 用户模式和内核模式**
    1) 限制一个应用可以执行的指令以及它可以访问的地址空间的范围; 处理器使用
       某个控制寄存器中的模式位来提供这个功能;
    2) 设置模式位后, 进程能运行在内核模式中;
    3) 没有设置模式位时, 进程就运行在用户模式中;
> ### **2.5 上下文切换**
    1) 内核为每个进程维持一个上下文;
    2) 上下文就是内核重新启动一个被抢占的进程所需要的状态;


## **3. 系统调用错误处理**
    1) Unix系统级函数遇到错误时, 会返回-1, 并设置全局整数变量errno来表示出了
       什么错误;
    2) 处理错误函数的封装:
        void unix_error(const char* msg) {
          fprintf(stderr, "%s: %s\n", msg, strerror(errno));
          exit(0);
        }


## **4. 进程控制**
    1) 获取进程ID
        * getpid返回调用进程的PID;
        * getppid返回它的附近承的PID;
    2) 创建和终止进程(进程处于三种状态之一)
        * 运行: 要么在CPU执行, 要么在等待被执行且最终会被内核调度;
        * 停止: 进程的执行被挂起, 且不会被调度;
        * 终止: 进程永远地停止了; 终止的原因有(接收到信号, 该信号默认行为是
                终止进程; 从主程序中退出; 调用exit函数)
    3) 父进程调用fork创建一个新的运行子进程;
        * fork只被调用一次, 却返回两次;
        * 一次是在调用进程中, 一次是在新创建的子进程中;
        * 在父进程中, fork返回子进程的PID; 在子进程中, fork返回0;
    4) 当一个进程终止时, 内核并不是立即把它从系统中清除; 进程被保持在一中已
       终止中, 直到被它的父进程回收; 父进程回收已终止的子进程时, 内核将子进
       程的退出状态传递给父进程, 然后抛弃已终止的进程;
    5) 一个终止了但还未被回收的进程就是僵死进程;
    6) sleep将一个进程挂起一段指定的时间; pause调用函数休眠, 直到该进程收到
       一个信号;
    7) execve在当前进程的上下文中加载并运行一个新程序; 加载并执行filename, 
       且带参数列表argv和环境变量列表envp;
