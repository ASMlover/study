# **虚拟存储器**
***

## **1. 物理和虚拟寻址**
    1) 计算机系统主存被组织成一个由M个连续的字节大小的单元组成的数组, 每字节
       都有一个唯一的物理地址; 第一个字节的地址为0, 接下来的字节地址为1, 然
       后是2, 以此类推; 这种方式就是物理寻址;
    2) 虚拟寻址时, CPU通过生成一个虚拟地址来访问主存, 这个虚拟地址在被送到存
       储器之前先转换成适当的物理地址;


## **2. 地址空间**
    1) 地址空间是一个非负数整数地址的有序集合: {0, 1, 2, ...}
    2) 如果地址空间中的整数是连续的, 那么它就是一个线性的地址空间;


## **3. 虚拟存储器作为缓存的工具**
    1) 虚拟存储器被组织为一个由存放在磁盘上的N个连续的字节代谢奥的单元组成的
       数组; 每个字节都有一个唯一的虚拟地址, 这个唯一的虚拟地址是作为到数组
       的索引的;
    2) 虚拟页面的集合都分为3个不相交的子集:
        * 未分配的: VM系统还未分配的页;
        * 缓存的: 当前缓存在物理存储器中的已经分配页;
        * 未缓存的: 没有缓存在物理存储器中的已分配页;


## **4. 垃圾搜集**
    1) 垃圾搜集器(garbage collector)是一种动态存储分配器, 自动释放程序不再需
       要的已分配块;
    2) Mark&Sweep垃圾搜集器
        typedef void* ptr;
        * ptr isPtr(ptr p) -> 如p指向一个已分配块中的某个字, 那么就返回一个
          指向这个块的起始位置的指针, 否则返回NULL;
        * int blockMarked(ptr b) -> 如果已经标记了块b, 那么返回true;
        * int blockAllocated(ptr b) -> 如块b是已分配的, 那么返回true;
        * void markBlock(ptr b) ->  标记块b;
        * int length(ptr b) -> 返回块b的以字为单位的长度(不包括头部);
        * void unmarkBlock(ptr b) -> 将块b的状态由以标记修改为未标记的;
        * ptr nextBlock(ptr b) -> 返回堆中块b的后继;
