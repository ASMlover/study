# **类与面向对象编程**
***

## **1. class语句**
    1) 类定义了一组属性，这些属性与一组叫实例的对象相关且由其共享；
    2) 类通常是由函数、变量和计算出的属性组成的集合；
    3) 类中定义的函数是实例方法，是一种在类的实例上就进行操作的函数；
    4) 方法的第一个参数是self；
    5) 类变量是可在类的所有实例之间共享的值；

## **2. 类实例**
    1) 是以函数形式调用类对象来创建的；创建一个新实例，然后将该实例传递给类
       的__init__方法；
    2) 创建实例后，可以使用点(.)运算符来访问这些属性以及类的属性；
    3) 点(.)运算符属于属性绑定；

## **3. 范围规则**
    1) 类中没有范围是Python与C++或java的区别之一；
    2) Python没有提供显示声明变量的方式，所以需要显示使用self；
    3) Python里无法知道在方法中要赋值的变量是不是局部变量，或是否要保存为实
       例属性，显示self可以解决该问题，存储在self中的所有值都是实例的一部分

## **4. 继承**
    1) 继承是一种创建新类的机制，专门使用或修改现有类的行为；
    2) 如果没有有效的基类，类将继承object；
    3) 子类可以定义自己的__init__()，从而项实例添加新属性；子类定义__init__
       时不会自动调用基类的__init__，需要子类调用基类的__init__来对它们进行
       恰当的初始化；
    4) super(cls, instance)返回一个特殊对象，支持在基类上执行属性查找；

## **5. 多态动态绑定和鸭子类型**
    1) 在不考虑实例类型的情况下使用实例；
    2) 以obj.attr形式访问属性，会按照在实例本身内部、实例的类定义，然后是基
       类的顺序进行搜索并定位attr；返回第一个匹配项；

## **6. 静态方法和类方法**
    1) 静态方法是一种普通函数，位于类定义的命名空间中，不会对任何实例类型进
       行操作，需要使用@staticmethod装饰器；
    2) 类方法是将类本身作为对象进行操作的方法，使用@classmethod装饰器定义，
       类是作为第一个参数(cls)传递的；

## **7. 特性**
    1) 特性(property)是一种特殊的属性，访问它时会计算它的值；
        class Circle(object):
          def __init(self, radius):
            self.radius = radius
          @property
          def area(self):
            return math.pi * self.radius ** 2
          @property
          def perimeter(self):
            return 2 * math.pi * self.radius
        可以直接使用c.area和c.perimeter来访问达到方法调用的效果；
    2) @property装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加
       额外的()来调用该方法；
    3) 特性可以拦截操作以便设置和删除属性(setter和deleter)；
        class Foo(object):
          def __init__(self, name):
            self.__name = name
          @property
          def name(self):
            return self.__name
          @name.setter
          def name(self, value):
            if not isinstance(value, str):
              raise TypeError('Must be a string')
            self.__name = name
          @name.deleter
          def name(self):
            raise TypeError("Can't delete name")
        这样Foo的实例可以直接使用f.name来赋值和读取值，但是不能del name 属性
    4) 还可以使用property(getf=None, setf=None, delf=None, doc=None)函数定义
       的特性以及可执行每个操作的一组唯一命名的方法；
          class Foo(object):
            def getname(self):
              return self._name
            def setname(self, name):
              if not isinstance(name, str):
                raise TypeError('Must be a string')
              self._name = name
            def delname(self):
              raise TypeError("Can't delete name")
            name = property(getname, setname, delname)

## **8. 描述符**
    1) 描述符就是一个表示属性值的对象，实现一个或多个特殊的__get__(), 
       __set__()和__delete__()方法可以将描述符与属性访问机制挂钩，还可以自定
       义这些操作；
          class TypedProperty(object):
            def __init__(self, name, type, default=None):
              self.name = "_" + name
              self.type = type
              self.default = default if default else type()
            def __get__(self, instance, cls):
              return getattr(instance, self.name, self.default)
            def __set__(self, instance, value):
              if not isinstance(value, self.type):
                raise TypeError("Must be a %s" % self.type)
              setattr(instance, self.name, value)
            def __delete__(self, instance):
              raise AttributeError("Can't delete attribute")
          class Foo(object):
            name = TypedProperty('name', str)
            num = TypedProperty('num', int, 43)
          >>> f =  Foo()
          >>> n = f.name      # 隐式调用Foo.name.__get__(f, Foo)
          >>> f.name = 'name' # 隐式调用Foo.name.__set__(f, 'name')
          >>> del f.name      # 隐式调用Foo。name.__delete__(f)
    2) 描述符只能在类级别上进行实例化；不能通过在__init__和其他方法中创建描
       述符对象来为每个实例创建描述符；
    3) 有描述符的类使用的属性名称比实例上存储的属性名称具有更高的优先级；
