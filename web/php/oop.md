# **Object Oriented Programming** #
***

## **1. 基础** ##
        PHP中的类声明和其他面向对象语言类似, 各种访问权限的关键字也相同, 可
    以在class前面加上abstract或则final等。
        PHP和C++的在成员函数内部的区别是, 在成员内访问成员或或则方法需要使用
    关键字——$this.
        PHP中的预定义构造函数和析构函数分别为__construct和__destruct




## **2. __set(), __get(), __isset()和__unset()四个方法** ##
        这些预定义方法只有在需要的时候才添加到类当中, 他们的作用, 名称, 使用
    的参数列表和返回值都是规定好的。
> ### **2.1 __set** ###
    控制在对象外部只能为私有成员赋值, 不能获取私有成员的值;
    原型:
        void __set(string name, mixed value);
        name => 传入在为私有属性设置值的属性名
        value => 传入为属性设置的值
    使用的时候直接操作属性即可...
> ### **2.2 __get** ###
    直接在对象的外部获取私有属性的值时, 会调用该方法, 返回私有属性的值;
    原型:
        mixed __get(string name);
        name => 传入在获取私有属性值时的属性名
> ### **2.3 __isset和__unset** ###
    外部在使用isset方法检测对象中的成员时候, 就会调用__isset, unset类似;
    原型:
        bool __isset(string name);
        name => 传入对象中的成员属性名
        void __unset(string)
        name => 传入对象中的成员属性名, 将私有成员属性删除




## **3. PHP类继承** ##
        PHP只支持单继承, 继承的时候需要使用关键字extends
> ### **3.1 访问类型控制** ###
        如果成员没有指定成员访问修饰符, 将默认为public
                          private       protected       public 
        同一个类            yes            yes           yes
        类的子类            no             yes           yes
        所有外部成员        no             no            yes 




## **4. 常见的关键字和魔术方法** ##
> ### **4.1 final关键字的应用** ###
    1) final关键字的左右
        使用final标示的类, 不能被继承; 
        在类中使用final标识的成员方法, 在子类中不能被覆盖
    2) static关键字
        可以将类中的成员标示为静态, 可以用来标示属性和方法; 
        在类外的访问格式为:
            类名::静态成员属性名;
            类名::静态成员方法名();
        在类的声明方法中, 不能使用$this去访问, 尽量使用$self关键字来访问; 
    3) const关键字
        通过define来定义常量, 在类中的成员属性定义只能使用const来定义成常量;
        其访问方式和静态成员一样; 
        使用const的常量不能使用'$'符号, 常量名通常大写;
    4) 克隆对象
            可以根据对象克隆出一个完全一样的对象, 原本和副本两个对象完全对立
        互不干扰, 使用'clone'来克隆对象;
            如果需要副本在克隆时重新为成员赋值, 则可以在类中声明__clone;
            __clone方法不需要任何参数, 自动包含$this和$that两个对象引用, 
        $this是副本对象的引用, $that是原本对象的引用;
    5) 类中通用方法__toString()
        快速获取对象的字符串标示的最快捷的方式, 直接输出对象引用时自动调用;
        类中实现了__toString, 那么在echo $obj就可以输出想要的信息;
        __toString一定有一个字符串作为返回值, 通常返回的字符串是使用对象多个
        属性值连接而成;
    6) 通过__call处理错误调用
            在调用对象中不存在的方法是会报错, 如果类中实现了__call, 那么则会
        自动调用该方法, 且可以继续向下执行;
            __call原型:
            function __call($function, $args);
            $function => 调用的不存在的方法的方法名;
            $args     => 调用该不存在的方法时传递的参数数组;
    7) 自动加载类
            PHP提供了类的自动加载功能, 当你尝试使用一个PHP没有组织到的类时, 
        它会寻找一个__autoload的全局函数, 如果存在该函数, PHP会用一个参数(类
        的名称)来调用它。
            function __autoload($class_name) 
            { 
              include(ucfirst($class_name) . ".class.php");
            }
    8) 对象串行化
        将对象串行化的情况:
            对象需要在网络中传输, 将对象串行化为二进制串后在网络中传输;
            对象需要持久保存, 将对象串行化后写入文件或数据库;
        serialize需要一个对象引用名做参数, 返回一个对象串行化后的字符串;
        unserialize的参数为serialize的返回值, 返回重新组织好的对象;
        在调用serialize将对象串行化的时候, 会自动调用对象中的__sleep方法; 
        在调用unserialize反串行化对象时, 会自动调用对象中的__wakeup方法;
            __sleep不接受任何参数, 但是需要返回一个数组, 在数组中包含需要串
        行化的属性, 未被包含的数组在串行化时将被忽略, 如果没有__sleep方法,
        对象中的所有属性都将被串行化;
            __wakeup不接受任何参数, 也不返回, 只是需要将__sleep未包含的成员
        重新赋值, 以保证对象的完整性.



## **5. 抽象方法和抽象类** ##
        抽象方法就是没有方法提的方法, 并且使用abstract关键字来修饰; 只要在类
    中有一个方法是抽象方法, 那么这个类就是抽象类, 抽象类也可以使用abstract关
    键字来修饰。
        在抽象类中可以有不是抽象的属性和方法, 但是访问权限不能是private;
        同其他语言一样, 抽象类不能实例化;
        子类继承抽象类后, 必须将抽象类中的抽象方法按照子类自己的需求实现, 子
    类必须实现全部的抽象类中的方法, 否则其还是抽象类;




## **6. 接口** ##
        接口格式:
        interface 接口名 {
          // 常量成员
          // 抽象方法
        }
        虽然PHP是单继承的, 一个类只有一个父类, 但是一个类可以实现多个接口, 
    将要实现的多个接口之间使用逗号分开, 子类要将所有接口中的抽象方法全部实现
    即一个类要遵守多个规范;
        class 类名 implements 接口1, 接口2, ... 接口n {
          // 实现所有接口中的抽象方法
        }
