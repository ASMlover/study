# **API** #
***


## **1. 程序整理** ##
    1) 整理程序, 让命令行窗口的实现更加清晰
    2) 具体例子请参见./os-src/toyos98/


## **2. 显示单个字符的API** ##
    1) 只要我们的应用程序能够通过某种方法调用系统中的打印单个字符的函数就可
       以实现了
    2) 在汇编中, call和jmp其实差不多, 区别在于执行call的时候, 为了能够在接下
       来执行ret指令的时候正确返回, 会先将要返回的目标地址push到栈中
    3) 我们打印一个字符的函数是使用C语言来实现的, 即使我们将字符编码存放到寄
       存器中, 函数也没得办法来接收, 我们必须在call调用函数之前将文字编码推
       入栈中; 因此我们需要实现一个将寄存器中的值推入栈中的函数
    4) 首先应用程序是不知道console的地址的, 所以只能让OS将这个地址实现保存到
       某个内存中的地址
    5) 但是API的地址不能这样直接就使用了, 应该加上段号, 应用程序在段1003 * 8
       而操作系统在2 * 8段
    6) 同时普通的ret用于普通的call返回, 而对于fall-call调用的返回, 应该使用
       指令retf
    7) 具体例子请参见./os-src/toyos99/


## **3. 结束应用程序** ##
    1) 应用程序需要结束, 只需要程序调用ret即可, 这样操作系统也需要调用call而
       不是jmp来启动应用程序
    2) 具体例子请参见./os-src/toyos9a/


## **4. 不随操作系统版本改变的API** ##
    1) 每次我们修改了操作系统的代码, 那提供的API的地址就会改变, 那么我们就来
       解决这个问题
    2) CPU中有一个专门来注册函数的地方, 这就是IDT中设置的; IRQ只有0~15, 而
       CPU用于通知异常状态的中断最多也就32中, IDT中最多可以设置256个函数, 因
       此我们还可以使用很多未使用的项
    3) 我们设置的API函数选择在0x30~0xff这些空闲的即可
    4) 这样我们在自己的应用程序中就可以使用int指令调用我们的程序即可(API号)
    5) 而int指令用来调用的时候会被当做是中断处理, 使用retf是没有办法返回的,
       是需要使用iretd指令来实现的
    6) 在我们提供的API中, 我们使用int调用的时候, 对CPU来说相当于执行了中断处
       理程序, 因此在调用的同时会自动执行cli指令来禁止中断请求, 而我们只要用
       来代替call指令的, 因此我们需要在API的开头设置sti指令 
    7) 具体例子请参见./os-src/toyos9b/
