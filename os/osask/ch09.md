# **内存管理** #
***


## **1. 将鼠标和键盘整理成单独模块** ##
    1) 在讲解内存管理之前, 先将鼠标整理成一个单独处理的模块
    2) 具体例子请参见./os-src/toyos39/



## **2. 内存容量检查** ##
    1) 在启动的时候, BIOS肯定会检查内存容量, 所以我们只需要查询BIOS就可以知
       道内存的容量有多大;
       但是使用这种方法的话, 会造成汇编容量的增加, 也会由于BIOS的种类不同, 
       造成调用BIOS的麻烦;
    2) 486及以上的CPU才有高速缓存
    3) 为了使用CPU的高速缓存, 每次访问内存, 都要将所访问的地址和内容存储到高
       速缓存里面;
       往内存里写数据, 首先更新高速缓存的信息, 然后再写入内存
    4) 内存检查的时候, 往内存中随便写入一个值, 然后再读取, 判断读取的值与写
       入的值是否相等来判断内存是否正常连接;
       但是如果有缓存的话, 每次操作都是缓存; 那么只有在内存检查的时候才将缓
       存设置为OFF
    5) 首先检查CPU是386还是486, 如果是486以上, 那EFLAGS寄存器的第18位就是AC
       标志位; 如果是386, 那么就没有这个标志位, 那么第18位一直处于0
    6) 我们对一段范围的地址进行检查, 检查最后一个允许写的地址; 
       先将一个地址原来的值保存下来, 然后向该地址中写入一个值(0xaa55aa55), 
       在内存中反转, 检查结果是否正确; 如果正确, 再反转一次看能否恢复到原来
       的值, 这样就可以找到最后一块允许写的地址了;
       这里检查的时候, 我们每次检查4K的地址即可;
    7) 我们检查0x00400000 ~ 0xbfffffff范围内的地址可否写即可
    8) 具体例子请参见./os-src/toyos40/



## **3. 内存容量检查(setp 2)** ##
    1) 上次的demo中出现的结果与我们预想的有所不同
    2) 原因是C编译器, 为了效率的优化, 将代码中的几次反转在反转回来给优化掉了
       这样循环中便什么都没有了, 所以会出现和我们预想不一样的结果
    3) 为了不让编译器对这里做我们不想要的优化, 我们利用汇编来重写内存容量检
       查函数
    4) 具体例子请参见./os-src/toyos41/



## **4. 内存管理** ##
    1) 内存管理的基础, 一个是内存分配, 另一个是内存释放
    2) 假设有128MB内存, 以4KB为单位进行管理, 那么就有128MB/4KB=32768, 所以我
       们只需要管理这32768个区域即可(0/1来标示是否空着)
    3) 另一种就解决方法是:
        struct free_info_t {  //! 可用的空加你状况
          unsigned int addr, size;
        };
        struct mem_mgr_t {    //! 内存管理
          int frees;
          struct free_info_t[1000];
        };
        这种方法的优点是:
          * 占用内存少
          * 大块内存的分配和释放迅速
        这种方法的缺点是:
          * 内存管理的实现变得复杂
          * 内存空间被搞得零散, 容易出现内存碎片
    4) 解决内存碎片的方法是, 先将那些小内存块割舍掉, 内存管理空闲是再对使用
       中的内存进行检查, 将割舍掉的那部分内存找回来
    5) 具体例子请参见./os-src/toyos42/
