# **多任务** #
***


## **1. 挑战任务切换** ##
    1) 多任务(multitask), 即是多个任务的意思, 多个应用程序同时运行的状态就是
       多任务
    2) 要实现多任务就需要进行任务切换, 一般操作系统的切换需要0.01~0.03秒;
        如果操作系统0.0002s切换一次任务, 那么CPU处理能力的50%都被用在切换上
        了;
        0.001s切换一次任务, 在切换任务上就会消耗CPU处理能力的10%;
        如果0.01s切换一次任务, 那么只需要CPU的1%来进行任务切换;
    3) 向CPU发出任务切换指令时, CPU会先把寄存器中的值全部写入内存中, 这样是
       为了当以后切换回这个程序的时候, 可以从中断的地方继续运行; 接下来为了
       运行下一个程序, CPU会把所有寄存器中的值从内存中读取出来, 如此就完成了
       一次切换; 
       切换任务所需要的时间就是对内存进行读写操作所消耗的时间了
    4) 我们可以准备一个任务状态段来记录切换任务所需要的信息
        backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;
        eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;
        es, cs, ss, ds, fs, gs;
        ldtr, iomap;
        * eip(extended instruction pointer), 用来记录下一条需要执行的指令位
          于内存中哪个地址的寄存器; 每执行一条指令, eip寄存器中的就会自动累
          加, 从而保证一直指向下一条指令所在的内存地址
        * 第一行保存的是与任务设置相关的信息, 在执行任务切换的时候这些成员不
          会被写入(backlink除外)
        * 第二行和第三行是32位寄存器和16位寄存器 
        * ldtr和iomap是有关任务设置的信息, 在任务切换时不会被CPU写入
    5) tr(task register)寄存器, 是让CPU记住当前正在运行哪一个任务; 当进行任
       务切换的时候tr寄存器的值也会自动变化; 每次给tr寄存器赋值的时候, 必须
       把gdt的编号乘以8 
    6) 具体例子请参见./os-src/toyos74/



## **2. 任务切换进阶** ##
    1) 前面我们只是完成了从任务A切换到任务B, 我们需要将切换回A 
    2) 具体例子请参见./os-src/toyos75/



## **3. 做个简单的多任务** ##
    1) 现在实现任务来回切换的功能, 让任务看上去是同时运行的
    2) 为了实现任务切换, 我们需要实现一个jmp far的函数; 在jmp far指令中, 可
       以指定一个内存地址, CPU会从指定的内存地址中读取4个字节的数据存入到eip
       寄存器中, 再继续读取2字节的数据存放在cs寄存器中, 这样就可以实现跳转了
    3) 为了让任务看上去像是同时运行的, 我们需要将切换时间修改为0.02s
    4) 具体例子请参见./os-src/toyos76/
