# **进入32位模式并导入C语言** #
***


## **制作真正的IPL** ##
    1) 磁盘读写, 扇区校验, 以及寻道:
        * ah = 0x02; (读盘)
        * ah = 0x03; (写盘)
        * ah = 0x04; (校验)
        * ah = 0x0c; (寻道)
        * al = 处理对象的扇区数; (只能同时处理连续的扇区)
        * ch = 柱面号 & 0xff;
        * cl = 扇区号(0~5位) | ((柱面号 & 0x300) >> 2);
        * dh = 磁头号;
        * dl = 驱动器号;
        * es:bx = 缓冲地址; (校验以及寻道时不使用)
        * 返回值;
        * flags.cf == 0: 没有错误, ah == 0
        * flags.cf == 1: 有错误, 错误号码存入ah内(与重置(reset)功能一样)
    2) 进位标志是一个只能存储一位信息的寄存器, 用来表示有没有进位
    3) ch, cl, dh, dl分别表示柱面号, 扇区号, 磁头号, 驱动器号
    4) 磁头是个针状的磁性设备, 既可以从软盘正面也可以从软盘背面接触磁盘, 正
       面磁头为0号, 反面为1号
    5) 一张软盘有80个柱面, 2个磁头, 18个扇区, 一个扇区512字节
    6) 含有IPL的启动区, 是C0-H0-S1(柱面0, 磁头0, 扇区1)
    7) 缓冲区地址, 是一个内存地址, 表示我们要把磁盘上读出的数据装载到内存的
       哪个位置; 
       以ES:BX这种方式来表示地址, 表示ES * 16 + BX的内存地址
    8) 内存0x8000~0x81ff是留给启动区的, 要将启动区的内容读到那里; 
    9) 0x7c00~0x7dff用于启动区, 0x7e00~0x9fbff没特别作用, 操作系统可以随意使
       用
    10) 不管我们要指定内存的什么地址, 都必须同时指定段寄存器, 如果省略的话, 
        会将"DS:"作为默认的段寄存器; 因此DS必须预先指定为0, 否则就会读到其他
        地方而引起混乱
    11) 具体例子请参见./os-src/toyos00/


## **试错** ##
    1) 软盘很不可靠, 有时候会出现不能读取数据的状况, 所以应该在出现错误的时
       候, 让它再试几次
    2) JNC(jump if not carry), 进位标志是0的话就跳转
    3) JAE(jump if above or equal), 大于或等于的时候跳转
    4) ah=0x00, dl=0x00, int 0x13, 是系统复位命令
    5) 具体例子请参见./os-src/toyos01/


## **读到18扇区** ##
    1) JBE(jump if below or equal), 小于等于的时候跳转
    2) 指定处理的扇区数, 范围在0x01~0xff(指定0x02以上的数值时, 要特别注意能
       够连续处理多个扇区的条件, 如果是fd的话, 似乎不能跨越多个磁道, 也不能
       超过64k的界限)
    3) 具体例子请参见./os-src/toyos02/


## **读入10个柱面** ##
    1) JB(jump if below), 如果小于就跳转
    2) 这样就装载了10 * 2 * 512 * 18 = 180KB, 10个柱面, 每个扇区512字节, 18
       个扇区, 磁盘分两面。。。
    3) 具体例子请参见./os-src/toyos03/


## **着手开发操作系统** ##
    1) 这里只是开发了一个最简单的操作系统, 只让它hlt
        finish:
          hlt
          jmp finish
    2) 向一个空软盘保存文件时:
        * 文件名会写在0x002600以后的地方
        * 文件的内容会写在0x004200以后的地方
    3) 我们将操作系统本身的内容写到toyos.sys中, 再将它保存到磁盘文件上, 然后
       我们就可以从启动区执行这个toyos.sy就可以了


## **从启动区执行操作系统** ##
    1) 现在程序是从启动区开始, 把磁盘上的内容装载到内存0x8000地址, 所以磁盘
       0x4200的内容就应该在内存0x8000+0x4200=0xc200
    2) 这样我们就可以在toyos.s(操作系统程序)中让程序从0xc200开始执行, 而在启
       动区(ipl.s)直接跳转到这个地址即可


## **确认操作系统的执行情况** ##
    1) 设定ah=0x00后, 调用显卡BIOS的函数, 就可以切换显示模式了
    2) 设置显卡模式
        * 0x03: 16色字符模式, 80 * 25
        * 0x12: VGA图形模式, 640 * 480 * 4位彩色模式, 独特的4面存储模式
        * 0x13: VGA图形模式, 320 * 200 * 8位彩色模式, 调色板模式
        * 0x6a: 扩展VGA图形模式, 800 * 600 * 4位彩色模式, 独特4面存储模式
        * 返回值: 无



## **32位模式前期准备** ##
    1) 32位模式, 是指CPU的模式; CPU有16位和32位两种模式
    2) 以16位模式启动, 那么ax和cx等16位寄存器会很方便, 但是eax和ecx会很麻烦;
       16位模式和32位模式中, 机器语言的命令代码是不一样的; 同样的机器语言, 
       解释方法也是不一样的, 16位模式的机器语言在32位模式下是不能运行的
    3) CPU的自我保护功能在16位模式下不能使用
    4) 32位模式下不能调用BIOS功能了, 因为BIOS是用16位机器语言写的; 所以在开
       发操作系统中, 有什么需要调用BIOS的则应该在未进入32位模式的时候调用
    5) [VRAM]保存的是0xa0000, 即是用来显示画面的内存
    6) int 0x10, 这种画面模式下VRAM是0xa0000~0xafff的64KB
