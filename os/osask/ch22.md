# **用C语言编写应用程序** #
***


## **1. 保护操作系统** ##
    1) 现在的操作系统已经不能直接在内存上搞破坏了, 那我们还可以在定时器上做
       手脚
    2) 当以应用程序模式运行的时候, 执行in指令和out指令都会产生一般保护异常
    3) 直接使用in或out不能破坏操作系统
    4) 我可以直接使用cli然后执行hlt来对系统破坏做为实验(猜想系统应该死机)
    5) 当系统以应用程序模式运行的时候, 执行cli, sti和hlt这些指令都会产生异常
       因为中断应该是由操作系统来管理的, 应用程序不可以随便进行控制
    6) 系统里面有一个使用cli的函数, 我们直接使用这个函数即可对系统破坏(猜想)
    7) CPU规定除了设置好的地址以外, 禁止应用程序call其他的地址, 因此系统中应
       用程序要调用操作系统的API只能采用int 0x40的方法
    8) 看来我们的系统可以抵御上面的集中破坏了
    9) 具体例子请参见./os-src/toyosa5/


## **2. 帮助发现bug** ##
    1) CPU的异常处理功能, 除了可以保护操作系统免遭应用程序的破坏, 还可以帮助
       我们在编写应用程序的时候发现bug
    2) 我们的测试bug1程序中, 其实是栈出现了问题, 我们需要一个函数来处理栈异
       常, 栈异常的中断号是0x0c
    3) 如果访问的元素只是超过了数组的边界而没有超过应用程序的段边界的话, 也
       不会产生异常
    4) CPU产生异常的目的不是去发现bug, 而是为了保护操作系统
    5) 要让操作系统帮助发现bug, 最好是知道引发异常指令的地址
        * esp[0]    -> edi
        * esp[1]    -> esi  esp[0~7]为_asm_interrupt_handler中pushad的结果
        * esp[2]    -> ebp
        * esp[4]    -> ebx
        * esp[5]    -> edx
        * esp[6]    -> ecx
        * esp[7]    -> eax
        * esp[8]    -> ds   esp[8~9]为_asm_interrupt_handler中push的结果
        * esp[9]    -> es 
        * esp[10]   -> 错误编号(基本上是0, 显示出来也没有意思)
        * esp[11]   -> eip
        * esp[12]   -> cs   esp[10~12]为异常产生时cpu自动push的结果
        * esp[13]   -> eflags
        * esp[14]   -> esp  应用程序用esp
        * esp[15]   -> ss   应用程序用ss
    6) 在真机中测试, 捕获了这个bug1中的bug
    7) 具体例子请参见./os-src/toyosa6/


## **3. 强制结束应用程序** ##
    1) 目前我们的系统可以应对大部分的恶意程序了, 现在我们来为系统加上强制结
       束应用程序
    2) 我们只要将某一个按键设定为强制结束键, 这样就可以结束程序了
    3) 当按下强制结束键时, 改写命令行窗口任务的寄存器值, 并goto到结束函数就
       可以了
    4) 具体例子请参见./os-src/toyosa7/



## **4. 用C语言显示字符串** ##
    1) 来为C语言提供显示字符串的API
    2) 既然现在已经不使用retf来结束程序了, 我们就可以将应用程序开头的6个字节
       的改写还原了; 去掉开头那6个字节, 程序也不在jmp 0x1b了, 因此启动用户程
       序的地址也需要修改
    3) 具体例子请参见./os-src/toyosa8/


## **5. 用C语言显示字符串** ##
    1) 由于我们显示字符串的API并没能正确的显示字符串, 我们可以在字符串显示的
       API被调用的时候, 显示寄存器ebx的值来进行调试
    2) 我们创建的toy应用程序包含两个部分
        * 代码部分
        * 数据部分
        虽然有两个部分, 当程序中没有使用字符串和外部变量的时候, 就会生成不包
        含数据部分的toy文件;
        toy文件的数据部分会在应用程序启动的时候被传到应用程序的数据段中, 而
        toy文件中数据部分的位置则存放在代码部分的开头一段区域中;
    3) toy程序的开头36个字节不是程序, 而是下面的信息:
        * 0x0000(dword) -> 请求操作系统为应用程序准备的数据段的大小
        * 0x0004(dword) -> "Hari"(toy文件的标记)
        * 0x0008(dword) -> 数据段内预备空间的大小
        * 0x000c(dword) -> esp初始值&数据部分传送目的地址
        * 0x0010(dword) -> toy文件内数据部分的大小
        * 0x0014(dword) -> toy文件内数据部分从哪里开始
        * 0x0018(dword) -> 0xe9000000
        * 0x001c(dword) -> 应用程序运行入口地址0x20
        * 0x0020(dword) -> malloc空间的起始地址
    4) 我们对运行app程序的cmd_app进行一些更改; 
        * 文件中找不到"Hari"标志报错
        * 数据段的大小跟据.toy文件中指定的值进行分配
        * 将toy文件中的数据部分先复制到数据段后再启动程序
        经修改后, 我们的程序只有经过转换成toy的才会运行成功, 不会因为只是修
        改一些后缀就运行不该运行的文件了
    5) 具体例子请参见./os-src/toyosa9/



## **6. 显示窗口** ##
    1) 我们设计显示窗口的API
        * edx = 5
        * ebx = 窗口缓冲区
        * esi = 窗口在x轴方向上的大小(窗口宽度)
        * edi = 窗口在y轴方向上的大小(窗口高度)
        * eax = 透明色
        * ecx = 窗口名称
        * 调用后返回
          eax = 操作窗口的句柄
    2) 具体例子请参见./os-src/toyosaa/



## **7. 在窗口中描绘字符和方块** ##
    1) 现在来实现在窗口上显示字符和方块
    2) 显示字符的API
        * edx = 6
        * ebx = 窗口句柄
        * esi = 显示位置的x坐标
        * edi = 显示位置的y坐标
        * eax = 色号
        * ecx = 字符串长度
        * ebp = 字符串
    3) 描绘方块的API
        * edx = 7
        * ebx = 窗口句柄
        * eax = x0
        * ecx = y0
        * esi = x1
        * edi = y1
        * ebp = 色号
    4) 具体例子请参见./os-src/toyosab/
