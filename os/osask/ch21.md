# **保护操作系统** #
***


## **1. 攻克难题-字符串显示API** ##
    1) 现在的OS显示字符串的时候会出现问题, 应该是内存段出错造成的
    2) 显示单个字符的时候使用[cs:ecx]的方式特意指定cs, 因此可以成功读取msg的
       内容; 但是显示字符串的时候, 由于无法指定段地址, 程序会认为段地址是ds
       而从完全错误的内存中读取内容, 所以会出错
    3) toy_api并不知道代码段的起始位置位于内存的哪个地址, 这样我可以将代码段
       从cmd_app传到toy_api就可以了; 我只需要将起始地址存放在一个内存地址中
       就可以了
    4) 具体例子请参见./os-src/toyos9f/



## **2. 用C语言编写应用程序** ##
    1) 我们使用C语言来编写应用程序, 需要提供应用程序调用的C API, 而这个我们
       需要在汇编中实现
    2) 我们编译出来的C所写的toy文件, 我们需要修改其二进制的开头几个字节, 需
       要先调用0x1b这个地址的函数, 这个0x1b其实就是toy文件中入口函数的地址
    3) 但每次都修改编译出来的toy程序的开头几个字节实在是太麻烦了, 我们需要在
       操作系统中直接修改, 只需要在操作系统调用应用程序的地方对开头几个字节
       进行修改就可以了
    4) 具体例子请参见./os-src/toyosa0/


## **3. 保护操作系统** ##
    1) 我们应该为系统提供保护以应对那些恶意的程序或有bug的程序, 应该禁止用户
       程序访问一些本该由操作系统管理的内存空间
        * 操作系统用代码段  -> 2 * 8
        * 操作系统用数据段  -> 1 * 8
        * 应用程序用代码段  -> 1003 * 8
        * 应用程序用数据段  -> 1004 * 8
        * 3 * 8 ~ 1002 * 8 为TSS所使用的段
    2) 汇编中以.开头的标签名, 是一种本地标签的特殊标签, 和普通标签的区别在于
       即使表签名和其他函数中的标签重复, 系统也可以将它们区分开
    3) 具体例子请参见./os-src/toyosa1/


## **4. 对异常的支持** ##
    1) 现在我们来实现当程序出现异常之后强制结束程序的功能
    2) 在x86架构中, 当应用程序试图破坏操作系统, 或者试图违背操作系统的设置时
       会产生0x0d中断, 所以要强制结束程序只需要在0x0d中注册一个函数即可
    3) 具体例子请参见./os-src/toyosa2/



## **5. 保护操作系统** ##
    1) 操作系统会指定应用程序用的ds, 那么我们忽略系统指定的ds而用汇编语言直
       接将操作系统用的段地址存入ds的话, 就可以起到破坏作用了
    2) 具体例子请参见./os-src/toyosa3/
