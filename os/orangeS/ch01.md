# **一个最小的"操作系统"** #
***


## **1. 最小的操作系统** ##
    1) 编写一个最小的操作系统, 会显示一个红色的字符
    2) 具体例子请参见./os-src/os01/


## **2. 引导扇区** ##
    1) 计算机电源被打开后:
        * 进行加电自检(POST)
        * 寻找启动盘
        * 如选择从软盘启动, 会检查软盘的0面0磁道1扇区
        * 如果发现是以0xaa55结束, BIOS会认为这是一个引导扇区
    2) 一个正确的引导扇区除了以0xaa55结束外还应该包含一段少于512字节的执行码
    3) BIOS发现了引导扇区, 会将这512字节的内容装载到内存地址为0000:7c00, 然
       后跳转到0000:7c00处将控制权彻底交给这段引导代码
    4) 这样计算机不再由BIOS中的固有程序来控制, 而是由操作系统的一部分来控制
    5) 因此引导程序的第一行'org 07c00h', 是告诉编译器这段程序要被加载到内存
       偏移地址为7c00处 


## **3. NASM** ##
    1) nasm中, 任何不被[]括起来的标签或变量名都是地址, 访问标签中的内容必须
       使用[]
    2) jmp $ 表示让程序无限循环下去
    3) $ 表示当前被汇编后的地址
    4) $$ 表示一个节(section)的开始处被汇编后的地址



## **4. Bochs调试指令** ##
    1) b addr: 在某个物理地址设置断点(b 0x7c00)
    2) info break: 显示当前所有的断点信息
    3) c: 继续执行, 直到遇上断点
    4) s: 单步执行
    5) n: 单步执行(遇到函数则跳过)
    6) info cpu/r/fp/sreg/creg: 查看寄存器信息
    7) print-stack: 查看堆栈
    8) xp /nuf addr: 查看内存物理地址内容(xp /40bx 0x9013e)
    9) x /nuf addr: 查看线性地址内容(x /40bx 0x13e)
    10) u start end: 反汇编一段内存
    11) trace-on: 反汇编执行的每一条指令
    12) trace-reg: 每执行一条指令就打印CPU信息
