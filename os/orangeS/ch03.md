# **保护模式** #
***


## **1. 认识保护模式** ##
    1) 先来直观的看一个实模式切换到保护模式的例子
    2) 具体例子请参见./os-src/os02/
    3) 这个例子中, 我们做了如下操作:
        * 定义了一个GDT的数据结构, GdtLen是GDT的长度, GdtPtr是一个小的数据结
          构(6字节, 前2字节是GDT的界限, 后面4字节是基地址)
        * 16位代码进行了一些与GDT相关的操作
        * 32位代码进行了一点操作显存的工作
> ### **1.1 保护模式运行环境** ###
    1) 引导扇区空间有限, 只有512字节, 如果我们的程序越来越大超过512字节就不
       好办了, 那可以使用如下方法解决
        * 写一个引导扇区, 可以读取我们的程序并运行;
        * 把程序编译成COM文件, 然后让DOS来执行
    2) 操作步骤如下:
        * 下载一个FreeDos, 解压后将其中的a.img拷贝到我们的工作目录, 更名为
          freedos.img
        * bximage生成一个名为pm.img的软盘映像
        * 修改bochsrc文件, 确保有如下3行:
          floppya: 1_44=freedos.img, status=inserted
          floppyb: 1_44=pm.img, status=inserted
          boot: a
        * 启动bochs, 待freedos启动完毕后格式化B:盘
        * 将代码中的org 07c00h修改为0100h, 并重新编译
          $ nasm -o pmtest1.com pmtest1.s
        * 将pmtest1.com复制到虚拟软盘pm.img上
          $ sudo mount -o loop pm.img /mnt/floppy 
          $ sudo cp pmtest1.com /mnt/floppy/
          $ sudo umount /mnt/floppy 
        * 在FreeDos中执行命令
          > B:\pmtest1.com 
    3) 具体例子请参见./os-src/os03/
> ### **1.2 GDT(Global Descriptor Table)** ###
    1) I32下, CPU有实模式和保护模式两中工作模式
    2) 开始时CPU工作在实模式, 经过某种机制之后才进入保护模式
    3) 保护模式下, CPU具有巨大的寻址能力, 并为强大的32位系统提供了更好的硬件
       保护 
    4) Intel 8086是16位CPU, 具有16位寄存器, 16位数据总线, 20位的地址总线
    5) 物理地址 = 段值 * 16 + 偏移
    6) 在实模式下, 段值被看作是地址的一部分, 段值xxxxh表示以xxxx0h开始的一段
       内存; 在保护模式下, 虽然段值仍然是由原来16位的cs, ds等寄存器表示, 但
       此时它仅仅是一个索引, 这个索引指向一个数据结构的一个表项, 表项中详细
       定义了段的起始地址, 界限, 属性等内容;
    7) GDT的作用是用来提供段式存储机制 
    8) SelectorVideo是选择子, 是一个如下结构
       |15|14|13|12|11|10|9|8|7|6|5|4|3| 2 |1|0|
       -----------------------------------------
       |       Index of Descriptor     |TI |RPL|
       -----------------------------------------
       当TI和RPL都为0时, 选择子就表示描述符相对GDT基址的偏移, 否则是如上结构
> ### **1.3 实模式到保护模式, 不一般的jmp** ###
    1) gdtr的结构如下:
       |    32位基地址     | 16位界限 |
       lgdt [GdtPtr]作用是将GdtPtr指示的6个字节加载到寄存器gdtr中 
    2) A20地址线, 在8086中, ‘段:偏移’能访问的最大内存是ffff:ffff(10ffffh),  
       但是8086只有20位地址总线, 只能访问1MB, 如果试图访问超过1MB的地址就会
       回卷, 重新从地址0开始寻址; 
       但是到80286时, 为了保证兼容, 会控制第20个地址位, 这就是A20地址线, 如
       果不打开, 第20个地址位将从是0
    3) 打开A20地址线, 可以通过操作端口92h来实现
    4) cr0的结构如下
        31 30 29       19 18 17 16        6 5  4  3  2  1  0
       |PG|CD|NW|        |AM|  |WP|        |NE|ET|TS|EM|MP|PE|
       -------------------------------------------------------
    5) 寄存器cr0的第0位PE位是0时, CPU运行于实模式; 是1时, CPU运行于保护模式
    6) 进入保护模式的主要步骤如下:
        * 准备GDT
        * 用lgdt加载gdtr
        * 打开A20
        * 设置cr0的PE位
        * 跳转, 进入保护模式 
> ### **1.4 描述符号属性** ###
    1) 代码段和数据段描述符
       | BYTE7 |BYTE6|BYTE5|BYTE4|BYTE3|BYTE2|BYTE1|BYTE0|
       ---------------------------------------------------
       | 31..24| attribute |     23 .. 0     |   15..0   |
       | base2 |           |      base1      |  Limit 1  |
       ---------------------------------------------------
                    |
                    V 
       ---------------------------------------------
       |7| 6 |5| 4 | 3 | 2 | 1 | 0 |7|6|5|4|3|2|1|0|
       |---------------------------|---------------|
       |G|D/B|0|AVL| Limit2(19..16)|P|DPL|S| TYPE  |
       |---------BYTE6-------------|-----BYTE5-----| 
    2) 描述符各属性详情如下:
        * P位-存在位(Present); P=1表示段在内存中存在,P=0表示段在内存中不存在
        * DPL(Descriptor Privilege Level) - 描述符特权级, 可以是0~3, 数字越
          小权限越大
        * S位 - 指明描述符是数据段/代码段描述符(S=1)
                            还是系统段/门描述符(S=0) 
        * TYPE描述符类型
          TYPE值| 数据段和代码段描述符      |  系统段和门描述符 |
            0     只读                         <未定义>
            1     只读, 已访问                 可用286TSS
            2     读/写                        LDT
            3     读/写, 已访问                忙的286TSS
            4     只读, 向下扩展               286调用门
            5     只读, 向下扩展, 已访问       任务门
            6     读/写, 向下扩展              286中断门
            7     读/写, 向下扩展, 已访问      286陷阱门 
            8     只执行                       <未定义> 
            9     只执行, 已访问               可用386TSS 
            A     执行/读                      <未定义>
            B     执行/读, 已访问              忙的386TSS 
            C     只执行, 一致码段             386调用门
            D     只执行, 一致码段, 已访问     <未定义> 
            E     执行/读, 一致码段            386中断门 
            F     执行/读, 一致码段, 已访问    386陷阱门 
        * G位(段界限粒度Granularity位) - G=0时, 段界限粒度为字节
                                         G=1时, 段界限粒度为4KB
        * D/B位, 分为3种情况
          - 在可执行代码段描述符中, 这一位是D位; D=1时, 指令使用32位地址以及
            32位或8位操作数; D=0时, 使用16位地址以及16位或8位操作数 
          - 在向下扩展数据段的描述符中, 这一位是B位; B=1时,段的上部界限是4GB
            B=0时, 段的上部界限是64KB
          - 在描述堆栈段(ss寄存器指向的段)中, 这一位是B位; 
            B=1, 隐式的堆栈访问指令使用32位堆栈指针寄存器esp;
            B=0, 隐式的堆栈访问指令使用16位堆栈指针寄存器esp;
        * AVL - 保留位 
    3) 如果目标代码的特权级低的话, 无论是不是一致代码段, 都不能通过call或者
       jmp转移进去; 数据段都是非一致的, 表明不能被低特权级的代码访问, 但是可
       以被更高特权级的代码访问 




## **2. 保护模式进阶** ##
> ### **2.1 海阔凭鱼跃** ###
    1) 在保护模式下, 可以访问的内存空间高达4G, 我们修改程序来体验一下超过1MB
       的访问能力
    2) 让我们的程序更加优雅, 在程序的末尾条转回实模式
    3) 我们程序的修改如下:
        * 新建一个以5MB位基址的段, 先读出开始处8字节的内容在写入一个串, 再从
          中读取8字节的内容(两次读取的内容应该会不同)
        * 在32位保护模式的出来代码中, 我们让ds指向新增的数据段, es指向新增的
          5MB内存的段, gs指向显存; 我们提示一串信息后开始读取一段数据, 然后 
          写入一段数据再读取一段数据 
        * 结束保护模式回到实模式之前, 需要加载一个合适的描述符选择子到有关段
          寄存器, 以使对应段描述符高速缓冲寄存器中含有合适的段界限和属性; 而
          且我们不能直接在保护模式中返回只能从16位代码中返回
    4) 具体例子请参见./os-src/os04/
> ### **2. LDT(Local Descriptor Table)** ###
    1) 指令lldt, 负责加载ldtr; 它的操作数是一个选择子, 这个选择子对应的就是
       用来描述LDT的那个描述符 
    2) 选择子描述符中, 如果TI位被置位, 那么系统将从当前LDT中寻找相应的描述符
    3) LDT是一种与GDT类似的描述符, 它的选择子的TI位必须被置为1; 在使用它的时
       候, 需要先用lldt指令加载ldtr, lldt的操作数是GDT中用来描述LDT的描述符
    4) 添加一个LDT描述的任务的步骤如下:
        * 增加一个32位的代码段, 内容可以尽量的简单
        * 增加一个段, 内容是一个LDT描述符表, 可以只有一个代码段描述符, 也可
          以增加更多的描述符描述更多的段(涉及的选择子TI位必须是1)
        * 在GDT中增加一个描述符, 用来描绘苏这个LDT, 同时要定义其描述符
        * 增加新添的描述符的初始化代码, 主要是针对段基址
        * 用新增加的LDT描述的局部任务准备完毕
        * 使用前使用lldt加载ldtr, 用jmp跳转等方式运行
    5) 具体例子请参见./os-src/os05/
> ### **3. 特权级概述** ###
    1) 在I32分段机制中, 特权级总共有4个特权级别, 从高到低分别是0, 1, 2, 3;数
       字越小表示的特权级越大
       0    -> 内核
       1, 2 -> 服务
       3    -> 应用程序
    2) 较为核心的代码和数据, 将被放在特权级较高的层中; 处理器将用这样的机制
       来避免低特权级的任务在不被允许的情况下访问位于高特权级的段 
    3) CPL(Current Privilege Level), 当前执行的程序或任务的特权级
       被存储在cs和ss的第0位和第1位上, CPL等于代码所在的段的特权级, 当程序转
       移到不同特权级的代码段的时候, 处理器将改变CPL;
       一致代码段可以被相同或更低特权级的代码访问, 当处理器访问一个与CPL特权
       级不同的代码段时, CPL不会被改变;
    4) DPL(Descriptor Privilege Level), 表示段或者门的特权级
       存储在段描述符或者门描述符的DPL字段中, 当当前代码段试图访问一个段或者
       门的时候, DPL会和CPL以及段或门选择子的RPL进行比较, 根据段或门类型的不
       同, 分别处理
        * 数据段: DPL规定了可以访问此段的最低特权级
        * 非一致代码(不使用调用门的情况下): DPL规定访问此段的特权级
        * 调用门: DPL规定了当前执行程序或任务可以访问此调用门的最低特权级
        * 一致代码段和通过调用门访问的非一致代码段: DPL规定了访问此段的最高
          特权级 
        * TSS: DPL规定了可以访问此TSS的最低特权级
    5) RPL(Requested Privilege Level), 是通过段选择子的第0位和第1位表现出来
       通过检查RPL和CPL来确认一个访问请求是否合法, 即使提出访问请求的段有足
       够的特权级, 如果RPL不够也不能访问; 
       如果RPL的数字比CPL大, 那么RPL将会起决定性的作用;
    6) 我们将数据段的选择子的RPL修改为3, 运行就会崩溃, 因为我们违反了特权级
       规则, 用RPL=3的选择子去访问RPL=1的段;
       具体例子请参见./os-src/os06/ 
    7) 不同特权级代码段之间的转移
       使用jmp或call指令可以实现下面4中转移
        * 目标操作数包含目标代码的段选择子
        * 目标操作数指向一个包含目标代码段选择子的调用门描述符
        * 目标操作数指向一个包含目标代码段选择子的TSS
        * 目标操作数指向一个任务门, 这个任务门指向一个包含目标代码段选择子的
          TSS 
> ### **4. 特权级转移** ###
    1) 通过jmp或call进行直接转移
       通过jmp或call能进行的代码段间的转移是有限的, 对于非一致代码, 只能在
       相同特权级代码之间转移; 对于非一致代码最多能从低到高, 而且CPL不会改
       变
    2) 门就是个描述符, 门描述符的结构如下:
        |BYTE7|BYTE6|BYTE5|BYTE4|BYTE3|BYTE2|BYTE1|BYTE0|
        |-----|-----|-----|-----|-----|-----|-----|-----|
        |31..16shift| attribute | selector  |15..0 shift|
        -------------------------------------------------
                          |
                          V
        -----------------------------------------------------------------
        | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 
        -----------------------------------------------------------------
        | P |  DPL  | S |     TYPE      | 0 | 0 | 0 |    Param Count    |
        -----------------------------------------------------------------
        门描述符的结构就是这样, 就是一个门描述了由一个选择子和一个偏移所指
        定的线性地址, 程序正是通过这个地址进行转移的 
    3) 门描述符分为:
        * 调用门(Call gates)
        * 中断门(Interrupt gates)
        * 陷阱门(Trap gates) 
        * 任务门(Task gates)
    4) 我们使用一个简单的调用门, 先不涉及任何特权级变换
    5) 调用门本质上只是一个入口地址, 只是增加了若干的属性而已
    6) 具体例子请参见./os-src/os07/ 
    7) 调用门特权级规则
                          |     call     |    jmp
       ----------------------------------------------------
         consistent CS    |       CPL <= DPL_G, 
                          |       RPL <= DPL_G, 
                          |       DPL_B <= CPL
       ----------------------------------------------------
           uniform CS     |CPL <= DPL_G, | CPL <= DPL_G, 
                          |RPL <= DPL_G, | RPL <= DPL_G, 
                          |DPL_B <= CPL  | DPL_B = CPL 
       ----------------------------------------------------
       通过调用门和call指定, 可以实现从低特权级到高特权级的转移, 无论目标代
       码是一致还是非一致的
