# **保护模式** #
***


## **1. 认识保护模式** ##
    1) 先来直观的看一个实模式切换到保护模式的例子
    2) 具体例子请参见./os-src/os02/
    3) 这个例子中, 我们做了如下操作:
        * 定义了一个GDT的数据结构, GdtLen是GDT的长度, GdtPtr是一个小的数据结
          构(6字节, 前2字节是GDT的界限, 后面4字节是基地址)
        * 16位代码进行了一些与GDT相关的操作
        * 32位代码进行了一点操作显存的工作
> ### **1.1 保护模式运行环境** ###
    1) 引导扇区空间有限, 只有512字节, 如果我们的程序越来越大超过512字节就不
       好办了, 那可以使用如下方法解决
        * 写一个引导扇区, 可以读取我们的程序并运行;
        * 把程序编译成COM文件, 然后让DOS来执行
    2) 操作步骤如下:
        * 下载一个FreeDos, 解压后将其中的a.img拷贝到我们的工作目录, 更名为
          freedos.img
        * bximage生成一个名为pm.img的软盘映像
        * 修改bochsrc文件, 确保有如下3行:
          floppya: 1_44=freedos.img, status=inserted
          floppyb: 1_44=pm.img, status=inserted
          boot: a
        * 启动bochs, 待freedos启动完毕后格式化B:盘
        * 将代码中的org 07c00h修改为0100h, 并重新编译
          $ nasm -o pmtest1.com pmtest1.s
        * 将pmtest1.com复制到虚拟软盘pm.img上
          $ sudo mount -o loop pm.img /mnt/floppy 
          $ sudo cp pmtest1.com /mnt/floppy/
          $ sudo umount /mnt/floppy 
        * 在FreeDos中执行命令
          > B:\pmtest1.com 
    3) 具体例子请参见./os-src/os03/
> ### **1.2 GDT(Global Descriptor Table)** ###
    1) I32下, CPU有实模式和保护模式两中工作模式
    2) 开始时CPU工作在实模式, 经过某种机制之后才进入保护模式
    3) 保护模式下, CPU具有巨大的寻址能力, 并为强大的32位系统提供了更好的硬件
       保护 
    4) Intel 8086是16位CPU, 具有16位寄存器, 16位数据总线, 20位的地址总线
    5) 物理地址 = 段值 * 16 + 偏移
    6) 在实模式下, 段值被看作是地址的一部分, 段值xxxxh表示以xxxx0h开始的一段
       内存; 在保护模式下, 虽然段值仍然是由原来16位的cs, ds等寄存器表示, 但
       此时它仅仅是一个索引, 这个索引指向一个数据结构的一个表项, 表项中详细
       定义了段的起始地址, 界限, 属性等内容;
    7) GDT的作用是用来提供段式存储机制 
    8) SelectorVideo是选择子, 是一个如下结构
       |15|14|13|12|11|10|9|8|7|6|5|4|3| 2 |1|0|
       -----------------------------------------
       |       Index of Descriptor     |TI |RPL|
       -----------------------------------------
       当TI和RPL都为0时, 选择子就表示描述符相对GDT基址的偏移, 否则是如上结构
> ### **1.3 实模式到保护模式, 不一般的jmp** ###
    1) gdtr的结构如下:
       |    32位基地址     | 16位界限 |
       lgdt [GdtPtr]作用是将GdtPtr指示的6个字节加载到寄存器gdtr中 
    2) A20地址线, 在8086中, ‘段:偏移’能访问的最大内存是ffff:ffff(10ffffh),  
       但是8086只有20位地址总线, 只能访问1MB, 如果试图访问超过1MB的地址就会
       回卷, 重新从地址0开始寻址; 
       但是到80286时, 为了保证兼容, 会控制第20个地址位, 这就是A20地址线, 如
       果不打开, 第20个地址位将从是0
    3) 打开A20地址线, 可以通过操作端口92h来实现
    4) cr0的结构如下
        31 30 29       19 18 17 16        6 5  4  3  2  1  0
       |PG|CD|NW|        |AM|  |WP|        |NE|ET|TS|EM|MP|PE|
       -------------------------------------------------------
    5) 寄存器cr0的第0位PE位是0时, CPU运行于实模式; 是1时, CPU运行于保护模式
    6) 进入保护模式的主要步骤如下:
        * 准备GDT
        * 用lgdt加载gdtr
        * 打开A20
        * 设置cr0的PE位
        * 跳转, 进入保护模式 
> ### **1.4 描述符号属性** ###
    1) 代码段和数据段描述符
       | BYTE7 |BYTE6|BYTE5|BYTE4|BYTE3|BYTE2|BYTE1|BYTE0|
       ---------------------------------------------------
       | 31..24| attribute |     23 .. 0     |   15..0   |
       | base2 |           |      base1      |  Limit 1  |
       ---------------------------------------------------
                    |
                    V 
       ---------------------------------------------
       |7| 6 |5| 4 | 3 | 2 | 1 | 0 |7|6|5|4|3|2|1|0|
       |---------------------------|---------------|
       |G|D/B|0|AVL| Limit2(19..16)|P|DPL|S| TYPE  |
       |---------BYTE6-------------|-----BYTE5-----| 
    2) 描述符各属性详情如下:
        * P位-存在位(Present); P=1表示段在内存中存在,P=0表示段在内存中不存在
        * DPL(Descriptor Privilege Level) - 描述符特权级, 可以是0~3, 数字越
          小权限越大
        * S位 - 指明描述符是数据段/代码段描述符(S=1)
                            还是系统段/门描述符(S=0) 
        * TYPE描述符类型
          TYPE值| 数据段和代码段描述符      |  系统段和门描述符 |
            0     只读                         <未定义>
            1     只读, 已访问                 可用286TSS
            2     读/写                        LDT
            3     读/写, 已访问                忙的286TSS
            4     只读, 向下扩展               286调用门
            5     只读, 向下扩展, 已访问       任务门
            6     读/写, 向下扩展              286中断门
            7     读/写, 向下扩展, 已访问      286陷阱门 
            8     只执行                       <未定义> 
            9     只执行, 已访问               可用386TSS 
            A     执行/读                      <未定义>
            B     执行/读, 已访问              忙的386TSS 
            C     只执行, 一致码段             386调用门
            D     只执行, 一致码段, 已访问     <未定义> 
            E     执行/读, 一致码段            386中断门 
            F     执行/读, 一致码段, 已访问    386陷阱门 
        * G位(段界限粒度Granularity位) - G=0时, 段界限粒度为字节
                                         G=1时, 段界限粒度为4KB
        * D/B位, 分为3种情况
          - 在可执行代码段描述符中, 这一位是D位; D=1时, 指令使用32位地址以及
            32位或8位操作数; D=0时, 使用16位地址以及16位或8位操作数 
          - 在向下扩展数据段的描述符中, 这一位是B位; B=1时,段的上部界限是4GB
            B=0时, 段的上部界限是64KB
          - 在描述堆栈段(ss寄存器指向的段)中, 这一位是B位; 
            B=1, 隐式的堆栈访问指令使用32位堆栈指针寄存器esp;
            B=0, 隐式的堆栈访问指令使用16位堆栈指针寄存器esp;
        * AVL - 保留位 
    3) 如果目标代码的特权级低的话, 无论是不是一致代码段, 都不能通过call或者
       jmp转移进去; 数据段都是非一致的, 表明不能被低特权级的代码访问, 但是可
       以被更高特权级的代码访问 




## **2. 保护模式进阶** ##
> ### **2.1 海阔凭鱼跃** ###
    1) 在保护模式下, 可以访问的内存空间高达4G, 我们修改程序来体验一下超过1MB
       的访问能力
    2) 让我们的程序更加优雅, 在程序的末尾条转回实模式
    3) 我们程序的修改如下:
        * 新建一个以5MB位基址的段, 先读出开始处8字节的内容在写入一个串, 再从
          中读取8字节的内容(两次读取的内容应该会不同)
        * 在32位保护模式的出来代码中, 我们让ds指向新增的数据段, es指向新增的
          5MB内存的段, gs指向显存; 我们提示一串信息后开始读取一段数据, 然后 
          写入一段数据再读取一段数据 
        * 结束保护模式回到实模式之前, 需要加载一个合适的描述符选择子到有关段
          寄存器, 以使对应段描述符高速缓冲寄存器中含有合适的段界限和属性; 而
          且我们不能直接在保护模式中返回只能从16位代码中返回
    4) 具体例子请参见./os-src/os04/
> ### **2. LDT(Local Descriptor Table)** ###
    1) 指令lldt, 负责加载ldtr; 它的操作数是一个选择子, 这个选择子对应的就是
       用来描述LDT的那个描述符 
    2) 选择子描述符中, 如果TI位被置位, 那么系统将从当前LDT中寻找相应的描述符
    3) LDT是一种与GDT类似的描述符, 它的选择子的TI位必须被置为1; 在使用它的时
       候, 需要先用lldt指令加载ldtr, lldt的操作数是GDT中用来描述LDT的描述符
    4) 添加一个LDT描述的任务的步骤如下:
        * 增加一个32位的代码段, 内容可以尽量的简单
        * 增加一个段, 内容是一个LDT描述符表, 可以只有一个代码段描述符, 也可
          以增加更多的描述符描述更多的段(涉及的选择子TI位必须是1)
        * 在GDT中增加一个描述符, 用来描绘苏这个LDT, 同时要定义其描述符
        * 增加新添的描述符的初始化代码, 主要是针对段基址
        * 用新增加的LDT描述的局部任务准备完毕
        * 使用前使用lldt加载ldtr, 用jmp跳转等方式运行
    5) 具体例子请参见./os-src/os05/
> ### **3. 特权级概述** ###
    1) 在I32分段机制中, 特权级总共有4个特权级别, 从高到低分别是0, 1, 2, 3;数
       字越小表示的特权级越大
       0    -> 内核
       1, 2 -> 服务
       3    -> 应用程序
    2) 较为核心的代码和数据, 将被放在特权级较高的层中; 处理器将用这样的机制
       来避免低特权级的任务在不被允许的情况下访问位于高特权级的段 
    3) CPL(Current Privilege Level), 当前执行的程序或任务的特权级
       被存储在cs和ss的第0位和第1位上, CPL等于代码所在的段的特权级, 当程序转
       移到不同特权级的代码段的时候, 处理器将改变CPL;
       一致代码段可以被相同或更低特权级的代码访问, 当处理器访问一个与CPL特权
       级不同的代码段时, CPL不会被改变;
    4) DPL(Descriptor Privilege Level), 表示段或者门的特权级
       存储在段描述符或者门描述符的DPL字段中, 当当前代码段试图访问一个段或者
       门的时候, DPL会和CPL以及段或门选择子的RPL进行比较, 根据段或门类型的不
       同, 分别处理
        * 数据段: DPL规定了可以访问此段的最低特权级
        * 非一致代码(不使用调用门的情况下): DPL规定访问此段的特权级
        * 调用门: DPL规定了当前执行程序或任务可以访问此调用门的最低特权级
        * 一致代码段和通过调用门访问的非一致代码段: DPL规定了访问此段的最高
          特权级 
        * TSS: DPL规定了可以访问此TSS的最低特权级
    5) RPL(Requested Privilege Level), 是通过段选择子的第0位和第1位表现出来
       通过检查RPL和CPL来确认一个访问请求是否合法, 即使提出访问请求的段有足
       够的特权级, 如果RPL不够也不能访问; 
       如果RPL的数字比CPL大, 那么RPL将会起决定性的作用;
    6) 我们将数据段的选择子的RPL修改为3, 运行就会崩溃, 因为我们违反了特权级
       规则, 用RPL=3的选择子去访问RPL=1的段;
       具体例子请参见./os-src/os06/ 
    7) 不同特权级代码段之间的转移
       使用jmp或call指令可以实现下面4中转移
        * 目标操作数包含目标代码的段选择子
        * 目标操作数指向一个包含目标代码段选择子的调用门描述符
        * 目标操作数指向一个包含目标代码段选择子的TSS
        * 目标操作数指向一个任务门, 这个任务门指向一个包含目标代码段选择子的
          TSS 
> ### **4. 特权级转移** ###
    1) 通过jmp或call进行直接转移
       通过jmp或call能进行的代码段间的转移是有限的, 对于非一致代码, 只能在
       相同特权级代码之间转移; 对于非一致代码最多能从低到高, 而且CPL不会改
       变
    2) 门就是个描述符, 门描述符的结构如下:
        |BYTE7|BYTE6|BYTE5|BYTE4|BYTE3|BYTE2|BYTE1|BYTE0|
        |-----|-----|-----|-----|-----|-----|-----|-----|
        |31..16shift| attribute | selector  |15..0 shift|
        -------------------------------------------------
                          |
                          V
        -----------------------------------------------------------------
        | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 
        -----------------------------------------------------------------
        | P |  DPL  | S |     TYPE      | 0 | 0 | 0 |    Param Count    |
        -----------------------------------------------------------------
        门描述符的结构就是这样, 就是一个门描述了由一个选择子和一个偏移所指
        定的线性地址, 程序正是通过这个地址进行转移的 
    3) 门描述符分为:
        * 调用门(Call gates)
        * 中断门(Interrupt gates)
        * 陷阱门(Trap gates) 
        * 任务门(Task gates)
    4) 我们使用一个简单的调用门, 先不涉及任何特权级变换
    5) 调用门本质上只是一个入口地址, 只是增加了若干的属性而已
    6) 具体例子请参见./os-src/os07/ 
    7) 调用门特权级规则
                          |     call     |    jmp
       ----------------------------------------------------
         consistent CS    |       CPL <= DPL_G, 
                          |       RPL <= DPL_G, 
                          |       DPL_B <= CPL
       ----------------------------------------------------
           uniform CS     |CPL <= DPL_G, | CPL <= DPL_G, 
                          |RPL <= DPL_G, | RPL <= DPL_G, 
                          |DPL_B <= CPL  | DPL_B = CPL 
       ----------------------------------------------------
       通过调用门和call指定, 可以实现从低特权级到高特权级的转移, 无论目标代
       码是一致还是非一致的
    8) 关于堆栈
        * 在实模式下, 如果jmp或call是在段间进行的而不是在段内进行的, 那么就
          是长的(far jmp/call), 反之是短的(near jmp/call)
        * 对于jmp, 长跳转对应段间, 短跳转对应段内 
        * 对短调用, call执行时, 下一条指令的eip压栈, 到ret时, 该eip会从堆栈
          中弹出
        * 长调用, call执行时压栈的有cs和eip; ret时, 也需要调用者的cs, 需要 
          弹出cs和eip 
    9) 通过调用门进行有特权级变换的转移——理论
        * 每个任务最多都可能在4个特权级之间转移, 所以, 每个任务需要4个堆栈
        * 我们只有一个ss和esp, 当发生堆栈切换的时候需要使用到TSS, 它是一个数
          据结构, 里面包含了多个字段(结构图见./pic/TSS.jpg)
        * 调用门需要关心的结构是esp0到ss2这3个ss和3个esp, 当发生堆栈切换的时
          候, 内层的ss和esp就是从这里取得的
        * 转移过程如下:
          o 根据目标代码段的DPL从TSS中选择应该切换到哪个ss和esp
          o 从TSS中读取新的ss和esp; 这个过程中如果发现ss, esp或者TSS界限错误
            都会导致无效的TSS异常(#TS)
          o 对ss描述符进行检查, 如果发生错误, 同样发生#TS异常 
          o 暂存当前ss和esp的值
          o 加载新的ss和esp
          o 将刚保存起来的ss和esp压入新的堆栈
          o 从调用者堆栈中将参数复制到被调用者堆栈中, 复制参数的数目由调用门
            中的Param Count来决定, 如果Param Count是0的话, 将不会复制参数
          o 将当前的cs/eip压栈 
          o 加载调用门中指定的新的cs和eip, 开始执行被调用者过程 
        * ret指令带有特权级变换的长返回处理流程如下:
          o 检查保存的cs中的RPL以判断返回时是否要变换特权级 
          o 加载被调用者堆栈上的cs和eip 
          o 如果ret有参数, 则增加esp的值跳过参数, 然后esp将指向被保存过的调
            用者ss和esp(ret参数必须对应调用门中的Param Count的值)
          o 加载ss和esp, 切换到调用者堆栈, 被调用者的ss和esp被丢弃(会进行ss
            描述符, esp和ss段描述符的检验)
          o 如果ret指令有参数, 增加esp的值跳过参数(在调用者堆栈中)
          o 检查ds, es, fs, gs的值, 如果其中哪一个寄存器指向的段的DPL小于CPL
            那么一个空描述符会被加载到寄存器 
        * 从低特权级到高特权级, 通过调用门和call指令来实现; 从高特权级到低特
          权级, 通过ret来实现 
    10) 进入ring3
        * 在ret指令执行前, 堆栈中应该已经准备好了目标代码段的cs,eip,ss,esp, 
          还有参数
        * 具体例子请参见./os-src/os08/
    11) 通过调用门进行有特权级变换的转移——实践
        * 例子——我们在进入死循环之前增加使用调用门的指令, 修改描述符和选择子
          是为了满足CPL和RPL都小于等于调用门DPL的条件 
          具体例子请参见./os-src/os09/ 
        * 从低特权级到高特权级转移的时候需要使用TSS; 在准备好TSS之后, 我们需
          要在特权级变化之前加载它 
          具体例子请参见./os-src/os0a/
          o 在32位代码中显示提示符后, 保存TSS, 将ring3的ss/sp/cs/eip压栈, 然
            后跳转到ring3级代码
          o 在ring3中显示数字3后, 根据TSS, 使用调用门回到ring0
          o 在ring0调用门代码中显示字符C之后, retf到ring3级代码中进入死循环
        * 我们为了让程序回到实模式, 在进入调用门目标代码后, 将调用局部任务的
          代码加入其中, 程序将由这里进入局部任务最终返回实模式
          具体例子请参见./os-src/os0b/ 






## **3. 页式存储** ##
    1) 什么是页?
       就是一块内存, 在80386中, 页的固定大小是4096字节; 在Pentium中, 页的大
       小可以是2MB或者4MB, 并且可以访问到多于4GB的内存 
    2) 辑地址, 线性地址, 物理地址 
       未打开分页机制的时候, 线性地址等同于物理地址, 可以认为逻辑地址通过分
       段机制直接转换成物理地址; 
       分页机制开启的时候, 分段机制将逻辑地址转换成线性地址, 线性地址再通过
       分页机制转换成物理地址;
       逻辑地址---|分段机制|--->线性地址---|分页机制|--->物理地址 
    3) 分页的缘由
       实现虚拟存储器, 线性地址中任意一个页都能映射到物理地址中的任何一个页,
       这无疑使得内存管理变得相当灵活。。。
> ### **3.1 分页机制概述** ###
    1) 分页机制就像一个函数
       物理地址 = f(线性地址)
       转换使用两极页表, 第一级叫做页目录, 大小为4KB, 存储在一个物理页当中, 
       每个表项4字节长, 共有1024个表项; 
       每个表项对应第二级的一个页表, 第二级的每一个页表也有1024个表项, 每个 
       表项对应一个物理页; 
       页目录表的表项简称PDE(Page Directory Entry), 页表的表项简称PTE(Page 
       Table Entry); 
    2) 转换时, 先从cr3指定的页目录中根据线性地址的高10位得到页表地址, 然后在
       页表中根据线性地址的第12到21位得到物理页首地址, 将这个首地址加上线性 
       地址低12位便得到了物理地址
    3) 如果cr0的PG位=1, 则分页机制生效; so => 我们准备好了页目录表和页表, 并
       将cr3指向页目录表之后, 只需要设置PG位分页机制就可以开始工作了 
> ### **3.2 编写代码启动分页机制** ###
    1) 页目录表位于地址2MB处, 有1024个表项, 占用4KB空间
    2) 页表位于地址2MB+4KB处, 假定共有1024个页表, 每个页表占用4096字节, 则总
       共占用4MB空间 
    3) 将所有的线性地址映射到相同的物理地址
       物理地址 = f(线性地址) = 线性地址 
    4) 具体例子请参见./os-src/os0c/
> ### **3.3 PDE和PTE** ###
    1) PDE和PTE的结构图请参见./pic/PDE.jpg和./pic/PTE.jpg 
    2) P(存在位), 表示当前条目所指向的页或者页表是否在物理内存中; 
        * P=0表示不在内存中, 如果访问此页会产生页异常
        * P=1表示页在内存中
    3) R/W指定一个页或一组页的读写权限
        * 与U/S位和寄存器cr0中的WP位相互作用
        * R/W=0表示只读
        * R/W=1表示可读可写 
    4) U/S指定一个页或一组页的特权级
        * 与R/W位和寄存器cr0中的WP位相互作用
        * U/S=0表示系统级别, 如果CPL为0,1,2, 那么它便在此级别
        * U/S=1表示用户级别, 如果CPL=3, 则它在此级别
        * 如果cr0中的WP=0, 即便用户级页面的R/W=0, 系统级程序仍具有写权限
        * 如果cr0中的WP=1, 系统级程序也不能写入用户级的只读页
    5) PWT用于控制对单个页或者页表的缓冲策略
        * PWT=0 使用Write-back缓冲策略
        * PWT=1 使用Write-through缓冲策略 
        * cr0的CD位被设置时会被忽略
    6) PCD用于控制单个页或者页表的缓冲
        * PCD=0 页和页表可以被缓冲
        * PCD=1 页和页表不可被缓冲
        * cr0的CD位被设置时会被忽略
    7) A指示页或页表是否被访问
    8) D指示页或页表是否被写入
    9) PS决定了页的大小
        * PS=0, 页大小为4KB, PDE指向页表 
    10) PAT, 选择PAT(Page Attribute Table)条目(设置为0)
    11) G, 指示全局页
        * 如果此位被设置, 同时cr4中的PGE被设置, 此页的页表或页目录条目不会在
          TLB中变得无效, 即便cr3被加载或人物切换的时候也是这样的 
    12) 处理器会将最近常用的页目录和页表项保存到TLB缓冲区中, 找不到的时候才
       会到内存中寻找; 
       当页目录和页表项被修改的时候, 操作系统应该立刻使TLB中对应的条目无效;
       cr3被加载的时候, 所有TLB都会自动无效(除非页和页表条目的G被设置) 
> ### **3.4 cr3** ###
    1) cr3的结构如下:
       31                         12           5   4   3     0
       --------------------------------------------------------
       |        Page Dir Base       |           |PCD|PWT|     |
       --------------------------------------------------------
    2) cr3又叫PDBR(Page-Directory Base Register), 高20位将是页目录表首地址的
       高20位, 页目录表首地址的低12位为0;
       页目录表是4KB对齐的;
> ### **5. 节约使用内存** ###
    1) 操作系统必须知道内存的容量, 以便进行管理
    2) 获取机器内存的一种通用性方法是利用中断15h
    3) 在调用中断15h之前需要填充如下寄存器:
        * eax -> 想要获取内存信息, 需要将ax赋值为0e820h
        * ebx -> 放置"后续值", 第一次调用时ebx必须为0
        * es:di -> 指向一个地址范围描述符结构ARDS, BIOS会填充此结构
        * ecx -> es:di所指向的地址范围描述符结构的大小, 以字节为单位
        * edx -> 0534d4150h, BIOS将会使用这个标志, 对调用者将要请求的系统映
          像信息进行校验, 这些信息会被BIOS放置到es:di所指向的结构当中
    4) 中断调用之后, 结果会被放置在下列寄存器当中
        * cf -> cf=0表示没有错误, 否则出现错误
        * eax -> 0534d4150h(`SAMP`)
        * es:di -> 返回的地址范围描述符结构指针, 和输入值一样
        * ecx -> BIOS填充在地址范围描述符中的字节数量, BIOS所返回的最小值是
          20字节
        * ebx -> 为等到下一个地址描述符所需要的后续值, 依赖于具体的BIOS实现,
          调用者不必关心它的具体形式, 只需在下次迭代时将其原封不动放置到ebx
          中就可通过它获取得到下一个地址范围描述符
          ebx=0, 且cf没有进位, 表示它是最后一个地址范围描述符
    5) 地址范围描述符结构如下
        Offset  |     Name      | Meaning
        0       | BaseAddrLow   | 基地址的低32位
        4       | BaseAddrHigh  | 基地址的高32位
        8       | LengthLow     | 长度(字节)的低32位
        12      | LengthHigh    | 长度(字节)的高32位
        16      | Type          | 这个地址范围的地址类型
    6) Type的取值如下:
        Value   |     Name              | Meaning
        -------------------------------------------------------------------
        1       | AddressRangeMemory    | 这个内存是一段可被OS使用的RAM
        -------------------------------------------------------------------
        2       | AddressRangeReserved  | 该地址段正在被使用, 活被系统保留,
                |                       | 不能被OS使用
        -------------------------------------------------------------------
        Other   | Unknown               | 保留, 任何其他值都会被OS认为是
                |                       | AddressRangeReserved 
        ------------------------------------------------------------------- 
    7) 获取机器的内存并显示出来
       具体例子请参见./os-src/os0d/
    8) 内存情况解释
        Memory Segment      | Attribute               | 是否可被OS使用
        00000000h~0009fbffh | AddressRangeMemory      | YES
        0009fc00h~0009ffffh | AddressRangeReserved    | NO
        000e8000h~000fffffh | AddressRangeReserved    | NO
        00100000h~01ffffffh | AddressRangeMemory      | YES
        fffc0000h~ffffffffh | AddressRangeReserved    | NO 
> ### **3.6 进一步体会分页机制** ###
    1) DEMO(使用分页机制)
       先执行某个线性地址处的模块, 然后通过改变cr3来转换地址映射关系, 再执行
       同一个线性地址处的模块, 由于地址映射已经改变, 两次应该得到不同的输出 
    2) 具体例子请参见./os-src/os0e/
    3) 由于分页机制的存在, 程序使用的都是线性地址空间, 而不再是直接物理地址 






## **4. 中断和异常** ##
    1) 在保护模式下, 中断机制需要使用IDT(Interrupt Descriptor Table)中断描述
       符表; IDT可能是下面三种之一:
        * 中断门描述符
        * 陷阱门描述符
        * 任务门描述符
    2) 中断门和陷阱门的结构如下:
       | BYTE7 | BYTE6 | BYTE5 | BYTE4 | BYTE3 | BYTE2 | BYTE1 | BYTE0 |
       -----------------------------------------------------------------
       |     31..16    |               |               |      15..0    |
       |     offset    |  attributes   |   selector    |      offset   |
       -----------------------------------------------------------------
                              |
                              V
       -----------------------------------------------------------------
       | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       -----------------------------------------------------------------
       | P |  DPL  | S |     TYPE      | 0 | 0 | 0 |     Reserved      |
       -----------------------------------------------------------------
       | -------->  BYTE5   <--------- | -----------> BYTE4 <----------|
    3) 对比调用门, 中断门和陷阱门BYTE4的低5位是保留位, 而不是Param Count, 且
       表示TYPE的4位也将变成0xE(中断门)或0xF(陷阱门); S位依旧是0;
> ### **4.1 中断和异常机制** ###
    1) 中断通常在程序执行时因为硬件而随机发生, 通常用来处理处理器外部的事件,
       比如外围设备的请求;
       异常通常在处理器执行指令过程中检测到错误时发生, 比如遇到零除的情况;
    2) 每一种中断(异常)都会对应一个中断向量号, 这个向量号通过IDT就与相应的中
       断处理程序对应起来了
    3) 保护模式中的中断和异常表请参见书
    4) 异常:
        * Fault是一种可被更正的异常, 且一旦被更正, 程序可以不失连续性的继续
          执行;
          当一个Fault发生的时候, 处理器会把产生fault的指令之前的状态保存起来
          异常处理程序的返回地址是产生fault的指令, 而非其后的指令
        * Trap是一种发生trap的指令执行之后立即被报告的异常, 也允许程序不失连
          续的继续执行;
          异常处理程序的返回地址是产生trap的指令之后的那条指令
        * Abort是一种不总是报告精确异常发生位置的指令, 不允许程序继续执行, 
          用来报告严重错误
> ### **4.2 外部中断** ###
    1) 中断有两种产生原因
        * 由硬件产生的中断 —— 外部中断 
        * 由int n产生的中断
    2) 外部中断分为不可屏蔽中断和可屏蔽中断, 分别由CPU的两根引脚NMI和INTR来
       接收
       具体结构请参见图./pic/8295A.jpg
    3) NMI不可屏蔽, 与IF是否被设置无关; NMI对应的中断向量号是2 
    4) BIOS初始化8295A的时候, IRQ0~IRQ7被设置为对应向量号08h~0fh; 在保护模式
       下08h~0fh被占用, 对8295A的设置需要通过相应的端口写入特定的ICW
       (Initialization Command Word)来实现的;
       主8295A对应的端口号地址是20h和21h, 从8295A对应的端口号地址是a0h和a1h;
       ICW有4个, 每一个对应不同的格式的字节;
    5) 初始化8295A的过程如下
        * 往端口20h或a0h写入ICW1
        * 往端口21h或a1h写入ICW2
        * 往端口21h或a1h写入ICW3
        * 往端口21h或a1h写入ICW4 
    6) ICW的4种格式请参见书或其他资料
