# **保护模式** #
***


## **1. 认识保护模式** ##
    1) 先来直观的看一个实模式切换到保护模式的例子
    2) 具体例子请参见./os-src/os02/
    3) 这个例子中, 我们做了如下操作:
        * 定义了一个GDT的数据结构, GdtLen是GDT的长度, GdtPtr是一个小的数据结
          构(6字节, 前2字节是GDT的界限, 后面4字节是基地址)
        * 16位代码进行了一些与GDT相关的操作
        * 32位代码进行了一点操作显存的工作
> ### **1.1 保护模式运行环境** ###
    1) 引导扇区空间有限, 只有512字节, 如果我们的程序越来越大超过512字节就不
       好办了, 那可以使用如下方法解决
        * 写一个引导扇区, 可以读取我们的程序并运行;
        * 把程序编译成COM文件, 然后让DOS来执行
    2) 操作步骤如下:
        * 下载一个FreeDos, 解压后将其中的a.img拷贝到我们的工作目录, 更名为
          freedos.img
        * bximage生成一个名为pm.img的软盘映像
        * 修改bochsrc文件, 确保有如下3行:
          floppya: 1_44=freedos.img, status=inserted
          floppyb: 1_44=pm.img, status=inserted
          boot: a
        * 启动bochs, 待freedos启动完毕后格式化B:盘
        * 将代码中的org 07c00h修改为0100h, 并重新编译
          $ nasm -o pmtest1.com pmtest1.s
        * 将pmtest1.com复制到虚拟软盘pm.img上
          $ sudo mount -o loop pm.img /mnt/floppy 
          $ sudo cp pmtest1.com /mnt/floppy/
          $ sudo umount /mnt/floppy 
        * 在FreeDos中执行命令
          > B:\pmtest1.com 
    3) 具体例子请参见./os-src/os03/
> ### **1.2 GDT(Global Descriptor Table)** ###
    1) I32下, CPU有实模式和保护模式两中工作模式
    2) 开始时CPU工作在实模式, 经过某种机制之后才进入保护模式
    3) 保护模式下, CPU具有巨大的寻址能力, 并为强大的32位系统提供了更好的硬件
       保护 
    4) Intel 8086是16位CPU, 具有16位寄存器, 16位数据总线, 20位的地址总线
    5) 物理地址 = 段值 * 16 + 偏移
    6) 在实模式下, 段值被看作是地址的一部分, 段值xxxxh表示以xxxx0h开始的一段
       内存; 在保护模式下, 虽然段值仍然是由原来16位的cs, ds等寄存器表示, 但
       此时它仅仅是一个索引, 这个索引指向一个数据结构的一个表项, 表项中详细
       定义了段的起始地址, 界限, 属性等内容;
    7) GDT的作用是用来提供段式存储机制 
    8) SelectorVideo是选择子, 是一个如下结构
       |15|14|13|12|11|10|9|8|7|6|5|4|3| 2 |1|0|
       -----------------------------------------
       |       描述符索引              |TI |RPL|
       -----------------------------------------
       当TI和RPL都为0时, 选择子就表示描述符相对GDT基址的偏移, 否则是如上结构
> ### **1.3 实模式到保护模式, 不一般的jmp** ###
    1) gdtr的结构如下:
       |    32位基地址     | 16位界限 |
       lgdt [GdtPtr]作用是将GdtPtr指示的6个字节加载到寄存器gdtr中 
    2) A20地址线, 在8086中, ‘段:偏移’能访问的最大内存是ffff:ffff(10ffffh),  
       但是8086只有20位地址总线, 只能访问1MB, 如果试图访问超过1MB的地址就会
       回卷, 重新从地址0开始寻址; 
       但是到80286时, 为了保证兼容, 会控制第20个地址位, 这就是A20地址线, 如
       果不打开, 第20个地址位将从是0
    3) 打开A20地址线, 可以通过操作端口92h来实现
    4) cr0的结构如下
        31 30 29       19 18 17 16        6 5  4  3  2  1  0
       |PG|CD|NW|        |AM|  |WP|        |NE|ET|TS|EM|MP|PE|
       -------------------------------------------------------
    5) 寄存器cr0的第0位PE位是0时, CPU运行于实模式; 是1时, CPU运行于保护模式
    6) 进入保护模式的主要步骤如下:
        * 准备GDT
        * 用lgdt加载gdtr
        * 打开A20
        * 设置cr0的PE位
        * 跳转, 进入保护模式 
> ### **1.4 描述符号属性** ###
    1) 代码段和数据段描述符
       | BYTE7 |BYTE6|BYTE5|BYTE4|BYTE3|BYTE2|BYTE1|BYTE0|
       ---------------------------------------------------
       | 31..24|属性(如下) |     23 .. 0     |   15..0   |
       |段基址2|           |     段基址1     |  段界限1  |
       ---------------------------------------------------
                    |
                    V 
       ---------------------------------------------
       |7| 6 |5| 4 | 3 | 2 | 1 | 0 |7|6|5|4|3|2|1|0|
       |---------------------------|---------------|
       |G|D/B|0|AVL|段界限2(19..16)|P|DPL|S| TYPE  |
       |---------BYTE6-------------|-----BYTE5-----| 
    2) 描述符各属性详情如下:
        * P位-存在位(Present); P=1表示段在内存中存在,P=0表示段在内存中不存在
        * DPL(Descriptor Privilege Level) - 描述符特权级, 可以是0~3, 数字越
          小权限越大
        * S位 - 指明描述符是数据段/代码段描述符(S=1)
                            还是系统段/门描述符(S=0) 
        * TYPE描述符类型
          TYPE值| 数据段和代码段描述符      |  系统段和门描述符 |
            0     只读                         <未定义>
            1     只读, 已访问                 可用286TSS
            2     读/写                        LDT
            3     读/写, 已访问                忙的286TSS
            4     只读, 向下扩展               286调用门
            5     只读, 向下扩展, 已访问       任务门
            6     读/写, 向下扩展              286中断门
            7     读/写, 向下扩展, 已访问      286陷阱门 
            8     只执行                       <未定义> 
            9     只执行, 已访问               可用386TSS 
            A     执行/读                      <未定义>
            B     执行/读, 已访问              忙的386TSS 
            C     只执行, 一致码段             386调用门
            D     只执行, 一致码段, 已访问     <未定义> 
            E     执行/读, 一致码段            386中断门 
            F     执行/读, 一致码段, 已访问    386陷阱门 
        * G位(段界限粒度Granularity位) - G=0时, 段界限粒度为字节
                                         G=1时, 段界限粒度为4KB
        * D/B位, 分为3种情况
          - 在可执行代码段描述符中, 这一位是D位; D=1时, 指令使用32位地址以及
            32位或8位操作数; D=0时, 使用16位地址以及16位或8位操作数 
          - 在向下扩展数据段的描述符中, 这一位是B位; B=1时,段的上部界限是4GB
            B=0时, 段的上部界限是64KB
          - 在描述堆栈段(ss寄存器指向的段)中, 这一位是B位; 
            B=1, 隐式的堆栈访问指令使用32位堆栈指针寄存器esp;
            B=0, 隐式的堆栈访问指令使用16位堆栈指针寄存器esp;
        * AVL - 保留位 
    3) 如果目标代码的特权级低的话, 无论是不是一致代码段, 都不能通过call或者
       jmp转移进去; 数据段都是非一致的, 表明不能被低特权级的代码访问, 但是可
       以被更高特权级的代码访问 
