# **VS Debug**
***



## **Summary**
 * 记录使用VS进行调试的一些技巧



## **1. VS Watch窗口**
 * 伪变量
  - @err:           当前断点处GetLastError()的值
  - $handles:       当前应用句柄数量
  - $clk:           以时钟形式显示时间
  - $vframe:        显示当前堆栈帧的地址
  - $env:           显示环境块的大小
  - @reg || $reg:   查看寄存器内容(@eax, @esp, @ebp, @ecx ...)
  - @eax:           最近一次函数返回值, 64位系统使用@rax
  - $tid:           当前线程ID
  - $pid:           当前进程ID
  - $user:          当前OS用户名字
  - $cmdline:       进程命令行
 * 数值格式化
  - 0x10,wm:        WM_CLOSE
  - 0x00400000,wc:  WS_OVERLAPPEDWINDOW
  - @err,hr:        0x00000002系统找不到指定的文件
  - hr:             HRESULT或Win32错误代码
  - wc:             窗口类标志
  - wm:             Windows消息数字
  - !:              原始格式
  - 进制转换  
        (1). 123,i:   有符号十进制  
        (2). 123,d:   有符号十进制  
        (3). 123,u:   无符号十进制  
        (4). 123,o:   无符号八进制  
        (5). 123,x:   小写十六进制 123,h  
        (6). 123,X:   大写十六进制 123.H  
 * 内存查看
  - ptr:            当成字符串查看(含地址)
  - ptr,s:          当成字符串查看(不含地址)
  - ptr,8:          当成BYTE[8]查看 
  - ptr,mb:         当成BYTE[16]查看 
  - ptr,mw:         当成WORD[8]查看 
  - ptr,md:         当成DWORD[4]查看 
  - ptr,mq:         当成ULONGLONG[2]查看 
  - ptr,c:          单个字符
  - ptr,sb:         ASCII字符串
  - ptr,sub:        Unicode字符串
  - ptr,s8:         UTF-8字符串
  - ptr,s8b:        UTF-8字符串 
  - ptr,bstr:       BSTR字符串 



## **2. 调试技巧**
> ### **1. 异常中断**
    在处理被调用之前, 异常发生时可以启动调试器进行中断, 可以让你在异常发生后
    立即调试程序; 
    Debug -> Exception;
    Ctrl+Alt+E;
> ### **2. Watch窗口中的伪变量**
    请见上一个说明
> ### **3. 符号越界后查看堆对象**
    符号越界后你还想查看对象的值, 这个时候Watch窗口中的变量是被禁用的, 不能
    再查看;
    如果你指导对象的地址, 可以将地址转换为该对象类型的指针, 放在Watch查看;
> ### **4. 查看数组的值**
    如果查看的数组很大, 可以使用(array+<offset>),<count>去查看从<offset>位置
    开始的特定范围的<count>个元素;
> ### **5. 避免进入不必要的函数**
    想要跳过一些函数, 需要在注册表里面添加一些值:
    1. 实际位置取决于你使用的VS版本和操作系统平台
    2. 值的名字是数字, 代表规则的优先级; 数字越大, 优先级越高;
    3. 值数据是一个正则表达式的REG_SZ, 指定怎样过滤和执行;
    在注册表HKEY_LOCAL_MACHINE\Software\Microsoft\VisualStudio\10.0\NativeDE\StepOver
> ### **6. 从代码启动调试器Launch the debugger from code**
    可以在程序中产生中断给调试器一个机会通过调用内部的__debugbreak()来附加调
    试器;
        void break_for_debugging(void) {
          __debugbreak();
        }
    也可以在X86平台触发中断3;
        __asm int 3;
> ### **7. 在Output窗口打印**
    调用DebugOutputString;
> ### **8. 隔离内存泄漏**
    在一个特定(可复现)位置中断的步骤:
    1. 确定你有足够的关于内存泄漏的报告模式
    2. 多次运行程序直到你能在程序运行结束后的内存泄漏报告里找到一个可复现的
       分配编号
    3. 在程序一开始的地方设置一个断点以便你能尽早进行中断
    4. 在最初的中断发生是, Watch的Name显示:{,,msvcr90d.dll}_crtBreakAlloc, 
       在Value里写入你想要查找的位置编号
    5. 继续调试(F5)
    6. 程序执行到指定位置会停止, 你可以使用调用栈被指引找到被该位置触发的那
       段代码;
> ### **9. 调试发行版**
    编译选项设置/Zi /Od
    链接选项设置/DEBUG 
> ### **10. 远程调试**
    1. 需要在远程机器上安装远程调试监控
    2. 远程调试监控必须以管理员身份运行, 并且用户比哦许属于管理员组
    3. 在你运行监控时, 会开启一个新的服务, 名字必须用VS的Attach to Progress
       窗口的Qualifier组合框的值
    4. 远程和本地机器上的防火墙必须允许VS和远程调试监控之间能通信
    5. PDB文件必须要
        - 本地PDB文件必须可用(远程机器的相同路径下放置一个对应的模块)
        - 远程机器上的托管PDB文件必须可用
> ### **11. 数据断点**
    当数据在内存位置变化时, 让调试器中断;
    数据点点只能在调试的过程中添加(调试->新断点->新数据断点)或者通过断点窗口
    来添加;
> ### **12. 线程重命名**
    在Thread窗口, 给你的线程重新设置一个名字;
    也可以用程序的方式来给线程命名RaiseException
> ### **13. 指定线程设置断点**
    可以使用断点的Filer命令来实现(筛选器);
    允许使用线程名, 线程ID, 进程名, 进程ID和机器名的不同组合;
> ### **14. 定时执行**
    计算执行一个代码块的时间(不精确);
    在Watch窗口或Immediate窗口添加@clk=0重置计时器;
    1. 在代码块起始位置设置断点;
    2. 在代码块结束位置设置断点;
    3. 在Watch窗口添加@clk;
    4. 当第一个断点触发, 在立即窗口中输入@clk=0;
    5. 运行程序, 直到遇到代码结束块位置的断点, 并在Watch窗口查看@clk的值;
> ### **15. 格式化数字**
    请参见上一个主题"VS Watch窗口"
> ### **16. 格式化内存数据**
    请参见上一个主题"VS Watch窗口"
> ### **17. 在系统DLL调用处暂停**
    需要使用原生debugger提供的上下文运算符, 可以设定断点位置, 变量名或表达式
    1. {[函数],[源代码],[模块]}断点位置
    2. {[函数],[源代码],[模块]}变量名
    3. {[函数],[源代码],[模块]}表达式
    可以使用DBH.exe来获取一个特定函数的修饰名字(编译器生成的名字);
    如:
        {,,Kernel32.dll}_CreateThreadStub@24 
> ### **18. 载入符号**
    当你调试程序的时候, 调用堆栈窗口不会显示全部的调用堆栈, 会忽略系统DLL的
    信息;
    可以在Tools->Options->Debugging->Symbols中配置
> ### **19. 在MFC中报告内存泄漏**
    使用DEBUG_NEW来重定义new运算符;
    #ifdef _DEBUG
    # define new DEBUG_NEW
    #endif
> ### **20. 调试ATL**
    需要在预处理定义或预编译头文件中定义两个宏:
    _ATL_DEBUG_QI
    _ATL_DEBUG_INTERFACES
    必须在atlbase.h包含之前定义
