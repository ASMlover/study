# **Game开发技巧**



## **1. B*自动寻路算法**
> ### **1.1 定义**
    1) 探索节点: 在寻路过程中向前探索的节点为探索节点, 其实节点就是探索节点;
    2) 自由探索节点:
       探索节点朝着目标前进, 如果前方不是阻挡, 探索节点可以继续向前进入下一
       个地图格子, 这种探索节点自由探索节点;
    3) 绕爬的探索节点:
       探索节点朝着目标前进, 如前方阻挡, 探索节点将试图绕过阻挡, 绕行的探索
       节点就是绕爬的探索节点;
> ### **1.2 算法**
    1) 探索节点为自由节点, 从原点出发, 向目标前进;
    2) 自由节点前进中判断前面是否为障碍:
       a) 不是障碍, 向目标前进一步, 仍为自由节点;
       b) 是障碍, 以前方障碍为界, 分左右两个分支, 分别视图绕过障碍, 这两个分
          支节点就成了两个绕爬的探索节点
    3) 绕爬的探索节点绕过障碍后又成为自由节点, 回到2);
    4) 探索节点前进后, 判断当前地图格子是否为目标格子, 如果是则寻路成功, 根
       据寻路过程构造出完整路径;
    5) 寻路过程中, 如果探索节点没有了, 则寻路结束, 表明没有目标格子, 不能够
       到达;



## **2. 简易自动寻路算法**
    1) 在场景中标记出若干waypoint, 这些点一般在大片无障碍区域的中央以及分叉
       路口(可以靠人工设置);
       Waypoint设置重点: 场景中所有可达区域都能至少看到一个waypoint;
    2) 将所有waypoint用直线连接起来, 得到一张图;
    3) 每次需要得到场景任意两点间的路径, 从起始点和目标点各取一个临近可见的
       waypoint, 然后求这两个waypoint之间在图上的最短路径;
    4) 得到路径后角色在场景行走时, 间隙判断是否可以直接看到路径上的下一个
       waypoint, 只要可以看到就沿直线朝路径上最远可见的waypoint移动;



## **3. 简易排行**
    适用与积分区间不大(0 ~ 5000)
    1) 做5000个桶, 每一个桶里记录这个分数有多少个人;
    2) 玩家分数变化, 把原来的桶玩家数减一, 新的桶加一;
    3) 排行查询仅需要把分数靠前的桶累加, 则可以知道查询者的名次;
    4) 真正需要精确知道的人名是榜单前n(100)个, 对前n个做排序也很快;



## **4. 海量玩家积分排行**
> ### **4.1 简单SQL查询**
    select 1 + count(uid) from rank where uid = uid and score > uscore;
    主要应对数据规模比较小, 性能要求不是太高的情况;
> ### **4.2 均匀分区设计**
    积分按照1000分区段分表, 更新数据的时候相应修改对应区段的表;
    玩家的积分首先可确定其所属的区段, 把高于s积分的区段的count累加, 在查出
    玩家在该用户区段的排名, 二者相加即可;
> ### **4.3 积分排名数组**
    用一个大小为1000000的数组表示积分和排名对应关系, rank[s]表示s积分所对应
    的排名;
    当积分从s变成s+n后, 只需要将rank[s]~rank[s+n-1]n个元素的值增加1即可;



## **5. MySQL读写性能**
    * 测试的是每秒的吞吐量
    * 写性能
      不开binlog, guid主键, 无索引: myisam(1639), innodb(971)
      开binlog, guid主键, 无索引:   myisam(675), innodb(374)
      开binlog, guid主键, 有索引:   myisam(599), innodb(329)
      开binlog, 自增值主键, 有索引: myisam(595), innodb(347)
    * 读性能
      guid主键:       myisam(2372), innodb(2553)
      自增值主键:     myisam(2195), innodb(2273)

    * 结论:
      1) 开启binlog, 写性能下降60%
      2) myisam与innodb相比, 写速度更快(快40%), 读速度差不多;


## **6. redis**
> ### **6.1 优点**
    1) 高性能 - 支持超过100K+/s的读写频率;
    2) 数据类型丰富 - strings, lists, hashes, sets和sorted sets;
    3) 原子 - 所有操作都是原子操作, 还支持几个操作合并后的原子性执行;
    4) 丰富的特性 - 支持publish/subscribe, 通知, key过期等等;
> ### **6.2 持久化**
    1) 快照: 定期将数据以异步方式从内存以RDB格式写入磁盘;
        * 默认的持久化方式;
          save 900 1    # 900秒内超过一个key被修改, 则发起快照保存
          save 300 10   # 300秒内超过10个key被修改, 则发起快照保存
        * 过程:
          a. redis调用fork(有子进程和父进程);
          b. 父进程继续处理client请求, 子进程负责将内存内容写到临时文件; 由
             于OS的写时复制机制父子进程会共享相同的物理页面, 当父进程处理写
             请求时OS会为父进程要修改的页面创建副本, 而不是写共享的页面; 所
             以子进程的数据是fork时整个数据库的一个快照;
          c. 子进程将快照写入临时文件后, 用临时文件替换原来的快照, 子退出;
    2) 追加: AOF格式, 将数据集修改操作记录下来, 可在后台对只可追加的记录做
             修改来避免无限增长的日志;
        * Append-Only File
          比快照有更好的数据持久化, redis会将每一个收到的写命令都追加到文件;
          重启是会通过重新执行文件中保存的写命令在内存中重建整个数据库内容;
          appendonly yes      # 启用AOF持久化方式
          appendfsync always  # 每次收到写命令都立即写入磁盘, 最慢
          appendfsync everysec  # 每秒强制写一次磁盘, 推荐
          appendfsync no      # 完全依赖操作系统, 性能最好, 持久化没保证
        * bgrewriteaof命令: 将内存数据以命令方式保持到临时文件, 替换原文件
          a. redis调用fork
          b. 子根据内存中的数据快照, 将重建数据库状态命令写入临时文件
          c. 父进程继续处理client请求, 处理把命令写入原来aof文件; 同时将收到
             的写命令缓存起来, 这样如果子进程重写失败也不会出问题;
          d. 当子将快照写入临时文件后, 通知父; 父将缓存的命令写入临时文件;
          e. 父用临时文件替换原来的aof文件, 重命名; 后面收到的写命令也往新的
             aof文件追加;

## **7. 网络同步**
> ### **7.1 状态同步**
    * 主控端点击技能按钮，技能开始播放动作，主控端上行告知服务器技能开始
    * 服务器广播给所有客户端，告知其他客户端此玩家开始执行技能。其他玩家客户端收到指定后播放技能表现
    * 服务器延迟一段时间后进行技能结算，并将结果通知客户端。
        延时时间=技能前摇时间-上行-下行（下行一般不确定，默认上行=下行）
      也可以：
        延时时间=技能前摇时间-上行（防止要求技能前摇时间过长）
    * 要求技能前摇时间>2倍网络延迟，若前摇过短则延迟时间为0，效果可能差一些。
      主控端表现完美，其他客户端可能出现看到主动端释放技能，前摇还没结束就开始结算了。
    1) 瞬时技能:
      * authority发送技能请求到server
      * server计算伤害结果同步到authority和proxy-client
      * authority和proxy-client播放技能动画并在跳伤害跳字、扣血等
    2) 延时技能（弹道等）
      * authority发送技能请求到server
      * server创建子弹（或前摇）并广播给authority和proxy-client，客户端播放弹道或前摇
      * server过一段时间计算伤害结果并同步给authority和proxy-client
      * authority和proxy-client播放技能结果或命中并伤害跳字、扣血等
    3) 法术场、弹道同步
      * server创建一个法术场，通知客户端
      * server端法术场每隔一段时间结算一次，结算的时候检测到攻击目标则计算伤害信息将结果发送给客户端，客户端收到信息后播放相应的表现
      * server端法术场时间到了之后在销毁时通知所有客户端销毁法术场
      * 弹道类似，区别是server每隔一段时间根据飞行速度等去检测目标碰撞
    4) buff同步
      * buff是附加在entity上的东西，server只需要确认buff是否挂在一个entity上
      * 客户端和服务端都维护一个buff管理器，挂buff的消息通知所有客户端，客户端负责表现，服务端负责结算
    5) 伤害、属性同步
      * 技能、buff、法术场、弹道都可能造成伤害，当服务器发现造成伤害时，搜线计算伤害，然后将结果同步到所有客户端，所有客户端接收到消息后播放伤害表现等
      * 血量、攻击力、速度等基础信息可以使用属性同步（即值改变了，底层立即同步给客户端）
> ### **7.2 帧锁定同步**
    * 对反外挂不友好
    * 所有的表现、数据都是在客户端执行的，断线重连也很难（需要在重连的时候重传所有的控制信息）
    * 帧取决于网络延迟最严重的那个客户端
    1) 总体流程：
      * 客户端定时上传控制信息
      * 服务器收到所有控制信息后广播给所有客户端
      * 客户端用服务器下发更新消息中的控制信息进行游戏
      * 如果客户端在下一个关键帧没收到服务器的更新消息则等待
      * 如果客户端在下一个关键帧收到来服务器的更新消息，则将其中的控制信息用于游戏，并采集当前的控制信息发送到服务器，继续进行下去
      * 服务器采集到所有数据后再次发送下一个关键帧更新消息
    2) 客户端流程
      2.1 - 判断当前是否是关键帧f1，不是则跳转到（2.7）
      2.2 - 如果是关键帧，看有没有f1的update数据，没有则重复（2.2）等待
      2.3 - 采集f1的输入作为控制数据与f1编号一起发送给服务器
      2.4 - 从update f1中得到下一个关键帧的号码f2以及下一个关键帧之间的输入数据in-data
      2.5 - 从f1到下一个关键帧f2之间的虚拟输入都使用in-data
      2.6 - let f1=f2
      2.7 - 执行该帧逻辑
      2.8 - 跳转到（2.1）
    3) 服务器流程
      3.1 - 收集所有客户端本关键帧f1的控制数据，等待直到收集完所有的控制数据
      3.2 - 根据所有的控制数据，计算下一个关键帧f2的update数据，计算再下一个关键帧编号f3
      3.3 - 将update数据发送到所有客户端
      3.4 - let f1=f2
      3.5 - 跳转到（3.1）
> ### **7.3 乐观帧锁定同步**
    * 针对帧锁定改进为定时不等待的乐观方式在每次帧时间触发的时候固定将操作广播给所有客户，不以来具体每个玩家是否有操作更新
    1) 流程
      * 服务器20次/s ~ 50次/s相所有客户端发送更新消息(包括所有客户端的操作和递增的帧序号)
      * 客户端如播放录像一样不停播放这些包含每帧玩家操作的update信息
      * 客户端如果没有update消息了，就需要等到，直到有新的update消息到来
      * 如果客户端一下收到很多连续的update消息，则需要快进播放
      * 客户端只要有控制操作就发消息到服务器（可以不按每帧才采集）
