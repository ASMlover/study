# **协同程序(coroutine)** #
***

        协同程序与线程差不多, 有自己独立的栈, 局部变量和指令指针; 同时又与其
    他协同程序共享全局变量和其他大部分东西。
        一个具有多线程的程序可以同时运行多个线程, 协同程序却需要彼此协作的运
    行; 一个具有多个协同程序的程序在任意时刻只能运行一个协同程序, 其正在运行
    的协同程序只会在其显示的要求挂起的时候, 其执行才会暂停。

## **1. 协同程序基础** ##
    1) lua将所有关于协同程序的函数放到一个名为"coroutine"的table中
    2) create用于创建新的协同程序, 只有一个参数, 就是一个函数
    3) create返回一个thread类型的值, 表示新的协同程序
    4) 一个协同程序有4中状态: 挂起(suspended), 运行(running), 死亡(dead)以及
       正常
    5) 新创建的协同程序处于挂起状态; 协同程序不会在创建它的时候自动执行
    6) 可以使用status来检查协同程序的状态
    7) coroutine.resume => 启动或再次启动一个协同程序的执行, 并将其状态由挂
       起修改为运行
    8) 协同程序可以使用yield让一个运行中的协同程序挂起, 而之后可以在恢复它的
       运行
        co = coroutine.create(function ()
            for i = 1, 10 do
              print("co", i)
              coroutine.yield()
            end
          end)
       当唤醒这个协同程序时, 它即开始执行, 直到第一个yield为止
    9) 在协同程序的角度, 所有在它挂起时发生的活动都发生在yield调用中, 当协同
       程序恢复执行的时候, 对yield的调用才返回; 然后协同程序继续执行, 直到下
       一个yield调用或结束
    10) resume是在保护模式中运行的, 如果在一个协同程序的执行中发生任何错误, 
        lua将不会显示错误信息, 而是将执行权返回给resume调用 
    11) 协同程序的另一项机制就是可以通过一对resume-yield来交换数据;
        第一次调用resume时, 并没有对应的yield等它, 因此所有传递给resume的额
        外参数都是传递给协同程序主函数的参数;
        resume调用返回值中, 第一个值为true则表示没错误, 而后面的所有值都是对
        应yield传入的参数;
        yield返回的额外值就是对应resume传入的参数;
        当一个协同程序结束时, 它的主函数所返回的值都将作为对应resume的返回值


## **2. 管道与过滤器** ##
    1) 当协同程序调用yield时, 是从一个悬而未决的resume调用中返回
    2) 对resume的调用也是从一次yield调用中返回



## **3. 以协同程序实现迭代器** ##
    1) wrap与create类似, 创建一个新的协同程序
    2) wrap并不是返回协同程序本身, 而是返回一个函数
    3) 每次调用这个函数的时候, 就可以唤醒一次协同程序, 但与resume不同之处在
       它不会返回错误代码, 遇到错误的时候, 它会引发错误


## **4. 非抢先式的多线程** ##
    1) 协同程序提供了一种协作式的多线程, 都等同于一个线程, 一对yield-resume
       可以讲执行权在不同线程之间切换
    2) 协同程序与常规多线程不同在于, 协同程序是非抢先式的
