# **I/O库** #
***

## **1. 简单I/O模型** ##
    1) 简单模型的所有操作都作用于两个当前文件, I/O库将当前输入文件初始化为进
       程标准输入, 将当前输出文件初始化为进城标准输出
    2) io.input(filename)调用会以只读模式打开指定的文件, 并将其设置为当前输
       入文件; 之后除非再次调用io.input, 否则所有的输入都将来源于这个文件
    3) io.output也可以完成类似的工作
    4) io.write接受任意数量的字符串参数, 并将它们写入当前输出文件; 也接受数
       字参数, 数字参数会根据常规的转换规则转换为字符串
    5) io.read从当前输入文件中读取字符串, 其参数为
        "*all"      读取整个文件
        "*line"     读取下一行
        "*number"   读取一个数字
        <num>       读取一个不超过<num>个字符的字符串
    6) io.read(0)用于检查是否到达了文件末尾, 如果还有数据可读, 会返回一个空
       字符串, 否则返回nil


## **2. 完整I/O模型** ##
        该模型基于文件句柄, 等价于C语言中的流(FILE*); 打开一个文件, 可以使用
    io.open, 其仿照了C语言的fopen函数, 具有两个参数, 一个是要打开的文件名, 
    另一个是模式字符串。
        "r" -> 读取, "w" -> 写入, "a" -> 追加, "b"表示打开二进制; 返回表示文
    件的新句柄, 若发生错误, 返回nil;
        打开一个文件后, 就可以使用read/write方法读写文件了:
        local f = assert(io.open(filename, "r"))
        local t = f:read("*all")
        f:close()
        I/O库提供了3个预定义C语言流的句柄: io.stdin, io.stdout和io.stderr, 
    这样就可以直接将信息写到错误流:
        io.stderr:write(message)
> ### **2.1 性能小诀窍** ###
    1) 一次性读取整个文件比逐行读取快(限小文件)
    2) 处理大文件时, 使用足够大的块(如, 8KB大小的块)来读取文件; 为了避免在行
       中间断开, 可以在读一个块时在加上:
       local lines, rest = f:read(BUFSIZE, "*line")
       rest包含了被块嗦断开的那行的剩余部分
> ### **2.2 二进制文件** ###
    1) io.input和io.output总是以文本方式打开文件, UNIX中二进制和文本无差别, 
       但在其他系统(Windows)必须在io.open的模式字符串中带有"b"
    2) 通常在读取二进制数据时, 使用*all模式来读取整个文件, 或者使用<num>模式
       来读取n个字节
> ### **2.3 其他文件操作** ###
    1) 函数tmpfile返回一个临时文件的句柄, 这个句柄以读写方式打开; 这个文件会
       在程序结束时自动删除
    2) 函数flush会将缓冲中的数据写入文件
    3) seek -> 可以获取和设置一个文件的当前位置; f:seek(whence, offset), 
       whence的有效值有: 
        "set" -> offset解释为相对于文件起始的偏移量; 
        "cur" -> offset解释为相对于当前位置的偏移量;
        "end" -> offset解释为相对于文件末尾的偏移量;
       调用file:seek()会返回当前的文件位置
