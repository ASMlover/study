# **构造, 解析, 拷贝语意学** #
*** 

## **1. 引子** ##
        //! C++
        class Abstract_base {
        public:
          virtual ~Abstract_base(void) = 0;
          virtual void interface(void) const = 0;
          virtual const char* mumble(void) const { return mumble_; }
        protected:
          char* mumble_;
        };
> ### **1.1 纯虚函数的存在** ###
    1) 纯虚析构函数, 类的设计者一定得定义它; 因为每一个子类的析构函数会被编
       译器加以扩展, 以静态调用的方式调用其每一个虚基类以及上一层基类的析构
       函数; 因此, 只要缺乏任何一个基类析构函数的定义, 都会导致连接失败... 
    2) 不要将虚析构函数声明为纯虚的 
> ### **1.2 虚拟规格的存在** ###
        将所有的成员函数都声明为虚函数, 然后再靠编译器的优化操作把非必要的虚
    函数去除, 是一个不好的设计观念;
> ### **1.3 虚拟规格中的const的存在** ###
        为一个抽象基类的虚函数设置const的时候, 确实很难决定; 不将函数声明为
    const, 该函数不能获得以一个const引用或const指针; 然而声明一个函数为const
    却发现其构造实例必须修改某一个成员数据;
        所以最好不在抽象基类中的虚函数使用const就是了
> ### **1.4 重新设计的类声明** ###
        //! C++
        class Abstract_base {
        public:
          virtual ~Abstract_base(void);
          virtual void interface(void) = 0;
          const char* mumble(void) const 
          {
            return mumble_;
          }
        protected:
          Abstract_base(char* pc = NULL);
          char* mumble_;
        };




## **2. 无继承情况下的对象构造** ##
    1) 一个对象的生命是该对象的一个执行期属性; 局部对象的声明从其定义开始到
       该作用域结束为止; 全局对象的声明和整个程序的生命相同; 堆对象的生命从
       它被new出来开始到它被delete销毁为止
> ### **2.1 抽象数据类型** ###
    1) 对然明确的初始化列表效率很高但明确的初始化列表有如下三个缺点:
        * 只有当类成员数是public时才有效
        * 只能指定常量, 因为它们在编译时期就可以被评估求值
        * 由于编译器并没有自动施行, 所以初始化行为的失败可能会比较高
> ### **2.2 为继承做准备** ###
    1) 在类中有虚函数的情况下, 除了每一个类对象多负担一个vptr, 虚函数的引入
       也引发编译器对我们的类产生膨胀作用
        * 我们所定义的构造函数被附加一些代码, 以便将vptr初始化; 这些附加的代
          码必须被附加在任何基类构造的调用之后, 但是必须在任何由程序员提供的
          代码之前
        * 合成一个拷贝构造和一个拷贝赋值操作, 而且其操作不再是不重要的; 如果
          一个类对象被初始化或以一个子类对象赋值, 那么以位为基础(bitwise)的
          操作可能给vptr带来非法的设定
    2) 编译器在优化状态下可能会把对象的连续内容拷贝到另一个对象身上, 而不是
       实现一个精确的以成员为基础的赋值操作
    3) 如果你的设计之中有许多函数都需要以传值方式传回一个local类对象, 如:
        //! C++
        T operator +(const T&, const T&)
        {
          T result;
          //! ...
          return result;
        }
        那么提供一个拷贝构造就是合理的——甚至默认memberwise语意就足够了
