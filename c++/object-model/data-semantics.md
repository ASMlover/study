# **Data语意学(The Semantics of Data)** #
***

        例子:
        //! C++
        class X {};
        class Y : public virtual X {};
        class Z : public virtual X {};
        class A : public Y, public Z {};
        在主流的C++编译器上, 各个类的大小分别为: sizeof(X)=1, sizeof(Y)=4, 
    sizeof(Z)=4, sizeof(A)=8;
        而类Y和类Z的大小受3个因素的影响:
        1) 语言本身所造成的额外负担
           当语言支持虚基类时, 就会导致一些额外负担; 在子类中, 其反映在某种
           形式的指针上, 它要么是指向虚基类子对象, 要么指向一个相关的表格; 
           表格中不是存放虚基类子对象的地址就是其偏移量
        2) 编译器对于特殊情况所提供的优化处理
           虚基类X的子对象的1字节也出现在类Y和Z上, 传统上它被放在子类的固定
           部分的尾端;
           某些编译器会对空虚基类提供特殊处理;
        3) Alignment的限制
           类Y和Z限制是5字节, 但是在大部分及其上, 结构体大小受到alignment的 
           限制, 使得它们更有效率地在内存中读取;
        
        空虚基类提供了一个虚接口, 没有定义任何数据; 在新近的编译器上, 一个空
    虚基类被视为子类对象最开头的一部分, 即没有花费任何的额外空间(因为既然有
    了成员, 就不需要原本为了空类而安插的一个char了).
        一个虚基类子对象只会在子类中存在一份实体, 不管它在类继承体系中出现了
    多少次, 类A的大小由下列几点决定:
        1) 被共享的唯一一个class X实体, 大小为1字节
        2) 基类Y的大小, 减去因虚基类X而配置的大小, 为4字节; 类Z相同
        3) 类A自己的大小
        4) 类A的alignment数量(如有的话); 因此大小为12字节
        而对于对空虚基类做了处理的编译器, 类X实体中的1字节将被拿掉, 那么字节
    对齐的3字节就不必要了, 则大小为8字节;
        C++对象模型尽量以空间优化和存取速度优化的考虑来表现非静态数据成员, 
    并且保持和C语言struct数据配置的兼容性, 它将数据直接存放在每一个类对象之
    中; 对继承而来的非静态数据成员也是如此; 静态数据成员被放置在程序的一个全
    局数据段中, 不会影响个别类对象的大小; 不管该类被产生出多少个对象, 静态数
    据成员永远只存在一份实体;
        每一个类对象必须有足够的大小以便容纳它所有的非静态数据成员:
        1) 由编译器自动加上的额外数据成员, 以便支持语言特性
        2) 因为alignment(边界调整)的需求


## **1. Data Member的绑定(The Binding of a Data Member)** ##
