# **二叉树** #
*** 

## **1. 二叉树特点** ##
    1) 每个节点最多只有两个子树
    2) 左子树与右子树是有序的, 不能随意颠倒
    3) 树中即使只有一个子树也要分是左子树还是右子树


## **2. 二叉树基本形态** ##
    1) 空二叉树
    2) 只有一个根节点
    3) 根节点只有左子树
    4) 根节点只有右子树
    5) 根节点既有左子树也有右子树


## **3. 特殊二叉树** ##
> ### **3.1 斜树** ###
    1) 所有节点都只有左子树 => 左斜树
    2) 所有节点都只有右子树 => 右斜树
> ### **3.2 满二叉树** ###
    所有的分支节点都有左子树和右子树, 且所有叶子都在同一层上  
    满二叉树特点:
    1) 叶子只能在最下一层
    2) 非叶子节点的度一定是2
    3) 在同样深度的二叉树中, 满二叉树节点最多, 叶子最多
> ### **3.3 完全二叉树** ###
    对一颗具有n个节点的二叉树按层序编号, 如果编号为i[1, n]的节点与同样深度的满二叉树中的编号为i的节点在二叉树中位置完全相同, 则这颗二叉树为完全二叉树  
    完全二叉树特点:
    1) 叶子节点只能出现在最下两层
    2) 最下层的叶子一定集中在左部连续位置
    3) 倒数第2层, 若有叶子节点, 一定都在右部连续位置
    4) 如果节点度为1, 则该节点只有左孩子, 不存在只有右子树的情况
    5) 同样节点数的二叉树, 完全二叉树的深度最小


## **4. 二叉树的性质** ##
    1) 二叉树第i层最多有2^(i-1)个节点
    2) 深度为k的二叉树最多有2^k - 1个节点
    3) 对任意一一棵二叉树, 如果终端节点数为n0, 度为2的节点数为n2, 则n0 = n2 + 1
    4) 具有n个节点的完全二叉树的深度为[log2n] + 1 ([x]为取整数值)
    5) 对具有n个节点的完全二叉树的节点按层序编号, 对任一节点有:
        a) 如i=1, 则节点i是二叉树的跟, 无双亲; 如i>1, 则其双亲是节点[i/2]
        b) 如2i>n, 则节点i无左孩子; 否则其左孩子是节点2i
        c) 如2i+1>n, 则节点i无右孩子; 否则其右孩子是节点2i+1



## **5. 二叉搜索树** ##
    其性质是比节点小的在左子树, 比节点大的在右子树
> ### **5.1 性质** ###
    1) 若左子树不为空, 左子树所有节点的值均小于根节点的值
    2) 若右子树不为空, 右子树所有节点的值均大于根节点的值
    3) 左、右子树也分别为二叉树
> ### **5.2 查找算法** ###
    在二叉查找树b中查找k  
    1) 若b为空, 则查找失败
    2) 若k等于b的根节点的数据域的值, 则查找成功
    3) 若k小于b的根节点的数据域的值, 则查找左子树
    4) 查找右子树
> ### **5.3 插入算法** ###
    向一个二叉查找树b中插入一个节点n  
    1) 若b为空, 则将n所指的节点作为根节点
    2) 若n->data等于b的根节点的数据域的值, 返回
    3) 若n->data小于b的根节点的数据域的值, 把n所指的节点插入到左子树
    4) 把n所指的节点插入到右子树
> ### **5.4 删除节点算法** ###
    1) 若*p节点是叶子节点, 只需要修改其双亲节点的指针即可, 直接删除*p节点
    2) 若*p节点只有左子树或右子树, 只需要令左子树或右子树直接成为其双亲节点*f的左子树或者右子树即可
    3) 若*p节点的左子树和右子树均不为空, 在删除*p之后, 为保持其他元素之间的相对位置不变, 可按中序遍历保持有序进行调整。其一是令*p的左子树为*f的左/右子树, *s为*p左子树的最右下的节点, 而*p的右子树为*s的右子树; 其二是令*p的直接前驱替代*p, 然后再从二叉排序树中删去它的直接前驱
