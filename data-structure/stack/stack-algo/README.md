# **Stack相关的算法** #
***
    这里主要记录了Stack相关的算法操作


## **1. 得到Stack中的最大值(最小值)** ##
* 获取Stack中的最大值(最小值)
* 要求时间复杂度为O(1)

> ### **1.1 分析** ###
    1) 一般的方法是遍历Stack内部每一个元素的值, 但是这样的时间复杂度是O(n)
    2) 其他的一些查询最大方法(二分查找等)也不能到达O(1)
    3) 我们就可以想象将最大值放在Stack对象中, 但是pop掉元素的时候, 有可能最大值已经不再Stack中了
    4) 那我们在每次push的时候将最大值记录到每个节点上
    5) 在插入的时候需要取得上一个节点的最大值, 需要耗费一定的时间
    6) 如果考虑将当前的最大值同时放到Stack对象上, 那pop的时候需要更新存储在Stack对象上的最大值, 同样消耗了pop的效率
    7) 最后, 打算只将最大值放到节点上, 不再放到Stack对象上(目前我只能想  
       到如此)
> ### **1.2 实现** ###
    请参见目录./stack-fetch-max/


## **2. 共享Stack** ##
* 多个栈共享一个大数据区(该数据区一开始就申请好的)
* 要求可以任意多个栈

> ### **2.1 实现** ###
    1) 要求每一个栈的元素数据类型相同(其实可以使用void*来实现多态)
    2) 每一个栈的相对数据空间大小是固定的(或者说每个栈的空间相等)这一个可以使用其他方式来定制, 可以使得每一个栈的空间各不相同
    3) 根据栈id对每个栈进行操作(push, pop, peek ...)
    4) 具体实现请参见./stack-shared/



## **3. 解析算术表达式** ##
* 输入一个计算式(加减乘除四则混合运算)
* 解析该表达式并计算出结果

> ### **3.1 分析** ###
    1) 该四则运算式是一个中缀表达式, 需要先转换成后缀表达式
    2) 利用后缀表达式来求取四则运算的结果
> ### **3.2 实现** ###
    1) 将四则运算式转换为后缀表达式
       a) 将数字输出, 运算符压栈
       b) 如果遇到一个运算符是')', 则一直出栈输出运算符, 直到'('为止
       c) 如果运算符的优先级比栈顶的优先级高, 将运算符压栈
       d) 如果运算符的优先级比栈顶的优先级低, 则所有运算符出栈, 并压栈该运算符
       e) 原式子遍历结束后出栈所有运算符
    2) 计算后缀表达式的值
       a) 将所有的数字压栈
       b) 遇到运算符, 出栈两个数字元素
       c) 根据运算符计算两个出栈的元素
       d) 将计算的结果压栈
       e) 如此循环
    3) 具体实现请参见./stack-calc/



## **4. 括号匹配判断** ##
* 要求输入一串括号'()', '[]'
* 判断输入的这一串括号是否匹配

> ### **4.1 分析** ###
    1) 一串符号中只能是() []
    2) 括号可以嵌套
    3) 每一对括号必须匹配
    4) 可以使用栈的方式来实现, 遇到右括号就出栈查询匹配
> ### **4.2 实现** ###
    1) 算法的判断以Stack来实现
    2) 只要是左括号就压栈
    3) 只要是右括号就出栈, 判断出栈的括号是否匹配
    4) 最后栈为空则匹配
    5) 具体实现请参见./stack-bracket-match/



## **5. 数制转换** ##
* 要求输入一个10进制数
* 按照需求转换为规定的进制数

> ### **5.1 实现** ###
    1) 根据进制数取余压栈
    2) 计算结束后再依次出栈则是所需的数值
    3) 具体实现请参见./stack-conversion/



## **6. 两个栈实现队列** ##
* 使用两个栈来实现队列

> ### **6.1 思路** ###
    1) 有两个栈一个进stack_in, 一个出stack_out
    2) enqueue的时候直接将值push到stack_in
    3) dequeue的时候, 如果stack_out为空, 则将stack_in的元素依次倒入stack_out中, 最后一个直接返回
    4) dequeue的时候, 如果stack_out不为空, 则直接pop一个
> ### **6.2 实现** ###
    1) 具体实现请参见./stack-queue/
