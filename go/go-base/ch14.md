# **并发concurrency** #
***


## **concurrency** ##
    1) goroutine只是由官方实现的超级"线程池", 每个实例4~5k的栈内存占用和由于
       实现机制而减少的创建和销毁开销, 是go高并发的根本原因
    2) 并发由切换时间片来实现"同时运行", 并行则是直接利用多核实现多线程的
       运行, 但是Go可以设置使用的核数量, 以便发挥多核计算机的能力
    3) Go使用通信来共享内存
    4) 创建一个goroutine直接使用go <funcName> 即可


## **Channel** ##
    1) 是goroutine沟通的桥梁, 大都是阻塞同步的
    2) 通过make创建, close关闭
    3) channel是引用类型
    4) 可使用for range来迭代不断操作channel
    5) 可设置单向或双向通道
    6) 可设置缓存大小, 在未被填满之前不会发生阻塞
    7) 使用缓存计数方式来判定任务完成退出main, 具体例子请参见./demo/demo0b/
    8) 使用等待数组来判断所有任务完成, 具体例子请参见./demo/demo0c/


## **Select** ##
    1) 可处理一个或多个channel的发送于接收
    2) 同时有多个可用的channel时按随机顺序处理
    3) 可用空的select来阻塞main函数
    4) 可设置超时
